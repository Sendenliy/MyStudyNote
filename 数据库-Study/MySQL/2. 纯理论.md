## 第1章 绪论

1. 数据库概述（四个基本概念）
<img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231174822068.png" alt="image-20231231174822068" style="zoom:23%;" />
  

   数据：

   - 定义：数据是信息的具体表现形式，描述事物的符号记录
   - 数据的表现形式：数字、文字、图形、图像和声音等

   数据库：

   - 定义：数据库DB是长期储存在计算机内，有组织的、可共享的大量数据的集合。
   - 特点：按照数据模型组织，具有较小的冗余度，具有较高的独立性，被用户所共享

   数据库管理系统：

   - 定义：数据库管理系统DBMS是位于用户与操作系统之间的一层数据管理软件。
   - 用途：组织和存储好大量的数据，并提供方便、高效地检索数据和维护数据的手段。
   - 主要功能：数据定义功能；数据组织、存储和管理功能；数据操纵功能；数据库的事务管理和运行管理；数据库的建立和维护功能

   数据库系统：

   - 定义：数据库系统DBS是指在计算机系统中引入数据库后的系统。存储、管理、处理和维护的系统。
   - 构成：数据库，数据库管理系统，应用系统，数据库管理员

   

2. 数据管理技术的发展

   - 人工管理
     - 数据不保存、数据由程序管理、数据不共享、没有独立性

   - 文件系统管理
     - 数据可以长期保存，由文件系统管理、共享性和独立性差

   - 数据库管理

     - 数据长期存储、由DBMS管理、数据整体结构化、共享性和独立性较高

     - 由层次、网状数据库到关系数据库

     - 由关系数据库到对象关系、面向对象数据库

3. 数据库系统数据的特点

   **整体结构化：**

   - 整体数据的结构化是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。
   - 数据库不仅数据内部是结构化的，而且整体是结构化的，数据之间 是具有联系的。

   **独立性：**

   - 数据独立性：数据独立于应用程序（由DBMS的二级映像功能来保证的）
   - 物理独立性：指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。
   - 逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。

   **共享性高：**

   - 数据被多用户、多应用共享使用
   - 减少数据冗余，节约存储空间；避免数据之间的不相容与不一致；可以根据用户需求增加新的应用

   **由DBMS统一管理和控制：**（DBMS对数据的控制功能）

   - 数据的安全性保护
   - 数据的完整性检查
   - 并发控制
   - 数据库恢复

4. 数据模型

   模型是对现实世界中某个对象特征的模拟和抽象。

   定义：

   - 数据模型也是一种模型，它是对现实世界数据特征的数字化抽象。

   - 描述现实世界的实体及之间的联系；能存放在计算机中，通过计算机软件进行处理；数据模型用来描述数据、组织数据和操作数据

   类型：

   - 概念模型：也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。
   - 逻辑模型和物理模型
     - 逻辑模型：主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。
     - 物理模型：描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231180159819.png" alt="image-20231231180159819" style="zoom:33%;" />

   组成要素：

   - 数据结构 
     描述数据库的组成对象，以及对象之间的联系
     是对系统静态特性的描述
   - 数据操作 
     对数据库中各种对象（型）的实例（值）允许执行的操作及有关的操作规则。
     数据操作是对系统动态特性的描述
   - 数据的约束条件 
     一组完整性规则的集合。
     完整性规则是对数据模型中数据及其联系定义的制约和储存规则。

5. 概念模型

   基本概念：

   - 实体：客观存在并可相互区别的事物
   - 属性：实体所具有的某一特性
   - 码：唯一标识实体的属性集
   - 实体型：用实体名及属性名集合来抽象和刻画同类实体
   - 实体集：同一类型实体的集合

   两个实体型间的联系：

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231180529074.png" alt="image-20231231180529074" style="zoom:33%;" />

   多个实体型间的联系：

   - 多个实体型间的一对多联系：
     若实体集E1，E2，...，En存在联系，对于实体集Ej中的给定实体，最多只和Ei中的一个实体相联系，则我们说Ei与E1，E2，...，Ei-1，Ei+1，...，En之间的联系是一对多的。

     <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231181131197.png" alt="image-20231231181131197" style="zoom:33%;" />

   - 多个实体型间的一对一联系，多个实体型间的多对多联系

     <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231181219764.png" alt="image-20231231181219764" style="zoom:33%;" />

   同一个实体集内各实体间的联系：

   - 一对多联系：<img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231181440568.png" alt="image-20231231181440568" style="zoom:33%;" />

   概念模型的表示方法：实体－联系方法 ( E-R方法)

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231181830136.png" alt="image-20231231181830136" style="zoom:23%;" />

   - 实体型：用矩形表示，矩形框内写明实体名。

   - 属性：用椭圆形表示，并用无向边将其与相应的实体连接起来

   - 联系
     联系本身：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n或m:n）  

     联系的属性：联系本身也是一种实体型，也可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来。

6. 常用的数据模型

   这里讲的数据模型都是逻辑上的，是计算机能够理解且被 DBMS 支持的数据视图

   层次模型：树的组织形式

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231182058814.png" alt="image-20231231182058814" style="zoom:23%;" />

   网状模型：图的形式组织数据

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231182109158.png" alt="image-20231231182109158" style="zoom:25%;" />

   层次、网状模型：

   - 数据之间的关联关系由复杂的指针关系来维护，结构描述复杂
   - 数据检索操作依赖于由指针系统指示的路径
   - 逐一记录的操作，不能有效支持记录集合的操作

   关系模型：
   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231182217248.png" alt="image-20231231182217248" style="zoom:25%;" />

   - 在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。
   - 关系必须是规范化的，满足一定的规范条件。
     最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表 。
   - 基本概念
     - 关系：一个关系对应通常说的一张表。
     - 元组：表中的一行即为一个元组。
     - 属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名。
     - 码：表中的某个属性组，它可以唯一确定一个元组。
     - 域：属性的取值范围。
     - 分量：元组中的一个属性值。
     - 关系模式：对关系的描述。表示为：关系名（属性1，属性2，…，属性n）例如学生（学号，姓名，年龄，性别，系，年级）

   - 数据之间的关联关系由Table中属性的值来表征，结构描述简单；数据检索操作不依赖路径信息或过程信息，支持非过程化的数据操作；有效支持记录集合的操作；较为完善的理论基础

   面向对象模型：

   - 面向对象技术和集合/聚集操作技术的结合
   - 支持复杂数据类型，数据封装与抽象数据结构
   - 支持面向对象的一些特性：类、继承、封装、多态...

   对象关系模型：

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231182304665.png" alt="image-20231231182304665" style="zoom:35%;" />

7. 数据库系统结构

   数据库系统模式的概念：“型” 和“值” 的概念

   - 型（Type）：对某一类数据的结构和属性的说明。

     记录型:（学号，姓名)

   - 值（Value）：是型的一个具体赋值。
     该记录型的一个记录值:(900201，李明)

   从数据库管理系统角度看，数据库系统通常采用**三级模式结构**，是数据库系统内部的系统结构 。

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231182954231.png" alt="image-20231231182954231" style="zoom:23%;" />

   - 模式：也称逻辑模式
     数据库中全体数据的逻辑结构和特征的描述；所有用户的公共数据视图，综合了所有用户的需求

     - 一个数据库只有一个模式
     - 是数据库系统模式结构的中间层
     - 与数据的物理存储细节和硬件环境无关；与具体的应用程序、开发工具及高级程序设计语言无关
     - 定义的内容：数据的逻辑结构（数据记录由哪些数据项构成，数据项的名字、类型、取值范围等）；数据之间的联系；数据有关的安全性、完整性要求

   - 外模式：也称子模式或用户模式

     - 一个数据库可以有多个外模式
     - 数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述。
     - 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。
     - 外模式的地位：介于模式与应用之间
     - 模式与外模式的关系：一对多
       外模式通常是模式的子集；对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同。

     - 外模式与应用的关系：一对多
       同一外模式也可为某一用户的多个应用系统所使用；但一个应用程序只能使用一个外模式。

   - 内模式：也称存储模式

     - 一个数据库只有一个内模式
     - 是数据物理结构和存储方式的描述
     - 是数据在数据库内部的表示方式
       - 记录的存储方式、索引的组织方式
       - 数据是否压缩存储、是否加密、记录结构规定

   数据库的二级映像功能：

   - 外模式／模式映像：定义外模式与模式之间的对应关系

     - 每一个外模式都对应一个外模式／模式映像
     - 映像定义通常包含在各自外模式的描述中

     <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231184201195.png" alt="image-20231231184201195" style="zoom:33%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231184220116.png" alt="image-20231231184220116" style="zoom:33%;" />

   - 模式／内模式映像：定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的。

     - 数据库中模式／内模式映像是唯一的。
     - 该映像定义通常包含在模式描述中。

     <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231184336415.png" alt="image-20231231184336415" style="zoom:33%;" />

## 第2章 关系数据库

一个关系(relation)就是一个Table。在一个给定的应用领域中，所有实体及实体之间联系的关系的集合构成一个关系数据库。

关系数据库也有型和值之分。

- 关系数据库的型：称为关系数据库模式，是对关系数据库的描述。

  若干域的定义；在这些域上定义的若干关系模式

- 关系数据库的值：是这些关系模式在某一时刻对应的关系的集合，通常简称为关系数据库。

1. 关系模型的三要素：

   - 关系数据结构：
   - 基本操作：
     基本的： ∪（并）, —（差）， ×(广义积), σ(选择),π(投影)
     扩展的：∩(交), <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231185224097.png" alt="image-20231231185224097" style="zoom:33%;" />(连接)，÷（除）
   - 完整性约束：实体完整性、参照完整性和用户自定义完整性

2. 关系模型与关系数据语言的关系：
   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231185404713.png" alt="image-20231231185404713" style="zoom:33%;" />

   关系运算：关系代数和关系演算

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231185559808.png" alt="image-20231231185559808" style="zoom:23%;" />

   关系演算：元组演算和域演算

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231185611433.png" alt="image-20231231185611433" style="zoom:23%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231185633809.png" alt="image-20231231185633809" style="zoom:25%;" />

   域-列的取值集合

   - 定义：域是一组具有相同数据类型的值的集合

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231185947822.png" alt="image-20231231185947822" style="zoom:25%;" />

   笛卡尔积：

   - 定义：给定一组域D1，D2，…，Dn，这些域中可以有相同的。D1，D2，…，Dn的笛卡尔积为：

     D1×D2×…×Dn＝｛(d1，d2，…，dn)｜di∈Di，i＝1，2，…，n｝

   - 所有域的所有取值的组合，组合不能重复

   - 元组:笛卡尔积中每一个元素（d1，d2，…，dn）叫作一个n元组或简称元组。

   - 分量:笛卡尔积元素（d1，d2，…，dn）中的每一个值di叫作一个分量。

   - 基数:若Di（i＝1，2，…，n）为有限集，其基数为mi（i＝1，2，…，n），则D1×D2×…×Dn的基数M为：<img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231191142921.png" alt="image-20231231191142921" style="zoom:33%;" />

   关系

   - 定义：D1×D2×…×Dn的子集叫作在域D1，D2，…，Dn上的关系，表示为： R（D1，D2，…，Dn）

     R表示关系名，n表示关系的目或度（Degree）

   - 当n=1时，称该关系为单元关系。当n=2时，称该关系为二元关系。

   - 关系是笛卡尔积的有限子集。无限关系在数据库系统中是无意义的。

   候选码

   - 若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码。
   - 在最简单的情况下，候选码只包含一个属性。
   - 在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）

   主码

   - 若一个关系有多个候选码，则选定其中一个为主码（Primary key）。
   - 侯选码的诸属性称为主属性
   - 不包含在任何侯选码中的属性称为非码属性

3. 关系的性质

   - 列是同质的
     每一列中的分量是同一类型的数据，来自同一个域。
   - 不同的列可出自同一个域
     其中的每一列称为一个属性。不同的属性要给予不同的属性名
   - 列的顺序无所谓
   - 任意两个元组的候选码不能完全相同
   - 行的顺序无所谓，行的次序可以任意交换
   - 分量必须取原子值
     每一个分量都必须是不可分的数据项。这是规范条件中最基本的一条。

4. 关系模式

   定义：关系的描述称为关系模式

   - 关系模式可以形式化地表示为：R（U，D，dom，F）

     R：关系名；U ：组成该关系的属性名集合；D：属性组U中属性所来自的域；dom：属性向域的映象集合；F：属性间的数据依赖关系集合

   - 关系模式通常可以简记为：R (U)或R (A1，A2，…，An)
     R是关系名；A1，A2，…，An是属性名

   关系模式和关系：

   - 关系模式

     对关系的描述；静态的、稳定的

   - 关系

     关系模式在某一时刻的状态或内容；动态的、随时间不断变化的

   - 关系模式和关系往往统称为关系，通过上下文加以区别。

5. 关系操作

   基本的关系操作

   - 查询
     基本操作：选择、投影、并、差、笛卡尔积
     扩展操作：连接、除、交
   - 数据更新
     插入、删除、修改。
     其中选择、投影、并、差、笛卡尔积是五种基本操作。其他操作可以用基本操作来定义和导出

   关系数据语言的分类

   - 关系代数语言  

     用对关系的运算来表达查询要求。典型代表：ISBL

   - 关系演算语言：用谓词来表达查询要求

     - 元组关系演算语言

       谓词变元的基本对象是元组变量。典型代表：APLHA, QUEL

     - 域关系演算语言    

       谓词变元的基本对象是域变量。典型代表：QBE

   - 具有关系代数和关系演算双重特点的语言。典型代表：SQL

6. 关系的完整性

   实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。

   关系模型中三类完整性约束：
   实体完整性、参照完整性、用户定义的完整性

   **实体完整性**：若属性A是基本关系R的主属性，则属性A不能取空值。

   参照完整性：

   - 在关系模型中实体及实体间的联系都是用关系来描述的，因此可能存在着关系与关系间的引用。

   - 外码：设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码。

     基本关系R称为参照关系；基本关系S称为被参照关系或目标关系

     关系R和S不一定是不同的关系。
     目标关系S的主码Ks 和参照关系的外码F必须定义在同一个域上。
     外码并不一定要与相应的主码同名，当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别。

   - 参照完整性规则：若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：
     或者取空值（F的每个属性值均为空值）；或者等于S中某个元组的主码值。

   **用户定义的完整性**：是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。

7. 关系代数

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231193316053.png" alt="image-20231231193316053" style="zoom:23%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231193410299.png" alt="image-20231231193410299" style="zoom:25%;" />

   表示记号

   - R，t∈R，t[Ai]	设关系模式为R(A1，A2，…，An)
     它的一个关系设为R。t∈R表示t是R的一个元组，**t[Ai]**则表示元组t中相应于属性Ai的一个分量 。

     R(A，B，C)	元组或关系的元素t = (a1,b1,c1),(a1,b2,c2),(a2,b2,c1)	如t = (a1,b1,c1),则 t[A] = a1，t[B] = b1, t[C] = c1 

   - A，t[A]，  A ba
     若A={Ai1，Ai2，…，Aik}，其中Ai1，Ai2，…，Aik是A1，A2，…，An中的一部分，则A称为属性列或域列。
     **t[A]**=(t[Ai1]，t[Ai2]，…，t[Aik])表示元组t在属性列A上诸分量的集合。
     **A**则表示{A1，A2，…，An}中去掉{Ai1，Ai2，…，Aik}后剩余的属性组。

   - *t*r⌒ *t*s

     *R*为*n*目关系，*S*为*m*目关系。*t*r ∈*R*，*t*s∈*S*， *t*r⌒ *t*s称为元组的连接。它是一个*n* + *m*列的元组，前*n*个分量为*R*中的一个*n*元组，后*m*个分量为*S*中的一个*m*元组。 

   - 象集Zx
     给定一个关系R（X，Z），X和Z为属性组。当t[X]=x时，x在R中的象集（Images Set）为： Zx={t[Z]|t∈R，t[X]=x}
     它表示R中属性组X上值为x的诸元组在Z上分量的集合。 

   

8. 传统的集合运算

   并、交、差、广义笛卡尔积

9. 专门的关系运算

   选择：是从行的角度进行的运算

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231194323366.png" alt="image-20231231194323366" style="zoom:33%;" />

   投影：是从列的角度进行的运算（但投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行））

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231194540319.png" alt="image-20231231194540319" style="zoom:33%;" />

   连接：一般的连接操作是从行的角度进行运算。自然连接还需要取消重复列，所以是同时从行和列的角度进行运算。 

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231194556896.png" alt="image-20231231194556896" style="zoom: 25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231194610996.png" alt="image-20231231194610996" style="zoom: 25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231194621366.png" alt="image-20231231194621366" style="zoom: 25%;" />

   若把舍弃的元组也保存在结果关系中，而在其他属性上填空值，则称为外连接。若只把左边关系R中要舍弃的元组保留就叫左外连接；若只把右边关系S中要舍弃的元组保留就叫右外连接。

   除：是同时从行和列角度进行运算

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231194949352.png" alt="image-20231231194949352" style="zoom:33%;" />

   例题：P99

## 第6章 关系数据理论

数据库逻辑设计的工具──关系数据库的规范化理论

1. 问题的提出

   数据依赖的类型：函数依赖（FD）；多值依赖（MVD）

2. 规范化

   函数依赖

   - 平凡函数依赖与非平凡函数依赖

     <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231230206969.png" alt="image-20231231230206969" style="zoom:25%;" />

   - 完全函数依赖与部分函数依赖

   - 传递函数依赖

   多值依赖

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231231019944.png" alt="image-20231231231019944" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231231037283.png" alt="image-20231231231037283" style="zoom:25%;" />

   **范式**：把关系数据库规范化过程中为不同程度的规范化要求设立的不
   同标准称为范式。它是符合某一种级别的关系模式的集合。每种范式都规定了一些限制约束条件。

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231230333405.png" alt="image-20231231230333405" style="zoom:33%;" />

   **1NF**

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231230355954.png" alt="image-20231231230355954" style="zoom:33%;" />

   - 第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。
   - 但是满足第一范式的关系模式并不一定是一个好的关系模
     式。

   **2NF**

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231230502363.png" alt="image-20231231230502363" style="zoom: 25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231230603751.png" alt="image-20231231230603751" style="zoom:25%;" />

   - 采用投影分解法将一个1NF的关系分解为多个2NF的关系，可以在一定程度上减轻原1NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。
   - 从1NF关系中消除非主属性对码的部分函数依赖，则可得到2NF关系。
   - 如果R的码为单属性，或R的全体属性均为主属性，则
     R∈2NF。
   - 将一个1NF关系分解为多个2NF的关系，并不能完全消除关
     系模式中的各种异常情况和数据冗余

   **3NF**

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231230642669.png" alt="image-20231231230642669" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231230702528.png" alt="image-20231231230702528" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231230716660.png" alt="image-20231231230716660" style="zoom:25%;" />

   - 若R∈3NF，则R的每一个非主属性既不部分函数依赖于候选码也不传递函数依赖于候选码。
   - 如果R∈3NF，则R也是2NF。

   **BCNF**

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231230753087.png" alt="image-20231231230753087" style="zoom:33%;" />

   - 若R∈BCNF
      每一个决定属性集（因素）都包含（候选）码
      R中的所有属性（主，非主属性）都完全函数依赖于码
      R∈3NF（证明）
      若R∈3NF，则 R不一定∈BCNF

   **4NF**

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231231052515.png" alt="image-20231231231052515" style="zoom:25%;" />

   - 如果只考虑函数依赖，则属于BCNF的关系模式规范化程度已经是最高的了。
   - 如果考虑多值依赖，则属于4NF的关系模式规范化程度是最高的。
   - 数据依赖中除了最重要的函数依赖和多值依赖外，还有其他数据依赖，如连接依赖。
   - 函数依赖是多值依赖的一种特殊情况，而多值依赖实际上又是连接依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可由语义直接导出，而是在关系的连接运算时才反映出来。

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231231207019.png" alt="image-20231231231207019" style="zoom:33%;" />

3. 数据依赖的公理

   

4. 模式分解

   - 把低一级的关系模式分解为若干个高一级的关系模式的方法并不是唯一的
   - 只有能够保证分解后的关系模式与原关系模式等价，分解方法才有意义
   - 三种模式分解的等价定义
     分解具有无损连接性；分解要保持函数依赖；分解既要保持函数依赖，又要具有无损连接性

## 第7章 数据库设计

1. 数据库设计概述

   目标：为用户和各种应用系统提供一个信息基础设施和高效率的运行环境。

   特点：三分技术，七分管理，十二分基础数据。结构（数据）设计和行为（处理）设计相结合

   方法：手工试凑法、规范设计法

   步骤： 需求分析，概念结构设计，逻辑结构设计，物理结构设计，数据库实施，数据库运行和维护

2. 需求分析

   任务

   方法

   数据字典

3. 概念结构设计

   概念模型

   ER模型：描述概念模型的工具。

   - 子系统E-R图之间的冲突主要有三类：
     属性冲突； 命名冲突；结构冲突

   UML

4. 逻辑结构设计

5. 物理结构设计

6. 数据库的实施和维护

## 第9章 关系查询处理和查询优化

1. 关系数据库系统的查询处理

   查询处理步骤

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231221452202.png" alt="image-20231231221452202" style="zoom:25%;" />

   1. 查询分析：对查询语句进行扫描、词法分析和语法分析，判断它是否符合SQL语法规则。
   2. 查询检查：根据数据字典对合法的查询语句进行语义检查，即查询语句中的数据库对象，如属性名、关系名，是否存在和是否有效。还要根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查。通过后便把SQL查询语句转换成等价的关系代数表达式，用查询树（语法分析树）来表示。
   3. 查询优化：从多个可供选择的执行策略和操作算法中选择一个高效执行的查询处理策略。按优化的层次一般可分为代数优化和物理优化。

     - 代数优化：指关系代数表达式的优化，即按照一定的规则，改变代数表达式中操作的次序和组合，使查询执行更高效。
     - 物理优化：指存取路径和底层操作算法的选择。

   4. 查询执行：依据优化器得到的执行策略生成查询计划，由代码生成器生成执行这个查询计划的代码

   实现查询操作的算法示例

   选择操作的实现：<img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231221615923.png" alt="image-20231231221615923" style="zoom:33%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231221704943.png" alt="image-20231231221704943" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231221715500.png" alt="image-20231231221715500" style="zoom:25%;" />

   - 简单的全表扫描方法
     对基本表进行顺序扫描，逐一检查每个元组是否满足选择条件。对于小表简单有效，对于大表则效率低下。
   - 索引扫描方法
     通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组。

   连接操作的实现：<img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231221742512.png" alt="image-20231231221742512" style="zoom:25%;" />

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231221938068.png" alt="image-20231231221938068" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231221923355.png" alt="image-20231231221923355" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231221908835.png" alt="image-20231231221908835" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231221852563.png" alt="image-20231231221852563" style="zoom:25%;" />

2. 关系数据库系统的查询优化

   - 概述：

     查询优化在关系数据库系统中有着非常重要的地位
     关系查询优化是影响RDBMS性能的关键因素

   - 由DBMS进行查询优化的好处
     用户不必考虑如何最好地表达查询以获得较好的效率
     系统可以比用户程序的优化做得更好
     (1) 优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息

     (2)如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。
     (3)优化器可以考虑数百种不同的执行计划，而程序员一般只能考虑有限的几种可能性。
     (4)优化器中包括了很多复杂的优化技术。

   - RDBMS通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案

   - 集中式数据库
     执行开销主要包括：磁盘存取块数(I/O代价)；处理机时间(CPU代价)；查询的内存开销
      I/O代价是最主要的

   - 分布式数据库

     总代价=I/O代价+CPU代价+内存代价＋通信代价

   - 查询优化的总目标
     选择有效策略，求得给定关系表达式的值，使得查询代价最小（实际上是较小）

3. 代数优化

   - 代数优化策略：通过对关系代数表达式的等价变换来提高查询效率
   - 关系代数表达式的等价：指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的
   - 两个关系表达式E1和E2是等价的，可记为E1≡E2

   关系代数等价变换规则：

   - 连接、笛卡尔积的交换律、结合律
   - 合并或分解投影运算
   - 合并或分解选择运算
   - 选择运算与其他运算交换
   - 投影运算与其他运算交换

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231222957294.png" alt="image-20231231222957294" style="zoom:25%;" />

   - 

4. 物理优化

   代数优化改变查询语句中操作的次序和组合，不涉及底层的存取路径。
   物理优化的目标就是选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标

   - 基于规则的启发式优化
   - 基于代价估算的优化
   - 两者结合的优化方法：常常先用启发式规则，选取若干较优的候选取方案，减少代价估算的工作量；然后分别计算这些候选方案的执行代价，较快地选出最终的优化方案。

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231222641248.png" alt="image-20231231222641248" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231222651830.png" alt="image-20231231222651830" style="zoom:25%;" />

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231222707693.png" alt="image-20231231222707693" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231222718639.png" alt="image-20231231222718639" style="zoom: 25%;" />

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231222806123.png" alt="image-20231231222806123" style="zoom:33%;" />

## 第10章 数据库恢复

1. 事务的基本概念

   什么是事务

   - 事务：用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。

   - 事务和程序是两个概念

     在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序

     一个应用程序通常包含多个事务

   - 事务是恢复和并发控制的基本单位

   如何定义事务

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231223227033.png" alt="image-20231231223227033" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231223239142.png" alt="image-20231231223239142" style="zoom:25%;" />

   事务的ACID特性：

   - 原子性：事务是数据库的逻辑工作单位
     事务中包括的诸操作要么都做，要么都不做
     保证原子性是数据库系统本身的职责，由DBMS的事务管理子系统来实现。

   - 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态
     一致性状态：数据库中只包含成功事务提交的结果
     不一致状态：数据库中包含失败事务的结果

     <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231223432361.png" alt="image-20231231223432361" style="zoom: 25%;" />

   - 隔离性：对并发执行而言
     一个事务的执行不能被其他事务干扰
     一个事务内部的操作及使用的数据对其他并发事务是隔离的
     并发执行的各个事务之间不能互相干扰

   - 持续性：也称永久性
     一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。
     接下来的其他操作或故障不应该对其执行结果有任何影响。
     事务的持久性由DBMS的恢复管理子系统实现。

   事务的特性：

   - 保证事务ACID特性是事务处理的任务
   - 破坏事务ACID特性的因素
     多个事务并行运行时，不同事务的操作交叉执行（DBMS必须保证多个事务的交叉运行不影响这些事务的原子性）
     事务在运行过程中被强行停止（DBMS必须保证被强行终止的事务对数据库和其他事务没有任何影响）

2. 数据库恢复概述

   - 故障是不可避免的
     计算机硬件故障；系统软件和应用软件的错误；操作员的失误；恶意的破坏
   - 故障的影响
     运行事务非正常中断； 破坏数据库
   - 数据库管理系统对故障的对策
     DBMS提供恢复子系统；保证故障发生后，能把数据库中的数据从错误状态恢复到某一已知的正确状态；保证事务ACID
   - 恢复技术是衡量系统优劣的重要指标

3. 故障的种类

   事务故障

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231223737213.png" alt="image-20231231223737213" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231223748971.png" alt="image-20231231223748971" style="zoom:25%;" />

   系统故障

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231223801364.png" alt="image-20231231223801364" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231223812303.png" alt="image-20231231223812303" style="zoom:25%;" />

   介质故障

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231223824271.png" alt="image-20231231223824271" style="zoom:25%;" />

   计算机病毒

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231223841875.png" alt="image-20231231223841875" style="zoom:25%;" />

4. 恢复的实现技术

   恢复操作的基本原理：冗余
   		利用存储在系统其它地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据。
   恢复的实现技术：复杂
   		一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上。

   数据转储

   - 定义：转储是指DBA将整个数据库复制到磁带或另一个磁盘上保
     存起来的过程。这些备用的数据文本称为后备副本或后援副本。
   - 转储方法：静态转储与动态转储；海量转储与增量转储

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231224250932.png" alt="image-20231231224250932" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231224301698.png" alt="image-20231231224301698" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231224315329.png" alt="image-20231231224315329" style="zoom:33%;" />

   登记日志文件：

   - 日志文件的内容：日志文件是用来记录事务对数据库的更新操作的文件
   - 日志文件的格式
     以记录为单位的日志文件；以数据块为单位的日志文件
   - 日志文件内容
     各个事务的开始标记；各个事务的结束标记；各个事务的所有更新操作；与事务有关的内部更新操作
   - 日志文件的用途
     进行事务故障恢复；进行系统故障恢复；协助后备副本进行介质故障恢复
   - 为保证数据库是可恢复的，登记日志文件时必须遵循两条原则
     登记的次序严格按并行事务执行的时间次序
     必须先写日志文件，后写数据库

5. 恢复策略

   - 事务故障的恢复
   - 系统故障的恢复
   - 介质故障的恢复

6. 具有检查点的恢复技术

   

7. 数据库镜像

## 第11章 并发控制

1. 多事务执行方式：

   事务串行执行

   - 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行
   - 不能充分利用系统资源发挥数据库共享资源的特点

   交叉并发方式（interleaved concurrency）

   - 事务的并行执行是这些并行事务的并行操作轮流交叉运行
   - 是单处理机系统中的并发方式，能够减少处理机的空闲时间，提高系统的效率

   同时并发方式（simultaneous concurrency）

   - 多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行
   - 最理想的并发方式，但受制于硬件环境
   - 更复杂的并发方式机制

   事务并发执行带来的问题：可能会存取和存储不正确的数据，破坏事务的隔离性和数据库的一致性

2. 并发控制概述

   并发控制机制的任务：

   - 对并发操作进行正确调度；保证事务的隔离性；保证数据库的一致性

   并发操作带来的数据不一致性：

   - 丢失修改：指事务1与事务2从数据库中读入同一数据并修改，事务2的提交结果破坏了事务1提交的结果，导致事务1的修改被丢失。

   - 不可重复读：是指事务1读取数据后，事务2执行更新操作，使事务1无法再现前一次读取结果。（3类不可重复读）

     <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231200348044.png" alt="image-20231231200348044" style="zoom:33%;" />

   - 读“脏”数据：事务1修改某一数据，并将其写回磁盘；事务2读取同一数据后，事务1由于某种原因被撤消，这时事务1已修改过的数据恢复原值，事务2读到的数据就与数据库中的数据不一致，是不正确的数据，又称为“脏”数据。

3. 封锁

   - 定义：封锁就是事务T在对某个数据对象（例如表、记录等）操
     作之前，先向系统发出请求，对其加锁
     加锁后事务T就对该数据对象有了一定的控制，在事务T释
     放它的锁之前，其它的事务不能更新此数据对象。
     封锁是实现并发控制的一个非常重要的技术
   - 类型：一个事务对某个数据对象加锁后究竟拥有什么样的控制是由封锁的类型决定的。
     - 排它锁（写锁/X锁）
       若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁
     - 共享锁（读锁/S锁）
       若事务T对数据对象A加上S锁，则事务T可读A但不可修改A，其它事务只能再对A加S锁而不能加X锁，直到T释放A上的S锁

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231200719629.png" alt="image-20231231200719629" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231200733951.png" alt="image-20231231200733951" style="zoom: 25%;" />

4. 活锁和死锁

   封锁技术可以有效地解决并行操作的一致性问题，但也带来一些新的问题

   活锁：

   - 活锁指某个事务永远处于等待状态，得不到执行的现象
   - 如何避免：采用先来先服务的策略
     当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队
     该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。

   死锁：

   - 死锁指有两个或两个以上的事务处于等待状态，每个事务都在等待其中一个事务解除封锁，它才能继续执行下去，结果任何一个事务都无法执行。

   - 解决死锁的两类方法

     预防死锁；死锁的诊断与解除

   死锁的预防：

   - 产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。
   - 预防死锁的发生就是要破坏产生死锁的条件

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231215036049.png" alt="image-20231231215036049" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231215105674.png" alt="image-20231231215105674" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231215153280.png" alt="image-20231231215153280" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231215206637.png" alt="image-20231231215206637" style="zoom:25%;" />

   死锁的诊断与解除：

   - 允许死锁发生
   - 解除死锁
     由DBMS的并发控制子系统定期检测系统中是否存在死锁。一旦检测到死锁，就要设法解除。选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有的锁，使其它事务能继续运行下去。

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231215308070.png" alt="image-20231231215308070" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231215321660.png" alt="image-20231231215321660" style="zoom:25%;" />

5. 并发调度的可串行性

   - 计算机系统对并行事务中并行操作的调度是随机的，而不同的调度可能会产生不同的结果。
   - 将所有事务串行起来的调度策略一定是正确的调度策略。
     如果一个事务运行过程中没有其他事务在同时运行，也就是说它没有受到其他事务的干扰，那么就可以认为该事务的运行结果是正常的或者预想的

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231215503852.png" alt="image-20231231215503852" style="zoom:25%;" />

   - 以不同的顺序串行执行事务也有可能会产生不同的结果，但由于不会将数据库置于不一致状态，所以都可以认为是正确的。
   - 几个事务的并行执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同 。这种并行调度策略称为可串行化的调度
   - 可串行性是并行事务正确性的唯一准则

6. 两段锁协议

   - 目前DBMS常采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性。

   - 封锁协议
     何时申请加锁       持锁时间、何时释放锁

   - 两段锁协议是最常用的一种封锁协议，理论上已证明使用它产生的是可串行化调度。

   - 两段锁协议的内容

     - 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁
     - 在释放一个封锁之后，事务不再申请和获得任何其他封锁。

   - “两段”锁的含义

     事务分为两个阶段

     -  第一阶段是获得封锁，也称为扩展阶段；
     -  第二阶段是释放封锁，也称为收缩阶段。

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231215819993.png" alt="image-20231231215819993" style="zoom:25%;" /><img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231215831843.png" alt="image-20231231215831843" style="zoom:25%;" />

7. 封锁的粒度

   - 封锁对象的大小称为封锁的粒度(Granularity)
   - 封锁的对象：逻辑单元、物理单元
     例：在关系数据库中，封锁对象：
     逻辑单元: 属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库等
     物理单元：页（数据页或索引页）、物理记录等
   - 封锁对象可以很大也可以很小
     例： 对整个数据库加锁，对某个属性值加锁
   - 封锁粒度与系统的并发度和并发控制的开销成反比

8. 多粒度封锁：在一个系统中同时支持多种封锁粒度供不同的事务选择

   - 选择封锁粒度的原则

     - 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位；
     - 需要处理大量元组的用户事务：以关系为封锁单元；
     - 只处理少量元组的用户事务：以元组为封锁单位

   - 多粒度树

     - 以树形结构来表示多级封锁粒度
     - 根结点是整个数据库，表示最大的数据粒度
     - 叶结点表示最小的数据粒度

     <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231220159876.png" alt="image-20231231220159876" style="zoom:33%;" />

   - 多粒度封锁协议

     - 允许多粒度树中的每个结点被独立地加锁
     - 对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁
     - 在多粒度封锁中一个数据对象可能以两种方式封锁：显式封锁和隐式封锁

   <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231220313044.png" alt="image-20231231220313044" style="zoom:25%;" />

9. 意向锁

   - 引进意向锁（intention lock）目的

     提高对某个数据对象加锁时系统的检查效率

   - 意向锁的含义：如果对任一结点加基本锁，必须先对它的上层结点加意向锁；如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。

     <img src="C:\Users\32354\Desktop\大3\数据库\images\image-20231231220433406.png" alt="image-20231231220433406" style="zoom:33%;" />

   常用意向锁

   - 意向共享锁(简称IS锁)
     如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。
     例：要对某个元组加S锁，则要首先对关系和数据库加IS锁

   - 意向排它锁(Intent Exclusive Lock，简称IX锁)
     如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。
     例：要对某个元组加X锁，则要首先对关系和数据库加IX锁。

   - 共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)

     如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX =S + IX。例：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）。

   锁的强度

   - 锁的强度是指它对其他锁的排斥程度
   - 一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然

   具有意向锁的多粒度封锁方法

   - 申请封锁时应该按自上而下的次序进行；

   - 释放封锁时则应该按自下而上的次序进行

     例：事务T要对一个数据对象加锁，必须先对它的上层结点加意向锁

数据库的并发控制以事务为单位
并发操作所带来的数据库不一致性问题
 丢失修改
 不可重复读
 读脏数据
数据库的并发控制通常使用封锁机制
 两类最常用的封锁（X锁与S锁）

并发控制机制调度并发事务操作是否正确的判别准则是可串行性
 并发操作的正确性则通常由两段锁协议来保证。
 两段锁协议是可串行化调度的充分条件，但不是必要条件

对数据对象施加封锁，带来问题
 活锁： 先来先服务
 死锁：
 预防方法:一次封锁法;顺序封锁法
 死锁的诊断与解除:超时法;等待图法
不同的数据库管理系统提供的封锁类型、封锁协议、达到的系统一致性级别不尽相同。但是其依据的基本原理和技术是共同的。

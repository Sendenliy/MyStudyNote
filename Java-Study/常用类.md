# 常用类

## Object类

所有类的根类（父类），所有类都会直接或间接的继承Object类

### toString()方法

1. 概述返回该对象的字符串表示形式

   ```java
   //源码
   public String toString() {
       return getClass().getName() + "@" + Integer.toHexString(hashCode());
   }
   //获取包名 + 获取类名 + @ + 转十六进制【（返回十进制数）】
   ```

2. 注意：

   - 如果没有重写Object中的toString方法，直接输出对象名会默认调用Object中的toString方法，直接输出地址。

     ```java
     public static void main(String[] args) {
         Person p1 = new Person("夏明", 23);
         //输出地址值
         System.out.println(p1); //self.normalClass.Person@4554617c
         System.out.println(p1.toString());  //self.normalClass.Person@4554617c
        System.out.println("================================================");
         ArrayList<String> list = new ArrayList<>();
         list.add("小1");
         list.add("小2");
         list.add("小3");
         list.add("小4");
         System.out.println(list);   //[小1, 小2, 小3, 小4]
         System.out.println(list.toString());   //[小1, 小2, 小3, 小4]
         //此时的toString被重写过了，不是Object里的toString
     }
     ```

   - 如果重写了Object中的toString方法，再输出地址值，重写没有意义，所以重写完toString之后，应该返回对象的内容。

     ```java
     public String toString() {
         return "Person{" +"name='" + name + '\'' + ", age=" + age + '}';
     }
     ```

   > 总结：如果直接输出对象名不想输出地址值，就重写Object中的toString方法。

### equals()方法

1. 概述:比较两个对象的地址值是否相等

   ```java
   //源码
   public boolean equals(Object obj) {
       return (this == obj);
   }
   == 针对于基本数据类型来说，比较的是值。针对于引用数据类型来说，比较的是地址值
   ```

2. 注意：

   - 如果没有重写Object中的equals方法，那么就会调用Object中的equals方法，比较对象的地址值

   ```java
   public static void main(String[] args) {
       Person p1 = new Person("小红", 21);
       Person p2 = new Person("小红", 21);
       System.out.println(p1 == p2);  //false
       System.out.println(p1.equals(p2));  //false	& false
   
       System.out.println("=================================");
       String s1 = new String("abc");
       String s2 = new String("abc");
       System.out.println(s1 == s2);   //false
       System.out.println(s1.equals(s2));  //true
   }
   ```

   - 如果重写了Object中的equals方法，那么就会调用重写后的equals方法，应该比较对象的内容

     ```java
      public boolean equals(Object obj) {
         //问题4.如果传递自己，就不用判断类型和非空，直接返回true
         if (this == obj) {
             return true;
         }
         //问题3.如果传递null，就不用判断类型，直接返回false
         if (obj == null) {
             return false;
         }
         /*
         问题2.如果传递的不是Person类型，就会出现类型转换异常
         解决问题2：先判断类型，如果是Person类型，再强转成Person
         */
         if (obj instanceof Person) {
     	/*  
     	问题1.obj直接调用name和age调用不了，因为obj接收了Person类型的对象
                 属于多态，多态前提下不能直接调用子类特有内容
         解决问题1：向下转型
     	*/
             Person p = (Person) obj;
             return this.name.equals(p.name) && this.age == p.age;
         }
         return false;
     }
     
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Person person = (Person) o;
         return age == person.age && Objects.equals(name, person.name);
     }
     ```

   > 总结：
   >
   > - 如果想比较两个对象的内容，就重写一下equals方法
   > - alt + insert 自动重写equals

### clone()方法

1. 概述：复制一个属性值一样的新对象

   ```java
   //源码
   protected native Object clone() throws CloneNotSupportedException;
   //在Object中Clone()是被声明为protected的
   //这样做是有一定的道理的，以Employee类为例，通过声明为protected，就可以保证只有Employee类里面才能“克隆”Employee对象.
   ```

2. 使用：

   - 需要被克隆的对象Person实现Cloneable接口（即implements Cloneable）
   - 重写clone方法
   - 调用Clone()方法的对象所属的类(Class)必须implements Clonable接口，否则在调用Clone方法的时候会抛出CloneNotSupportedException

   ```java
   public static void main(String[] args) throws CloneNotSupportedException {
       Person p2 = new Person("小米", 16);
       Object o = p2.clone();
       Person p3 = (Person) o; //克隆了一个新对象
   
       System.out.println(p2 == p3); //比较地址值 false
       System.out.println(p2.equals(p3)); //比较属性值 true
   }
   ```

3. 创建对象的两种方法：new操作符创建一个对象和copy方法复制一个对象

4. new操作符本意：分配内存。

   执行时：查看new操作符后面的类型-> 分配内存空间 ->调用构造函数，填充对象的各个域（对象的初始化）

   构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。

5. clone方法：第一步也是分配内存

   调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同 -> 然后再使用原对象中对应的各个域，填充新对象的域 -> 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。

6. new和clone的区别

   - 假设现在有一个Employee对象，Employee tobby =new Employee(“CMTobby”,5000)
   - 通常我们会有这样的赋值Employee cindyelf=tobby，这个时候只是简单了copy了一下reference，cindyelf和tobby都指向内存中同一个object，这样cindyelf或者tobby的一个操作都可能影响到对方。
   - 打个比方，如果我们通过cindyelf.raiseSalary()方法改变了salary域的值，那么tobby通过getSalary()方法得到的就是修改之后的salary域的值，显然这不是我们愿意看到的。
   - 我们希望得到tobby的一个精确拷贝，同时两者互不影响，这时候， 我们就可以使用Clone来满足我们的需求。Employee cindy=tobby.clone()，这时会生成一个新的Employee对象，并且和tobby具有相同的属性值和方法。

7. shallow Clone与Deep Clone

   - Object在对某个对象实施Clone时对其是一无所知的，它仅仅是简单地执行域对域的copy，这就是Shallow Clone。
   - 以Employee为例，它里面有一个域是一个reference变量，经过Clone之后就会产生一个新的Date型的reference，它和原始对象中对应的域指向同一个Date对象，这样克隆类就和原始类共享了一部分信息，而这样显然是不利的
   - 这就需要对那些非基本类型的域进行特殊的处理，即DeepClone

### 	getClass()方法

1. 概述：返回引用中存储的实际对象的类型。

   用于判断两个引用中实际存储对象类型是否一致

   ```java
   //返回Class类型
   //源码
   public final native Class<?> getClass();
   ```

2. 不可重写.

   要调用的话，一般和getName()联合使用，如getClass().getName();

   ```java
   public static void main(String[] args) {
       Student s1 = new Student("李敏", 16);
       Student s2 = new Student("张辉", 18);
   
       //判断s1和s2是不是一个类型
       Class class1 = s1.getClass();
       System.out.println(class1.toString());  //class self.normalClass.Student
       Class class2 = s2.getClass();
       if (class1 == class2) System.out.println("属于同一个类型");
       else System.out.println("不是同一个类型");
   }
   ```

### hashCode()方法

1. 概述：返回该对象的哈希码值。

   

   ```java
   //源码
   public native int hashCode();
   ```

2. 哈希值：根据对象的地址或字符串或数字使用hash算法计算出来的int类型的数值.

   （相同对象返回相同哈希码）

   ```java
   System.out.println(s1.hashCode());  //1163157884
   System.out.println(s2.hashCode());  //1956725890
   Student s3 = s1;
   System.out.println(s3.hashCode());  //1163157884
   ```

3. 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。

4. 一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash Code() == obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价

### finalize()方法

1. 概述：当对象被判定为垃圾对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列。（该方法用于回收资源）

   ```java
   //源码
   protected void finalize() throws Throwable { }
   //它的工作原理是：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。
   ```

2. 垃圾对象：没有有效引用指向此对象时，为垃圾对象。

   垃圾回收：由GC销毁垃圾对象，释放数据存储空间。

   自动回收机制：JVM内存耗尽，一次性回收所有垃圾对象。
   手动回收机制：使用System.gc()；通知JVM执行垃圾回收

   ```java
   //重写finalize方法
   protected void finalize() throws Throwable {
       System.out.println(this.name + "对象被回收了");
   }
   
   public static void main(String[] args) {
        Student s1 = new Student("抓捕", 56);
        Student s2 = new Student("dfbd", 56);
        new Student("111", 56);
        new Student("222", 56);
        new Student("333", 56);
        //回收垃圾
        System.gc();
        System.out.println("回收垃圾");
    }
   //输出
        //回收垃圾
        //333对象被回收了
        //222对象被回收了
        //111对象被回收了
   ```

3. 关于垃圾回收

   - 对象可能不被垃圾回收。只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。
   - 垃圾回收并不等于“析构”。
     【析构函数与构造函数相反，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）。】
   - 垃圾回收只与内存有关。使用垃圾回收的唯一原因是为了回收程序不再使用的内存。

### wait()方法

1. 概述：wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。
   wait()方法一直等待，直到获得锁或者被中断。

   wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。

   ```java
   //源码
   public final native void wait(long timeout) throws InterruptedException;
   //参数：要等待的最长时间ms；额外时间mμs
   public final void wait(long timeout, int nanos) throws InterruptedException {
       if (timeout < 0) {
           throw new IllegalArgumentException("timeout value is negative");
       }
   
       if (nanos < 0 || nanos > 999999) {
           throw new IllegalArgumentException(
               "nanosecond timeout value out of range");
       }
   
       if (nanos > 0) {
           timeout++;
       }
   
       wait(timeout);
   }
   ```

2. 调用该方法后当前线程进入睡眠状态，直到以下事件发生。

   - 其他线程调用了该对象的notify方法。
   - 其他线程调用了该对象的notifyAll方法。
   - 其他线程调用了interrupt中断该线程。
   - 时间间隔到了。

   此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常

### notify()方法

概述：唤醒线程

```java
//源码
//唤醒在该对象上等待的某个线程
public final native void notify();
//唤醒在该对象上等待的所有线程
public final native void notifyAll();
```

## 包装类

### 包装类的介绍

1. 基本数据类型直接存储在栈，引用类型存储在堆（栈里是地址）。

2. 包装类：基本数据类型所对应的引用数据类型.

3. 包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。

   Object可统一所有数据，包装类的默认值是null

   <img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240317171603622-386669378.png" alt="image-20240317171610405" width="300" />

4. 基本类型和对应的包装类可以相互转换

5. 所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。

### 拆箱和装箱

1. 装箱：由基本类型向对应的包装类转换称为**装箱**，例如把 int 包装成 Integer 类的对象；

2. 拆箱：包装类向对应的基本类型转换称为**拆箱**，例如把 Integer 类的对象重新简化为 int

3. 手动装箱和拆箱

   ```java
   public static void main(String[] args) {
       //装箱：基本类型->引用类型
       int num1 = 10;
       //1.使用Integer类创建对象
       Integer i1 = new Integer(num1);
       //2.使用Integer.valueof方法
       Integer i2 = Integer.valueOf(num1);
   
       //拆箱：引用类型->基本类型
       Integer i3 = new Integer(100);
       int num2 = i3.intValue();
   }
   ```

4. 自动装箱和拆箱(JDK1.5以后)

   ```java
   //自动装箱
   int age = 30;
   Integer i4 = age;
   //自动拆箱
   int age2 = i4;
   ```

### 类型转换

1. 基本类型和字符串之间转换

   基本类型->字符串

   ```java
   int n1 = 15;
   //1.使用+号
   String s1 = n1 + "";
   //2.使用Integer中的toString方法
   String s2 = Integer.toString(n1);
   //toString方法的重载（转化为16进制）
   String s3 = Integer.toString(n1, 16);   //f
   String hexString = Integer.toHexString(n1);
   ```

   字符串->基本类型

   ```java
   String str = "150";
   //使用Integer.parseXXX()	要求str为纯数字
   int n2 = Integer.parseInt(str);
   ```

2. boolean字符串形式->基本类型

   ```java
   //“true”->true  非“true”->false
   String str2 = "true";
   boolean b1 = Boolean.parseBoolean(str2);
   System.out.println(b1);
   ```

## Math类

1. Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。

2. Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。

3. Math类中的常用值

   >Math.PI 记录的圆周率
   >Math.E 记录e的常量

4. Math类中常用的函数

   基本数学运算：

   |             函数             |              用法              |
   | :--------------------------: | :----------------------------: |
   |      Math.abs(double a)      |        返回参数的绝对值        |
   | Math.max(double a, double b) |    返回两个参数中较大的那个    |
   | Math.min(double a, double b) |    返回两个参数中较小的那个    |
   | Math.pow(double a, double b) |        返回 a 的 b 次方        |
   |     Math.sqrt(double a)      |        返回参数的平方根        |
   |     Math.cbrt(double a)      |        返回参数的立方根        |
   |     Math.round(double a)     | 将参数四舍五入为最接近的整数。 |

   三角函数：

   ```java
   Math.toDegrees() 弧度转化为角度
   Math.toRadians() 角度转化为弧度
   Math.sin(double a)：返回参数的正弦值。
   Math.cos(double a)：返回参数的余弦值。
   Math.tan(double a)：返回参数的正切值。
   Math.asin(double a)：返回参数的反正弦值。
   Math.acos(double a)：返回参数的反余弦值。
   Math.atan(double a)：返回参数的反正切值。
   Math.atan2(double y, double x)：返回 y/x 的反正切值，区间为 (-π, π]。
   ```

   取整函数：

   |         函数         |                        方法                        |
   | :------------------: | :------------------------------------------------: |
   | Math.ceil(double a)  |             返回大于等于参数的最小整数             |
   | Math.floor(double a) |             返回小于等于参数的最大整数             |
   | Math.round(double a) |            将参数四舍五入为最接近的整数            |
   |  Math.IEEEremainder  |                        求余                        |
   |      Math.rint       | 求距离某数最近的整数（可能比某数大，也可能比它小） |
   |    Math.random()     |              返回0-1之间的一个随机数               |

   指数和对数函数：

   ```java
   Math.exp(double a)：返回参数的指数值。
   Math.log(double a)：返回参数的自然对数。
   Math.log10(double a)：返回参数的以 10 为底的对数。
   ```

### BigDecimal类

1. 作用：精确计算浮点数

2. 精度丢失问题

   ```java
   public static void main(String[] args) {
       //double和float是近似值存储
       double d1 = 1.0;    //存的可能是0.9999999999
       double d2 = 0.9;
       System.out.println(d1 - d2); 	//0.09999999999999998   精度丢失
   
       double result = (1.4 - 0.5) / 0.9;
       System.out.println(result);		//0.9999999999999999  
   }
   ```

3. 方法

   ```java
   public static void main(String[] args) {
       BigDecimal bd1 = new BigDecimal("1.0");
       BigDecimal bd2 = new BigDecimal("0.9");
       //1.减法
       BigDecimal r1 = bd1.subtract(bd2);
       System.out.println(r1);     //0.1
       //2.加法
       BigDecimal r2 = bd1.add(bd2);
       System.out.println(r2);     //1.9
       //3.乘法
       BigDecimal r3 = bd1.multiply(bd2);
       System.out.println(r3);     //0.90
       //4.除法
       BigDecimal r4 = new BigDecimal("1.4").subtract(new BigDecimal("0.5")).divide(new BigDecimal("0.9"));
       System.out.println(r4);     //1
       //5.除法除不尽
       //BigDecimal r5 = new BigDecimal("10").divide(new BigDecimal("3"));
       //System.out.println(r5); //异常：.ArithmeticException
       
       //保留两位小数，四舍五入
       BigDecimal r5 = new BigDecimal("10").divide(new BigDecimal("3"), 2, BigDecimal.ROUND_HALF_UP);
       System.out.println(r5); //3.33
   }
   ```

### Random类

java.lang.  Math.Random()函数

能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围是[0.0,1.0)的左闭右开区间，返回值是一个伪随机选择的数，在该范围内（近似）均匀分布。  

```java
public static void main(String[] args) {
    // 结果是个double类型的值，区间为[0.0,1.0）
    System.out.println("Math.random()=" + Math.random());
    int num = (int) (Math.random() * 3);
    // 注意不要写成(int)Math.random()*3，这个结果为0或1，因为先执行了强制转换
    System.out.println("num=" + num);
} /
/结果
//Math.random()=0.44938147153848396
//num=1
```

java.util.Random  函数

1. 构造方法：两种

   ```java
   //创建一个新的随机数生成器
   Random()
   //使用单个 long 种子创建一个新的随机数生成器
   //种子数只是随机算法的起源数字，和生成的随机数的区间没有任何关系
   Random(long seed)
   ```

2. 无参构造

   ```java
   //在没带参数构造函数生成的Random对象的种子缺省是当前系统时间的毫秒数。
   //rand.nextInt(100)中的100是随机数的上限,产生的随机数为0-100的整数,不包括100。
   public static void main(String[] args) {
       Random rand =new Random();
       int i=rand.nextInt(100);
       System.out.println(i);
   }
   ```

3. 有参构造

   ```java
   //对于种子相同的Random对象，生成的随机数序列是一样的
   public static void main(String[] args) {
       Random ran1 = new Random(25);
       System.out.println("使用种子为25的Random对象生成[0,100)内随机整数序列: ");
       for (int i = 0; i < 10; i++) {
       	System.out.print(ran1.nextInt(100) + " ");
       } 
       System.out.println();
       //81 28 47 38 97 98 95 37 96 54
   }
   ```

4. 方法摘要

   ```java
   protected int next(int bits)
       //生成下一个伪随机数。
   boolean nextBoolean()
       //返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的boolean值。
   void nextBytes(byte[] bytes)
       //生成随机字节并将其置于用户提供的 byte 数组中。
   double nextDouble()
       //返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分布的 double值。
   float nextFloat()
       //返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分布float值。
   double nextGaussian()
       //返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的double值，其平均值是0.0标准差是1.0。
   int nextInt()
       //返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。
   int nextInt(int n)
       //返回一个伪随机数，它是取自此随机数生成器序列的、在（包括和指定值（不包括）之间均匀分布的int值。
   long nextLong()
       //返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。
   void setSeed(long seed)
       //使用单个 long 种子设置此随机数生成器的种子。
   ```

5. 例子

   ```java
   //生成[0,1.0)区间的小数
   double d1 = r.nextDouble();
   //生成[0,5.0)区间的小数
   double d2 = r.nextDouble() * 5;
   //生成[1,2.5)区间的小数
   double d3 = r.nextDouble() * 1.5 + 1;
   //生成[0,10)区间的整数
   int n2 = r.nextInt(10);
   ```

   

## 日期时间类

### Date类

1. 作用：表示特定的瞬间，精确到毫秒。Date类中的大部分方法都已经被Calendar类中的方法所取代

2. s -> ms -> μs微秒 -> ns纳秒/毫微秒

3. 构造方法

   ```java
   //1.使用当前日期和时间来初始化对象
   Date();
   //2.接收一个参数，该参数是从1970年1月1日起的毫秒数
   Date(long millisec);
   ```

4. 方法

   | 序号 | 方法和描述                                                   |
   | ---- | ------------------------------------------------------------ |
   | 1    | boolean after(Date date) 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 |
   | 2    | boolean before(Date date) 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 |
   | 3    | Object clone( ) 返回此对象的副本。                           |
   | 4    | int compareTo(Date date) 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 |
   | 5    | int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 |
   | 6    | boolean equals(Object date) 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 |
   | 7    | long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 |
   | 8    | int hashCode( ) 返回此对象的哈希码值。                       |
   | 9    | void setTime(long time) 用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 |
   | 10   | String toString( ) 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 |

   ```java
   public static void main(String[] args) {
       //1.创建Date对象
       Date d1 = new Date();
       //2.今天
       System.out.println(d1.toString());  //Tue Mar 19 15:15:46 CST 2024
       System.out.println(d1.toLocaleString());    //2024-3-19 15:16:18
       //3.昨天
       Date d2 = new Date(d1.getTime() - (60 * 60 * 24 * 1000));
       System.out.println(d2.toLocaleString());    //2024-3-18 15:19:01
       //4.after     d1在d2之后吗
       System.out.println(d1.after(d2));   //true
       //5.before    d1在d2之前吗
       System.out.println(d1.before(d2));  //false
       //6.compareTo()
       System.out.println(d1.compareTo(d2));   //1
       System.out.println(d2.compareTo(d1));   //-1
       System.out.println(d1.compareTo(d1));   //0
       //7.equals()
       System.out.println(d1.equals(d2));  //false
   
   }
   ```

### SimpleDateFormat

1. 作用：进行格式化(日期->文本)、解析(文本->日期)

2. 时间模式字母

   | 字母 | 描述                     | 示例                    |
   | ---- | ------------------------ | ----------------------- |
   | G    | 纪元标记                 | AD                      |
   | y    | 四位年份                 | 2001                    |
   | M    | 月份                     | July or 07              |
   | d    | 一个月的日期             | 10                      |
   | h    | A.M./P.M. (1~12)格式小时 | 12                      |
   | H    | 一天中的小时 (0~23)      | 22                      |
   | m    | 分钟数                   | 30                      |
   | s    | 秒数                     | 55                      |
   | S    | 毫秒数                   | 234                     |
   | E    | 星期几                   | Tuesday                 |
   | D    | 一年中的日子             | 360                     |
   | F    | 一个月中第几周的周几     | 2 (second Wed. in July) |
   | w    | 一年中第几周             | 40                      |
   | W    | 一个月中第几周           | 1                       |
   | a    | A.M./P.M. 标记           | PM                      |
   | k    | 一天中的小时(1~24)       | 24                      |
   | K    | A.M./P.M. (0~11)格式小时 | 10                      |
   | z    | 时区                     | Eastern Standard Time   |
   | '    | 文字定界符               | Delimiter               |
   | "    | 单引号                   | `                       |

3. 格式化：日期->字符串

   ```java
   public static void main(String[] args) {
       //1.创建SimpleDateFormat对象
       SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");
       //2.创建Date
       Date date = new Date();
       //3.格式化Date
       String string = sdf.format(date);
       System.out.println(string); //2024年03月19日16:23:30
   }
   ```

4. 解析：字符串->日期

   ```java
   Date date2 = sdf.parse("2024年03月19日16:23:30");
   System.out.println(date2);
   //Tue Mar 19 16:23:30 CST 2024
   ```

### Calendar

1. 作用：提供了获取或设置各种日历字段的方法

2. 源码

   ```java
   //Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可
   public abstract class Calendar implements Serializable, Cloneable, Comparable<Calendar> {}
   //构造方法
   //protected;无法直接创建该对象
   protected Calendar()
   {
       this(TimeZone.getDefaultRef(), Locale.getDefault(Locale.Category.FORMAT));
       sharedZone = true;
   }
   ```

3. Calendar类对象字段类型

   | 常量                  | 描述                           |
   | --------------------- | ------------------------------ |
   | Calendar.YEAR         | 年份                           |
   | Calendar.MONTH        | 月份                           |
   | Calendar.DATE         | 日期                           |
   | Calendar.DAY_OF_MONTH | 日期，和上面的字段意义完全相同 |
   | Calendar.HOUR         | 12小时制的小时                 |
   | Calendar.HOUR_OF_DAY  | 24小时制的小时                 |
   | Calendar.MINUTE       | 分钟                           |
   | Calendar.SECOND       | 秒                             |
   | Calendar.DAY_OF_WEEK  | 星期几                         |

4. 方法

   ```java
   public static void main(String[] args) {
       //1.创建Calendar对象
       Calendar calendar = Calendar.getInstance();
       //System.out.println(calendar);   //打印过多乱七八糟的
       System.out.println(calendar.getTime());     //Tue Mar 19 15:34:22 CST 2024
       System.out.println(calendar.getTime().toLocaleString());     //2024-3-19 15:34:54
       System.out.println(calendar.getTimeInMillis());     //1710833741822(1970至今的毫秒值)
       //2.获取时间信息
       System.out.println(calendar.get(Calendar.YEAR));    //2024
       System.out.println(calendar.get(Calendar.MONTH) + 1);    //2    月是从0开始的
       System.out.println(calendar.get(Calendar.DATE));    //19    Calendar.DAY_OF_MONTH
       System.out.println(calendar.get(Calendar.HOUR));  //3    HOUR十二小时制   HOUR_OF_DAY二十四小时制
       System.out.println(calendar.get(Calendar.MINUTE));  //42
       System.out.println(calendar.get(Calendar.SECOND));  //13
       //3.修改时间信息
       calendar.set(Calendar.DAY_OF_MONTH, 5);
       System.out.println(calendar.getTime().toLocaleString());    //2024-3-5 15:46:23
       //4.add修改
       calendar.add(Calendar.HOUR, -5);
       System.out.println(calendar.getTime().toLocaleString());    //2024-3-5 10:47:39
       //6.getActualMaximum()  getActualMinimum()
       int max = calendar.getMaximum(Calendar.DAY_OF_MONTH);
       System.out.println(max);    //31
       int min = calendar.getMinimum(Calendar.DAY_OF_MONTH);
       System.out.println(min);    //1
   }
   ```

## String类

### 概述

1. 字符串是常量，它们的值创建之后不可改变，改变的只是地址，原来的字符串还是存在的，并且产生垃圾。

2. 字符串字面值存储在字符串池中，字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。

   ```java
   //String的成员变量 
   
   //String的属性值
   private final char value[];
   //数组被使用的开始位置
   private final int offset;
   //String中元素的个数
   private final int count;
   //String类型的hash值
   private int hash; // Default to 0
   private static final long serialVersionUID = -6849794470754667710L;
   private static final ObjectStreamField[] serialPersistentFields =
   new ObjectStreamField[0];
   ```

   - 从源码看出String底层使用一个字符数组来维护的。
   - 成员变量可以知道String类的值是final类型的，不能被改变的，所以只要一个值改变就会生成一个新的String类型对象。
   - 存储String数据也不一定从数组的第0个元素开始的，而是从offset所指的元素开始。

   ```java
   public static void main(String[] args) {
       String name = "hello";    //此常量存储在字符串池中
       name = "zhangsan";   
       //nihao赋值给name,给字符串复制时，并没有修改数据，而是重新开辟了一个空间
       String name2 = "zhangsan";
   }
   ```

   <img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240317182828469-1260847449.png" alt="image-20240317182835218" width="300" />

### 创建字符串的两种方式

1. 直接赋值方式创建对象是在方法区的常量

   通过构造方法创建字符串是在堆内存

   ```java
   //产生一个对象，字符串池中存储
   String name="hello";
   //产生两个对象，堆、池各存储一个
   String str=new String("java");
   String str2=new String("java");	
   System.out.println(str==str2); //false地址不同
   //首先，出现了字面量"java"，那么去String Pool中查找是否有相同字符串存在，因为程序就这一行代码所以肯定没有，那么就在Java Heap（堆）中用字面量"java"首先创建1个String对象。
   //接着，new String("java")，关键字new又在Java Heap中创建了1个对象，然后调用接收String参数的构造器进行了初始化。最终str的引用是这个String对象
   ```

   <img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240317184216120-154971083.png" alt="image-20240317184222629" width="300" />

   手工入池

   ```java
   //对匿名对象"java"进行手工入池操作
   String str =new String("java").intern();
   String str1="java";
   System.out.println(str==str1); //true
   ```

2. 两种实例化方式的区别

   - 直接赋值（String str = "hello"）：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。
   - 构造方法（String str= new String("hello")）:会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public String intern();方法进行手工入池。
   - 在开发的过程中不会采用构造方法进行字符串的实例化。

3. 避免空指向

   ```java
   //==在对字符串比较的时候，对比的是内存地址
   //而equals比较的是字符串内容，在开发的过程中，equals()通过接受参数，可以避免空指向
   String str = null;
   if(str.equals("hello")){//此时会出现空指向异常}
       
   if("hello".equals(str)){//此时equals会处理null值，可以避免空指向异常
   ```

### 常用的方法

<img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240317190937211-750135660.png" alt="image-20240317190943771" width="400" />

1. String的判断

   ```java
   //方法
   boolean equals(Object obj)：比较字符串的内容是否相同
   compareTo(Object obj)：比较字符串在字典表里的大小或长度
   boolean equalsIgnoreCase(String str)： 比较字符串的内容是否相同,忽略大小写
   boolean startsWith(String str)： 判断字符串对象是否以指定的str开头
   boolean endsWith(String str)： 判断字符串对象是否以指定的str结尾
   ```

   ```java
   public static void main(String[] args) {
       // 创建字符串对象
       String s1 = "hello";
       String s2 = "hello";
       String s3 = "Hello";
       //1. boolean equals(Object obj):比较字符串的内容是否相同
       System.out.println(s1.equals(s2)); //true
       System.out.println(s1.equals(s3)); //false
       System.out.println("-----------");
       //2. boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写
       System.out.println(s1.equalsIgnoreCase(s2)); //true
       System.out.println(s1.equalsIgnoreCase(s3)); //true
       System.out.println("-----------");
       //3. boolean startsWith(String str):判断字符串对象是否以指定的str开头
       System.out.println(s1.startsWith("he")); //true
       System.out.println(s1.startsWith("ll")); //false
   }
   ```

2. String的截取

   ```java
   //方法
   int length():获取字符串的长度，其实也就是字符个数
   char charAt(int index):获取指定索引处的字符
   int indexOf(String str):获取str在字符串对象中第一次出现的索引。存在返回下标，不存在返回-1
   String substring(int start):从start开始截取字符串
   String substring(int start,int end):从start开始，end结束截取字符串。包括start，不包括end
   ```

   ```java
   public static void main(String args[]) {
       // 创建字符串对象
       String s = "helloworld";
       //4. int length():获取字符串的长度，其实也就是字符个数
       System.out.println(s.length()); //10
       System.out.println("--------");
       //5. char charAt(int index):获取指定索引处的字符
       System.out.println(s.charAt(0)); //h
       System.out.println(s.charAt(1)); //e
       System.out.println("--------");
       //6. int indexOf(String str):获取str在字符串对象中第一次出现的索引
       System.out.println(s.indexOf("l")); //2
       System.out.println(s.indexOf("owo")); //4
       System.out.println(s.indexOf("ak")); //-1
       System.out.println("--------");
       //7. String substring(int start):从start开始截取字符串
       System.out.println(s.substring(0)); //helloworld
       System.out.println(s.substring(5)); //world
       System.out.println("--------");
       //8. String substring(int start,int end):从start开始，到end结束截取字符串
       System.out.println(s.substring(0, s.length())); //helloworld
       System.out.println(s.substring(3, 8)); //lowor
   }
   ```

3. String的转换

   ```java
   //方法
   char[] toCharArray()：把字符串转换为字符数组
   String toLowerCase()：把字符串转换为小写字符串
   String toUpperCase()：把字符串转换为大写字符串
   ```

   ```java
   public static void main(String args[]){
       String s = "abcde";
       //9. char[] toCharArray():把字符串转换为字符数组
       char[] chs = s.toCharArray();
       for (int x = 0; x < chs.length; x++) {
       System.out.println(chs[x]);
       }
       System.out.println("-----------");
       //10. String toLowerCase():把字符串转换为小写字符串
       System.out.println("HelloWorld".toLowerCase());
       //11. String toUpperCase():把字符串转换为大写字符串
       System.out.println("HelloWorld".toUpperCase());
   }
   ```

4. 其他方法

   ```java
   //方法
   去除字符串两端空格：String trim()
   按照指定符号分割字符串：String[] split(String str)
   将旧字符串替换成新字符串：String replace(char oldChar,char newChar)
   ```

   ```java
   public static void main(String args[]) {
       //12.String trim()
       // 创建字符串对象
       String s1 = "helloworld";
       String s2 = " helloworld ";
       String s3 = " hello world ";
       System.out.println("---" + s1 + "---");
       System.out.println("---" + s1.trim() + "---");
       System.out.println("---" + s2 + "---");
       System.out.println("---" + s2.trim() + "---");	//---helloworld---
       System.out.println("---" + s3 + "---");
       System.out.println("---" + s3.trim() + "---");	//---hello world---
       System.out.println("-------------------");
       //13. String[] split(String str)
       // 创建字符串对象
       String s4 = "aa,bb,cc";
       String[] strArray = s4.split(",");
       //String[] strArray = s4.split("[ ,]+");正则表达式：【】选择；+一个或多个
       for (int x = 0; x < strArray.length; x++) {
       System.out.println(strArray[x]);
       /*aa
   	bb
   	cc*/
       //14.String replace(char oldChar,char newChar)
       System.out.println("---" + s3.trim().replace(" ","") + "---");
       //---helloworld---
       }
   }
   ```

5. 例子

   ```java
   public static void main(String[] args) {
       String str = "this is a text";
       //1."this is a text"分割
       String[] str1 = str.split(" ");
       for (int i = 0; i < str1.length; i++) {
           System.out.print(str1[i] + " ");
       }
       String str2 = str.replace("text", "pratice");
       System.out.println(str2);
       //2.text前面加上easy
       String str3 = str.replace("text", "easy text");
       System.out.println(str3);
       //3.首字母大写
       for (int i = 0; i < str1.length; i++) {
           char first = str1[i].charAt(0);
           //把第一个字符转成大写
           char upperfirst = Character.toUpperCase(first);
   
           String news = upperfirst + str1[i].substring(1);
           System.out.print(news);
       }
   }
   ```

## StringBuilder和StringBuffer

比String效率高，比String节省内存

### 概述

1. StringBuffer：可变长字符串，JDK1.0提供，运行效率慢、线程安全。

2. StringBuilder：可变长字符串，JDK5.0提供，运行效率快、线程不安全。

3. 源码

   ```java
   package java.lang;
   
   public final class StringBuilder
   	extends AbstractStringBuilder
   	implements java.io.Serializable, CharSequence 
   {
   	static final long serialVersionUID = 4383685877147921099L;
       // 构造函数。默认的字符数组大小是16。
       public StringBuilder() {
       super(16);
       }
       // 构造函数。指定StringBuilder的字符数组大小是capacity。
       public StringBuilder(int capacity) {
       	super(capacity);
       }   
       // 构造函数。指定字符数组大小=str长度+15，且将str的值赋值到当前字符数组中。
       public StringBuilder(String str) {
           super(str.length() + 16);
           append(str);
       } 
       // 构造函数。指定字符数组大小=seq长度+15，且将seq的值赋值到当前字符数组中。
       public StringBuilder(CharSequence seq) {
           this(seq.length() + 16);
           append(seq);
       }
       // 追加“对象obj对应的字符串”。String.valueOf(obj)实际上是调用obj.toString()
       public StringBuilder append(Object obj) {
       	return append(String.valueOf(obj));
       }
       // 追加“str”。
       public StringBuilder append(String str) {
           super.append(str);
           return this;
       }
       // 追加“sb的内容”。
       private StringBuilder append(StringBuilder sb) {
           if (sb == null)
                return append("null");
           int len = sb.length();
           int newcount = count + len;
           if (newcount > value.length)
           	expandCapacity(newcount);
           sb.getChars(0, len, value, count);
           count = newcount;
           return this;
       }  
       // 追加“sb的内容”。
       public StringBuilder append(StringBuffer sb) {
           super.append(sb);
           return this;
       } 
       // 追加“s的内容”。
       public StringBuilder append(CharSequence s) {
           if (s == null)
           	s = "null";
           if (s instanceof String)
           	return this.append((String)s);
           if (s instanceof StringBuffer)
           	return this.append((StringBuffer)s);
           if (s instanceof StringBuilder)
           	return this.append((StringBuilder)s);
           return this.append(s, 0, s.length());
       }
       // 追加“s从start(包括)到end(不包括)的内容”。
       public StringBuilder append(CharSequence s, int start, int end) {
           super.append(s, start, end);
           return this;
       }
       // 追加“str字符数组对应的字符串”
       public StringBuilder append(char[] str) {
           super.append(str);
           return this;
       }
       // 追加“str从offset开始的内容，内容长度是len”
       public StringBuilder append(char[] str, int offset, int len) {
           super.append(str, offset, len);
           return this;
       }
       // 追加“b对应的字符串”
       public StringBuilder append(boolean b) {
           super.append(b);
           return this;
       }
       // 追加“c”
       public StringBuilder append(char c) {
           super.append(c);
           return this;
       }
       // 追加“i”
       public StringBuilder append(int i) {
           super.append(i);
           return this;
       }
       // 追加“lng”
       public StringBuilder append(long lng) {
           super.append(lng);
           return this;
       }
       // 追加“f”
       public StringBuilder append(float f) {
           super.append(f);
           return this;
       }
       // 追加“d”
       public StringBuilder append(double d) {
           super.append(d);
           return this;
       }
       // 追加“codePoint”
       public StringBuilder appendCodePoint(int codePoint) {
           super.appendCodePoint(codePoint);
           return this;
       }
       
       // 删除“从start(包括)到end的内容”
       public StringBuilder delete(int start, int end) {
           super.delete(start, end);
           return this;
       }
       // 删除“位置index的内容”
       public StringBuilder deleteCharAt(int index) {
           super.deleteCharAt(index);
           return this;
       }
       
       // “用str替换StringBuilder中从start(包括)到end(不包括)的内容”
       public StringBuilder replace(int start, int end, String str) {
           super.replace(start, end, str);
           return this;
       }
       
       // “在StringBuilder的位置index处插入‘str中从offset开始的内容’，插入内容长度是len”
       public StringBuilder insert(int index, char[] str, int offset,int len)
       {
           super.insert(index, str, offset, len);
           return this;
       }
       // “在StringBuilder的位置offset处插入obj对应的字符串”
       public StringBuilder insert(int offset, Object obj) {
      	 	return insert(offset, String.valueOf(obj));
       }
       // “在StringBuilder的位置offset处插入str”
       public StringBuilder insert(int offset, String str) {
           super.insert(offset, str);
           return this;
       }
       // “在StringBuilder的位置offset处插入str”
       public StringBuilder insert(int offset, char[] str) {
           super.insert(offset, str);
           return this;
       }
       // “在StringBuilder的位置dstOffset处插入s”
       public StringBuilder insert(int dstOffset, CharSequence s) {
           if (s == null)
           	s = "null";
           if (s instanceof String)
           	return this.insert(dstOffset, (String)s);
           return this.insert(dstOffset, s, 0, s.length());
       }
       // “在StringBuilder的位置dstOffset处插入's中从start到end的内容'”
       public StringBuilder insert(int dstOffset, CharSequence s,
       int start, int end)
       {
           super.insert(dstOffset, s, start, end);
           return this;
       }
       // “在StringBuilder的位置Offset处插入b”
       public StringBuilder insert(int offset, boolean b) {
           super.insert(offset, b);
           return this;
       }
       // “在StringBuilder的位置Offset处插入c”
       public StringBuilder insert(int offset, char c) {
           super.insert(offset, c);
           return this;
       }
       // “在StringBuilder的位置Offset处插入i”
       public StringBuilder insert(int offset, int i) {
       	return insert(offset, String.valueOf(i));
       }
       // “在StringBuilder的位置Offset处插入l”
       public StringBuilder insert(int offset, long l) {
       	return insert(offset, String.valueOf(l));
       }
       // “在StringBuilder的位置Offset处插入f”
       public StringBuilder insert(int offset, float f) {
       	return insert(offset, String.valueOf(f));
       }
       // “在StringBuilder的位置Offset处插入d”
       public StringBuilder insert(int offset, double d) {
       	return insert(offset, String.valueOf(d));
       }
       
       // 返回“str”在StringBuilder的位置
       public int indexOf(String str) {
       	return indexOf(str, 0);
       }
       // 从fromIndex开始查找，返回“str”在StringBuilder的位置
       public int indexOf(String str, int fromIndex) {
       	return String.indexOf(value, 0, count,str.toCharArray(), 0, str.length(),fromIndex);
       }
       // 从后向前查找，返回“str”在StringBuilder的位置
       public int lastIndexOf(String str) {
       	return lastIndexOf(str, count);
       }
       // 从fromIndex开始，从后向前查找，返回“str”在StringBuilder的位置
       public int lastIndexOf(String str, int fromIndex) {
       	return String.lastIndexOf(value, 0, count,str.toCharArray(), 0, str.length(),fromIndex);
       }
       
       // 反转StringBuilder
       public StringBuilder reverse() {
           super.reverse();
           return this;
       }
       
       public String toString() {
           // Create a copy, don't share the array
           return new String(value, 0, count);
   	}
       
       // 序列化对应的写入函数
       private void writeObject(java.io.ObjectOutputStream s)
           throws java.io.IOException {
           s.defaultWriteObject();
           s.writeInt(count);
           s.writeObject(value);
       }
       // 序列化对应的读取函数
       private void readObject(java.io.ObjectInputStream s)
           throws java.io.IOException, ClassNotFoundException {
           s.defaultReadObject();
           count = s.readInt();
           value = (char[]) s.readObject();
       }
   }
   ```

### 方法

1. append() 追加

   ```java
   private static void testAppendAPIs() {
       System.out.println("------- testAppendAPIs ---------");
       StringBuilder sbuilder = new StringBuilder();
       // 追加字符数组
       sbuilder.append(new char[]{'a','b','c','d','e'});
       // 追加字符数组。0表示字符数组起始位置，3表示长度
       sbuilder.append(new char[]{'A','B','C','D','E'}, 0, 3);
       // 追加float
       sbuilder.append(1.414f);
       // 追加double
       sbuilder.append(3.14159d);
       // 追加boolean
       sbuilder.append(true);
       // 追加char
       sbuilder.append('\n');
       // 追加int
       sbuilder.append(100);
       // 追加long
       sbuilder.append(12345L);
       // 追加StringBuilder对象
       sbuilder.append(new StringBuilder("StringBuilder"));
       // 追加StringBuilder对象。6表示被追加对象的起始位置(包括)，13是结束位置(不包括)
       sbuilder.append(new StringBuilder("STRINGBUILDER"), 6, 13);
       // 追加StringBuffer对象。
       sbuilder.append(new StringBuffer("StringBuffer"));
       // 追加StringBuffer对象。6表示被追加对象的起始位置(包括)，12是结束位置(不包括)
       sbuilder.append(new StringBuffer("STRINGBUFFER"), 6, 12);
       // 追加String对象。
       sbuilder.append("String");
       // 追加String对象。1表示被追加对象的起始位置(包括)，6是结束位置(不包括)
       sbuilder.append("0123456789", 1, 6);
       sbuilder.append('\n');
       // 追加Object对象。此处以HashMap为例
       HashMap map = new HashMap();
       map.put("1", "one");
       map.put("2", "two");
       map.put("3", "three");
       sbuilder.append(map);
       sbuilder.append('\n');
       // 追加unicode编码
       sbuilder.appendCodePoint(0x5b57); // 0x5b57是“字”的unicode编码
       sbuilder.appendCodePoint(0x7b26); // 0x7b26是“符”的unicode编码
       sbuilder.appendCodePoint(0x7f16); // 0x7f16是“编”的unicode编码
       sbuilder.appendCodePoint(0x7801); // 0x7801是“码”的unicode编码
       System.out.printf("%s\n\n", sbuilder);
   }
   //
   ------- testAppendAPIs ---------
   abcde/ABC/1.414/3.14159/true
   100/12345/StringBuilder/BUILDER/StringBuffer/BUFFER/String/12345
   {1=one, 2=two, 3=three}
   字符编码
   ```

2. insert() 添加

   ```java
   private static void testInsertAPIs(){
       System.out.println("---------- testInsertAPIs -----------");
       StringBuilder sbuilder = new StringBuilder();
       // 在位置0处插入字符数组
       sbuilder.insert(0, new char[]{'a', 'b', 'c', 'd', 'e'});
       // 在位置0处插入字符数组。0表示字符数组起始位置，3表示长度
       sbuilder.insert(0, new char[]{'A', 'B', 'C', 'D', 'E'}, 0, 3);
       // 在位置0处插入float
       sbuilder.insert(0, 1.414f);
       // 在位置0处插入double
       sbuilder.insert(0, 3.14159d);
       // 在位置0处插入boolean
       sbuilder.insert(0, true);
       // 在位置0处插入char
       sbuilder.insert(0, '\n');
       // 在位置0处插入int
       sbuilder.insert(0, 100);
       // 在位置0处插入long
       sbuilder.insert(0, 12345L);
       // 在位置0处插入StringBuilder对象
       sbuilder.insert(0, new StringBuilder("StringBuilder"));
       // 在位置0处插入StringBuilder对象。6表示被在位置0处插入对象的起始位置(包括)，13结束位置(不包括)
       sbuilder.insert(0, new StringBuilder("STRINGBUILDER"), 6, 13);
       // 在位置0处插入StringBuffer对象。
       sbuilder.insert(0, new StringBuffer("StringBuffer"));
       // 在位置0处插入StringBuffer对象。6表示被在位置0处插入对象的起始位置(包括)，12是结束位置(不包括)
       sbuilder.insert(0, new StringBuffer("STRINGBUFFER"), 6, 12);
       // 在位置0处插入String对象。
       sbuilder.insert(0, "String");    
   	// 在位置0处插入String对象。1表示被在位置0处插入对象的起始位置(包括)，6是结束位置(不包括)
       sbuilder.insert(0, "0123456789", 1, 6);
       sbuilder.insert(0, '\n');
       // 在位置0处插入Object对象。此处以HashMap为例
       HashMap map = new HashMap();
       map.put("1", "one");
       map.put("2", "two");
       map.put("3", "three");
       sbuilder.insert(0, map);
       System.out.printf("%s\n\n", sbuilder);
   }
   //
   ---------- testInsertAPIs -----------
   {1=one, 2=two, 3=three}
   12345/String/BUFFER/StringBuffer/BUILDER/StringBuilder/12345/100
   true/3.14159/1.414/ABC/abcde
   ```

3. replace()  换头不换尾

   reverse()反转

   setCharAt()置换字符

   ```java
   private static void testReplaceAPIs() {
       System.out.println("------- testReplaceAPIs--------");
       StringBuilder sbuilder;
       sbuilder = new StringBuilder("0123456789");
       //把第0-3个字符换为“ABCDE”
       sbuilder.replace(0, 3, "ABCDE");
       System.out.printf("sbuilder=%s\n", sbuilder);
       sbuilder = new StringBuilder("0123456789");
       //反转
       sbuilder.reverse();
       System.out.printf("sbuilder=%s\n", sbuilder);
       sbuilder = new StringBuilder("0123456789");
       //把第0个字符换为'M'
       sbuilder.setCharAt(0, 'M');
       System.out.printf("sbuilder=%s\n", sbuilder);
       System.out.println();
   }
   //
   ------- testReplaceAPIs--------
   sbuilder=ABCDE3456789
   sbuilder=9876543210
   sbuilder=M123456789
   ```

4. delete() 删除 删头不删尾

   substring()获取字符串

   ```java
   private static void testDeleteAPIs() {
       System.out.println("------------------- testDeleteAPIs -------------------");
       StringBuilder sbuilder = new StringBuilder("0123456789");
       // 删除位置0的字符，剩余字符是“123456789”。
       sbuilder.deleteCharAt(0);
       // 删除位置3(包括)到位置6(不包括)之间的字符，剩余字符是“123789”。
       sbuilder.delete(3,6);
       // 获取sb中从位置1开始的字符串
       String str1 = sbuilder.substring(1);
       // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串
       String str2 = sbuilder.substring(3, 5);
       // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串，获取的对象是CharSequence对象，此处转型为String
       String str3 = (String)sbuilder.subSequence(3, 5);
       System.out.printf("sbuilder=%s\nstr1=%s\nstr2=%s\nstr3=%s\n",
       sbuilder, str1, str2, str3);
   }
   //
   ------------------- testDeleteAPIs -------------------
   sbuilder=123789
   str1=23789
   str2=78
   str3=78
   ```

5. index()

   ```java
   private static void testIndexAPIs() {
           System.out.println("-------- testIndexAPIs --------------");
           StringBuilder sbuilder = new StringBuilder("abcAbcABCabCaBcAbCaBCabc");
           System.out.println("sbuilder=" + sbuilder);
   	// 1. 从前往后，找出"bc"第一次出现的位置
           System.out.println("sbuilder.indexOf(\"bc\")" + "=" + 	sbuilder.indexOf("bc"));
   	// 2. 从位置5开始，从前往后，找出"bc"第一次出现的位置
           System.out.println("sbuilder.indexOf(\"bc\",5)" + "=" + sbuilder.indexOf("bc", 5));
   	// 3. 从后往前，找出"bc"第一次出现的位置
           System.out.println("sbuilder.lastIndexOf(\"bc\")" + "=" + sbuilder.lastIndexOf("bc"));
   	// 4. 从位置4开始，从后往前，找出"bc"第一次出现的位置
           System.out.println("sbuilder.lastIndexOf(\"bc\",4)" + "=" + sbuilder.lastIndexOf("bc", 4));
           System.out.println();
       }
   //
   -------------------------------- testIndexAPIs ----- ---------------------------
   sbuilder=abcAbcABCabCaBcAbCaBCabc
   sbuilder.indexOf("bc")=1
   sbuilder.indexOf("bc",5)=22
   sbuilder.lastIndexOf("bc")=22
   sbuilder.lastIndexOf("bc",4)=4
   ```

6. 其他API（应用编程接口）

   capacity()返回的是字符串缓冲区的容量

   charAt(i)返回下标为i的字符

   getChars(start,end,c,offset)将当前字符串从start到end-1位置上的字符复制到字符数组c中，并从c的offset处开始存放

   ```java
   private static void testOtherAPIs() {
       System.out.println("----------- testOtherAPIs -----------");
       StringBuilder sbuilder = new StringBuilder("0123456789");
       
       int cap = sbuilder.capacity();
       System.out.printf("cap=%d\n", cap);
       /*
       capacity()返回的是字符串缓冲区的容量
       StringBuffer( ); 分配16个字符的缓冲区
       StringBuffer( int len ); 分配len个字符的缓冲区
       StringBuffer( String s ); 除了按照s的大小分配空间外,再分配16个 字符的缓冲区
       你的StringBuffer是用字符构造的，"0123456789"的长度是10另外再分配16个字符，所
       以一共是26。
       */
       char c = sbuilder.charAt(6);
       System.out.printf("c=%c\n", c);
       
       char[] carr = new char[4];
       sbuilder.getChars(3, 7, carr, 0);
       for (int i=0; i<carr.length; i++){
       System.out.printf("carr[%d]=%c ", i, carr[i]);
       } 
       System.out.println();
   }
   //
   ----------- testOtherAPIs -----------
   cap=26
   c=6
   carr[0]=3 carr[1]=4 carr[2]=5 carr[3]=6 
   ```

## String、StringBuffer、StringBuilder之间的区别  

String 字符串常量 - -StringBuffer 字符串变量（线程安全）- -StringBuilder 字符串变量（非线程安全）  

1. StringBuilder 与StringBuffer的区别，StringBuilder与String的区别。

   - StringBuilder效率高，线程不安全，StringBuffer效率低，线程安全。
   - String是不可变字符串，StringBuilder是可变字符串。为什么有这样的差异，可以深入源码去解析，比如String类内的 priver final char value[] 等方法的原因。
   - 如果是简单的声明一个字符串没有后续过多的操作，使用String,StringBuilder均可，若后续对字符穿做频繁的添加，删除操作,或者是在循环当中动态的改变字符穿的长度应该用StringBuilder。使用String会产生多余的字符串，占用内存空间

2. 在大多数情况下三者在执行速度方面的比较：StringBuilder > StringBuffer > String

3. String 类型和 StringBuffer 类型的主要性能区别：

   - String 是不可变的对象, 因此在每次对 String类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。
   - 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。

4. 某些特别情况下

    String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的  

   ```java
   String S1 = “This is only a” + “ simple” + “ test”;
   StringBuffer Sb = new StringBuilder(“This is only a”).append(“
   simple”).append(“ test”);
   //但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了
   ```

5. StringBuilder 类型和 StringBuffer 类型的主要性能区别：

   - 如果可能，建议优先采用StringBuilder，因为在大多数实现中，它比StringBuffer 要快。
   - 大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的。此类提供一个与 StringBuffer兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。两者的方法基本相同  

6. 对于三者使用的总结：

   - 如果要操作少量的数据用 = String
   - 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder
   - 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer

## System类

1. 作用：系统类，主要用于获取系统的属性数据和其他操作，构造方法私有

2. 方法

   ```java
   public static void main(String[] args) {
       //1.arraycopy；数组的复制
       //src:原数组   srcPos:从哪个位置开始复制    dest：目标数组   destPos:目标数组的位置 length：复制的长度
       int[] arr = {1, 2, 3, 4, 5, 6, 7, 8};
       int[] dest = new int[8];
       System.arraycopy(arr, 0, dest, 0, arr.length);
       for (int i = 0; i < dest.length; i++) {
           System.out.print(dest[i] + " ");    //1 2 3 4 5 6 7 8 
       }
       //2.currentTimeMillis():从1970年至今的毫秒数，计时用
       System.out.println(System.currentTimeMillis());
       //3.System.gc();告诉垃圾回收器回收
           Student s1 = new Student("aaa", 19);
           Student s2 = new Student("bbb", 19);
           new Student("ccc", 19);
           System.gc();
           //回收了ccc 19
       //重写Student类中的finalize方法
        protected void finalize() throws Throwable {
           System.out.println("回收了" + name + " " + age);
       }
       //4.exit();退出JVM
       System.exit(0);
       System.out.println("OVER!");
       //不会输出OVER
   }
   ```

## File类

java.io.File类：文件和目录路径名的抽象表示形式

### File类的常见构造方法

```java
//以pathname为路径创建File对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。
public File(String pathname)
```

### 访问文件的属性

```java
//File的静态属性String separator存储了当前系统的路径分隔符
//通过File对象可以访问文件的属性
public boolean canRead()
public boolean exists()
public boolean isFile()
public long lastModified()
public String getName()
public boolean canWrite()
public boolean isDirectory()
public boolean isHidden()
public long length()
public String getPath()
```

### 创建空文件或目录

```java
//在该对象所指的文件或目录不存在的情况下
public boolean createNewFile()throws IOException
public boolean delete()
public boolean mkdir()， mkdirs()
```

### 例子

```java
/**
* File文件类 1.代表文件 2.代表目录
*/ 
public static void main(String[] args) {
    File f = new File("d:/src3/TestObject.java");
    File f2 = new File("d:/src3");
    File f3 = new File(f2, "TestFile.java");
    File f4 = new File(f2, "TestFile666.java");
    File f5 = new File("d:/src3/aa/bb/cc/dd");
    //f5.mkdirs();
    f5.delete();
    try {
    f4.createNewFile();
    System.out.println("文件创建成功！");
    } catch (IOException e) {
    e.printStackTrace();
    }
    if (f.isFile()) {
    System.out.println("是一个文件！");
    }
    if (f2.isDirectory()) {
    System.out.println("是一个目录！");
    }
    if (f3.isFile()) {
    System.out.println("是一个文件奥");
}
```

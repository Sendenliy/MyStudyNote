# 基本概念

## 前言

Web开发

- web，网页的意思 ， www.baidu.com
- 静态web
  - html，css
  - 提供给所有人看的数据始终不会发生变化！
- 动态web
  - 淘宝，几乎是所有的网站；
  - 提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！
- 技术栈：Servlet/JSP，ASP，PHP

在Java中，动态web资源开发的技术统称为JavaWeb；

## Web应用程序

web应用程序：可以提供浏览器访问的程序；

- a.html、b.html......多个web资源，这些web资源可以被外界访问，对外界提供服务；
- 你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上
- URL
- 这个统一的web资源会被放在同一个文件夹下，web应用程序-->Tomcat：服务器
- 一个web应用由多部分组成 （静态web，动态web）
  - html，css，js
  - jsp，servlet 
  - Java程序
  - jar包
  - 配置文件 （Properties）

web应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；

## 静态Web

.htm, .html,这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240416195035518-1890880946.png" alt="image-20240416195040718" width="500" />

静态web存在的缺点

- Web页面无法动态更新，所有用户看到都是同一个页面
  - 轮播图，点击特效：伪动态
  - JavaScript [实际开发中，它用的最多] 
  - VBScript
- 它无法和数据库交互（数据无法持久化，用户无法交互）

## 动态Web

页面会动态展示： “Web的页面展示的效果因人而异”；  

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240416195401723-1177076809.png" alt="image-20240416195407138" width="500" />

缺点：

- 假如服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布（停机维护）

优点：

- Web页面可以动态更新，所有用户看到都不是同一个页面
- 它可以与数据库交互 （数据持久化：注册，商品信息，用户信息........）

# Web服务器

## 技术讲解

### ASP

- 微软：国内最早流行的就是ASP；
- 在HTML中嵌入了VB的脚本， ASP + COM；
- 在ASP开发中，基本一个页面都有几千行的业务代码，页面极其混乱
- 维护成本高！
- C# 
- IIS

```html
<h1>
    <h1><h1>
        <h1>
            <h1>
                <%
                System.out.println("hello")
                %>
            <h1>
        <h1>
    <h1><h1>
<h1>
```

### php

- PHP开发速度很快，功能很强大，跨平台，代码很简单 （70% , WP）
- 无法承载大访问量的情况（局限性）  

### JSP/Servlet

B/S：浏览器和服务器

C/S: 客户端和服务器

- sun公司主推的B/S架构
- 基于Java语言的 (所有的大公司，或者一些开源的组件，都是用Java写的)
- 可以承载三高问题(高并发、高可用、高性能)带来的影响；
- 语法像ASP ， ASP-->JSP , 加强市场强度；

## Web服务器

服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；

### IIS

微软的； ASP...，Windows中自带的

### Tomcat

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240416212247643-72135155.png" alt="image-20240416212252462" width="300" />

Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，**最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现**，因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。

Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于**轻量级应用服务器**，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个Java初学web的人来说，它是最佳的选择

**Tomcat 实际上运行JSP 页面和Servlet**。Tomcat最新版本为9.0。

下载tomcat

1. 安装 or 解压
2. 了解配置文件及目录结构
3. 这个东西的作用

# Tomcat

## 安装Tomcat

1. tomcat官网：http://tomcat.apache.org/  
2. <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240416212337097-788654361.png" alt="image-20240416212342432" width="500" />
3. 解压

## Tomcat启动和配置

1. 各个文件夹

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240416212414834-2082531365.png" alt="image-20240416212420005" width="400" />

2. 启动、关闭Tomcat

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240416212454477-1711121399.png" alt="image-20240416212459908" width="350" />

3. 访问测试：http://localhost:8080/  

4. 问题

   - Java环境变量没有配置
   
   - 闪退问题：需要配置兼容性
   
   - 乱码问题：配置文件中设置
   
     1. 打开tomcat的/conf/server.xml，给它显示的增加编码方式
   
        ```xml
        <Connector connectionTimeout="20000" 
        		port="8080" protocol="HTTP/1.1" 
        		redirectPort="8443" URIEncoding="UTF-8"/>
        ```
   
     2. 将日志的编码格式也修改一下，打开tomcat的\conf\logging.properties
   
        ```
        如果logging.properties文件中的java.util.logging.ConsoleHandler.encoding属性是UTF-8则修改为GBK, 反之修改为UTF-8
        ```

## 配置

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240416212602196-1809755387.png" alt="image-20240416212607559" width="350" />

1. 可以配置启动的端口号

   - tomcat的默认端口号为：8080
   - mysql：3306 
   - http：80 
   - https：443

   ```xml
   <!--server.xml-->
   <Connector port="8081" protocol="HTTP/1.1"
   connectionTimeout="20000"
   redirectPort="8443" />
   ```
   
2. 可以配置主机的名称

   - 默认的主机名为：localhost->127.0.0.1
   - 默认网站应用存放的位置为：webapps

   ```xml
   <!--访问不到-->
   <Host name="www.qinjiang.com" appBase="webapps"
   unpackWARs="true" autoDeploy="true">
   ```

## 面试题

请你谈谈网站是如何进行访问的！

1. 输入一个域名；回车

2. 检查本机的 C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个`域名映射`

   - 有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问（127.0.0.1  www.qinjiang.com  ）
   - 没有：去DNS服务器找，找到的话就返回，找不到就返回找不到

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240416212858440-1878831563.png" alt="image-20240416212903380" width="400" />

3. 可以配置一下环境变量（可选性）  

DNS域名解析过程

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417155737553-1147480463.png" alt="image-20240417155742363" width="600" />

## 发布一个Web网站

不会就先模仿

1. 将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了

2. 网站应该有的结构

   ```java
   --webapps ：//Tomcat服务器的web目录
       -ROOT
       -SunStudy ：//网站的目录名
           - WEB-INF
               -classes : //java程序
               -lib：//web应用所依赖的jar包
               -web.xml ：//网站配置文件
           - index.html/index.jsp //默认的首页
           - static  //静态资源文件
               -css
               -style.css
               -js
               -img
       -.....
   ```

# Http

## 概述

HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。

- 文本：html，字符串，~ ….
- 超文本：图片，音乐，视频，定位，地图……. 
- 端口：80

Https：安全的

- 端口：443

## 两个时代

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417163704879-554787392.png" alt="image-20240417163709964" width="500" />

1. http1.0

   HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接

2. http2.0

   HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源

## Http请求

客户端---发请求（Request）---服务器  

```js
//General
Request URL:https://www.baidu.com/ 请求地址
Request Method:GET //get方法/post方法
Status Code:200 OK //状态码：200
Remote（远程） Address:14.215.177.39:443

//请求头RequestHeaders
Accept:text/html
Accept-Encoding:gzip, deflate, br
Accept-Language:zh-CN,zh;q=0.9 语言
Cache-Control:max-age=0
Connection:keep-alive
```

### 请求行

```js
Request URL:https://www.baidu.com/	
Request Method:GET	//请求方式
```

1. 请求行中的请求方式：GET
2. 请求方式：**Get，Post**        HEAD,DELETE,PUT,TRACT… 
3. get
   - 请求能够携带的参数比较少，大小有限制
   - 会在浏览器的URL地址栏显示数据内容
   - 不安全，但高效
4. post
   - 请求能够携带的参数没有限制，大小没有限制
   - 不会在浏览器的URL地址栏显示数据内容
   - 安全，但不高效。

### 消息头

```js
Accept：//告诉浏览器，它所支持的数据类型
Accept-Encoding：//支持哪种编码格式 GBK、UTF-8、GB2312、ISO8859-1
Accept-Language：//告诉浏览器，它的语言环境
Cache-Control：//缓存控制
Connection：//告诉浏览器，请求完成是断开还是保持连接
HOST：//主机..../.
```

## Http响应

服务器---响应-----客户端  

```js
Cache-Control:private //缓存控制
Connection:Keep-Alive //连接
Content-Encoding:gzip //编码
Content-Type:text/html //类型
```

### 响应体

```js
Accept：//告诉浏览器，它所支持的数据类型
Accept-Encoding：//支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1
Accept-Language：//告诉浏览器，它的语言环境
Cache-Control：//缓存控制
Connection：//告诉浏览器，请求完成是断开还是保持连接
HOST：//主机..../.
Refresh：//告诉客户端，多久刷新一次；
Location：//让网页重新定位；
```

### 响应状态码

1. 200：请求响应成功

2. 3xx：请求重定向

   304：使用本地缓存

   302重定向：你重新到我给你新位置去； 

3. 4xx：找不到资源 404

   资源不存在；

4. 5xx：服务器代码错误 500 

   502:网关错误

## 面试题

当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？  

# Maven

1. 在Javaweb开发中，需要使用大量的jar包，我们手动去导入；

2. 如何能够让一个东西自动帮我导入和配置这个jar包。

   由此，Maven诞生了！

## Maven-项目架构管理工具

我们目前用来就是方便导入jar包的！ 

Maven的核心思想：**约定大于配置**  

- 有约束，不要去违反。

Maven会规定好你该如何去编写我们的Java代码，必须要按照这个规范来；

## 下载安装Maven

官网：https://maven.apache.org/  

下载完成后，解压即可；  

![image-20240417111238272](https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417111233414-904280622.png)

## 配置环境变量

1. 在我们的系统环境变量中，配置如下配置：

   - M2_HOME  - - - -> maven目录下的bin目录
   - MAVEN_HOME  - - - -> maven的目录
   - 在系统的path中配置   - - - -> %MAVEN_HOME%\bin

2. 测试Maven是否安装成功，保证必须配置完毕！  

   ![image-20240417173200779](https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417173155342-370589667.png)

## 添加阿里云镜像

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417111506568-266514927.png" alt="image-20240417111511928" width="400" />

1. 镜像：mirrors

   作用：加速我们的下载

2. 国内建议使用阿里云的镜像

   ```xml
   <mirror>
       <id>nexus-aliyun</id>
       <mirrorOf>*,!jeecg,!jeecg-snapshots</mirrorOf>
       <name>Nexus aliyun</name>
       <url>http://maven.aliyun.com/nexus/content/groups/public</url>
   </mirror>
   ```

## 建立本地仓库

在本地的仓库，远程仓库；

建立一个本地仓库：localRepository

```xml
<localRepository>D:\Environment\apache-maven-3.9.6\maven-repo</localRepository>
```

## 在IDEA中使用Maven模版

1. 启动IDEA

2. 创建一个MavenWeb项目

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417180752034-1070593799.png" alt="image-20240417180756725" width="580" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417183920794-610648019.png" alt="image-20240417183925251" width="600" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417111816261-807727433.png" alt="image-20240417111821861" width="500" />

3. 等待项目初始化完毕  

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417181148426-1374466631.png" alt="image-20240417181153512" width="580" />

   构建成功

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417185049743-353418810.png" alt="image-20240417185054498" width="580" />

   Webapp模版内容（只有Web应用下才有）

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112003954-477894959.png" alt="image-20240417112009657" width="400" />

4. 观察maven仓库中多了什么东西

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417191757411-1400463392.png" alt="image-20240417191802053" width="500" />

5. IDEA中的Maven设置

   注意：IDEA项目创建成功后，看一眼Maven的配置

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417111918142-1212137820.png" alt="image-20240417111923663" width="550" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417111924205-1650099016.png" alt="image-20240417111929697" width="550" />

6. 到这里，Maven在IDEA中的配置和使用就OK了!  

## 创建一个普通的Maven



<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417192811572-686084451.png" alt="image-20240417192816561" style="zoom:33%;" />

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417193248659-514450918.png" alt="image-20240417193253255" width="680"/>

## 标记文件夹功能

方式一

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112016088-1675156267.png" alt="image-20240417112021674" width="400" />

方式二

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112020775-275592939.png" alt="image-20240417112026384" width="500" />

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112028485-1747668513.png" alt="image-20240417112033841" width="500" />

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112034741-419419676.png" alt="image-20240417112040206" width="500" />

## 在IDEA中配置Tomcat

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112054214-1622406821.png" alt="image-20240417112059836" width="500" />

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112103173-21836599.png" alt="image-20240417112108775" width="500" />

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112109912-407129550.png" alt="image-20240417112115530" width="500" />

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112118732-2104769754.png" alt="image-20240417112124341" width="500" />

解决警告问题

**必须要的配置**：为什么会有这个问题：我们访问一个网站，需要指定一个文件夹名字；（没有工件，尝试刷新一个右侧maven即可）

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112149067-1975853176.png" alt="image-20240417112154637" width="500" />

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112156987-1099126925.png" alt="image-20240417112202542" width="500" />

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112207435-1011485560.png" alt="image-20240417112212973" width="500" />

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112215069-425842617.png" alt="image-20240417112220618" width="500" />

## pom文件  

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112233592-976853325.png" alt="image-20240417112239007" style="zoom:50%;" />

1. 生命周期里面的clean：清除target

2. pom.xml

   ```xml
   <!--pom.xml 是Maven的核心配置文件-->
   <!--1.Maven版本和头文件-->
   <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
   
     <!--2.GAV-->
     <groupId>com.sun</groupId>
     <artifactId>javaweb-01-maven</artifactId>
     <!--3.项目的打包方式
     jar: java应用
     war: JavaWeb应用
     -->
     <packaging>war</packaging>
     <version>1.0-SNAPSHOT</version>
   
     <!--4.名称-->
     <name>javaweb-01-maven Maven Webapp</name>
     <url>http://maven.apache.org</url>
   
     <!--5.配置-->
     <properties>
           <maven.compiler.source>8</maven.compiler.source>
           <maven.compiler.target>8</maven.compiler.target>
           <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
       </properties>
   
     <!--6.项目依赖-->
     <dependencies>
       <!--具体依赖的jar包配置文件-->
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>3.8.1</version>
         <scope>test</scope>
       </dependency>
     </dependencies>
     
     <!--7.项目构建用的东西-->
     <build>
       <finalName>javaweb-01-maven</finalName>
     </build>
   </project>
   ```

3. Maven仓库的使用地址：https://mvnrepository.com/

   最好使用人数多的

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112850482-1718396590.png" alt="image-20240417112856060" width="500" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112900150-1355039921.png" alt="image-20240417112905625" width="500" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112907925-1959229405.png" alt="image-20240417112913532" width="500" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112915934-1190973030.png" alt="image-20240417112921438" width="500" />

4. `Maven：会帮你导入这个jar包所依赖的其他jar`

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112612402-693339947.png" alt="image-20240417112617560" width="500" />

5. maven由于他的**约定大于配置**

   我们之后可以能遇到我们写的**配置文件，无法被导出**或者生效的问题，解决方案：  

```xml
<!--在build中配置resources，来防止我们资源导出失败的问题-->
<build>
    <resources>
        <resource>
            <directory>src/main/resources</directory>
            <includes>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <filtering>true</filtering>
        </resource>
        <resource>
            <!--使得src/main/java可以导出文件**/*.properties和**/*.xml-->
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <!--设置不去过滤-->
            <filtering>true</filtering>
        </resource>
    </resources>
</build>
```

## IDEA操作

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240418150155161-1954357561.png" alt="image-20240418150158690" width="600" />

## 解决问题

1. Tomcat闪退

   配置CATELINA_HOME环境变量和Path

2. IDEA中每次都要重复配置Maven

   在IDEA中的全局默认配置中去配置，**使用管理员方式打开**

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112807480-2102600516.png" alt="image-20240417112813090" width="400" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112812816-160236400.png" alt="image-20240417112818151" width="600" />

3. maven默认web项目中的web.xml版本问题

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417112831244-502330555.png" alt="image-20240417112836771" width="600" />

   替换为webapp4.0版本和tomcat一致

   ```xml
   <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
   http://xmlns.jcp.org/xml/ns/javaee/webapp_4_0.xsd"
       version="4.0"
       metadata-complete="true">
   </web-app>
   ```

# Servlet

## 简介

1. Servlet就是sun公司开发动态web的一门技术

2. Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：

   - 编写一个类，实现Servlet接口
   - 把开发好的Java类部署到web服务器中。

   把实现了Servlet接口的Java程序叫做，Servlet  

## HelloServlet

Serlvet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet1. 

1. 构建一个普通的Maven项目，删掉里面的src目录，这个空的工程就是Maven主工程。以后我们的学习就在这个项目里面建立Moudel模块

2. 关于Maven父子工程的理解：

   - 父项目中会多一个

     ```xml
     <modules>
     	<module>servlet-01</module>
     </modules>
     ```

   - 子项目会有

     ```xml
     <parent>
         <groupId>com.sun</groupId>
         <artifactId>javaweb-02-servlet</artifactId>
         <version>1.0-SNAPSHOT</version>
     </parent>
     ```

   - 父项目中的jar包子项目可以直接使用

     ```java
     son extends father
     ```

3. Maven环境优化

   - 修改web.xml为最新的(可以从Tomcat里的webapp中拿)
   - 将maven的结构搭建完整(src.main.Java目录和resource)

4. 编写一个Servlet程序

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240418174144515-913243671.png" alt="image-20240418174149154" width="500" />

   1. 在src.main.java里编写一个普通类

   2. 实现Servlet接口，这里我们直接继承HttpServlet 

      ```java
      public class HelloServlet extends HttpServlet {
          //由于get和post只是请求实现的不同方式，可以相互调用，业务逻辑都一样
          @Override
          protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
              //ServletInputStream inputStream = req.getInputStream();
              //BufferedReader reader = req.getReader();
              //ServletOutputStream outputStream = resp.getOutputStream();
              //1.响应流
              PrintWriter writer = resp.getWriter();
              
              writer.print("hello,servlet!");
          }
      
          @Override
          protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
              doGet(req, resp);
          }
      }
      ```

5. 在web.xml里编写Servlet的映射

   为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；  

   ```xml
   <!--此处webapp的版本已更新为Tomcat中的-->
   <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
   http://xmlns.jcp.org/xml/ns/javaee/webapp_4_0.xsd"
            version="4.0"
            metadata-complete="true">
       
       <!--  web.xml配置web的核心应用-->
       <!--1.注册Servlet-->
       <servlet>
           <servlet-name>hello</servlet-name>
           <servlet-class>com.sun.servlet.HelloServlet</servlet-class>
       </servlet>
       
       <!--2.一个Servlet对应一个mapping映射-->
       <servlet-mapping>
           <!--名字与Servlet的名字对应-->
           <servlet-name>hello</servlet-name>
           <!--Servlet的请求路径-->
           <url-pattern>/hello</url-pattern>
       </servlet-mapping>
       
   </web-app>
   ```

6. 配置Tomcat

   项目发布的路径：http://localhost:8080/s1

   注意：配置项目发布的路径就可以了（部署的artifat工件里）

7. 启动测试

8. 访问HelloServlet类的路径：http://localhost:8080/s1/hello，OK！

## Servlet原理

Servlet是由Web服务器调用，Web服务器在收到浏览器请求之后，会：  

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240418200937112-413245231.png" alt="image-20240418200942236" width="400" />

## Mapping问题

1. 一个Servlet可以指定一个映射路径（1:1）

   ```xml
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/hello</url-pattern>
   </servlet-mapping>
   ```

2. 一个Servlet可以指定多个映射路径（1：N）

   ```xml
   <servlet-mapping>
   	<servlet-name>hello</servlet-name>
   <url-pattern>/hello</url-pattern>
   </servlet-mapping>
   
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/hello2</url-pattern>
   </servlet-mapping>
   
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/hello3</url-pattern>
   </servlet-mapping>
   ```

3. 一个Servlet可以指定通用映射路径

   ```xml
   <!--通配符，只要是/hello开头就可以-->
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/hello/*</url-pattern>
   </servlet-mapping>
   ```

4. 默认请求路径

   ```xml
   <!--默认请求路径--会覆盖index.jsp-->
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/*</url-pattern>
   </servlet-mapping>
   ```

5. 指定一些后缀或者前缀等等….

   ```xml
   <!--可以自定义后缀实现请求映射	hello/sajdlkajda.qinjiang也可以
   注意点：*前面不能加项目映射的路径
   -->
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>*.qinjiang</url-pattern>
   </servlet-mapping>
   ```

6. 优先级问题

   指定了`固有的映射路径优先级最高`，如果找不到就会走默认的处理请求；

   ```xml
   <!--404-->
   <servlet>
       <servlet-name>error</servlet-name>
       <servlet-class>com.kuang.servlet.ErrorServlet</servlet-class>
   </servlet>
       <servlet-mapping>
       <servlet-name>error</servlet-name>
       <url-pattern>/*</url-pattern>
   </servlet-mapping>
   ```

## ServletContext应用

myServlet.doGet()里

```java
this.getInitParameter()   //初始化参数	返回String
this.getServletConfig()   //Servlet配置	返回ServletConfig
    
this.getServletContext()  //Servlet上下文	返回ServletContext
```

web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用  

### 共享数据

我在这个Servlet中保存的数据，可以在另外一个servlet中拿到；  

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240418205646798-1393167446.png" alt="image-20240418205651900" width="450" /><img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240419161133347-785536427.png" alt="image-20240419161138500" width="450" />

```java
//1.放置数据的类
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//        this.getInitParameter()   //初始化参数
//        this.getServletConfig()   //Servlet配置
        ServletContext sc = this.getServletContext();

        String username="张三";
        //将一个数据保存在ServletContext中
        sc.setAttribute("username",username);

        System.out.println("Hello Servlet");
    }
}

//2.读取数据的类
public class GetServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //获取保存在ServletContext中的一个数据
        ServletContext servletContext = this.getServletContext();
		
        String username =(String) servletContext.getAttribute("username");

        resp.setCharacterEncoding("UTF-8");
        resp.setContentType("text/html");
        PrintWriter writer = resp.getWriter();
        writer.println("username: " + username);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

```xml
<!--3.配置web.xml-->
<servlet>
    <servlet-name>hello</servlet-name>
    <servlet-class>com.sun.servlet.HelloServlet</servlet-class>
    <!--    <init-param>-->
    <!--      <param-name></param-name>-->
    <!--      <param-value></param-value>-->
    <!--    </init-param>-->
</servlet>
<servlet-mapping>
    <servlet-name>hello</servlet-name>
    <url-pattern>/hello</url-pattern>
</servlet-mapping>

<servlet>
    <servlet-name>getc</servlet-name>
    <servlet-class>com.sun.servlet.GetServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>getc</servlet-name>
    <url-pattern>/getc</url-pattern>
</servlet-mapping>
```

### 获取初始化参数

```xml
<!--配置一些web应用初始化参数-->
<context-param>
    <param-name>url</param-name>
    <param-value>jdbc:mysql://localhost:3306/mybatis</param-value>
</context-param>
```

```java
//获取并输出Context初始化参数
public class ServletDemo03 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String url = context.getInitParameter("url");
        resp.getWriter().print(url);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

```xml
<!--配置映射-->
<servlet>
    <servlet-name>gp</servlet-name>
    <servlet-class>com.sun.servlet.ServletDemo03</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>gp</servlet-name>
    <url-pattern>/gp</url-pattern>
</servlet-mapping>
```

### 请求转发

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240419100356949-1811155496.png" alt="image-20240419100402410" width="400" />

```java
public class ServletDemo04 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        System.out.println("进入了ServletDemo04");
        //1.转发的请求路径
        //RequestDispatcher requestDispatcher = context.getRequestDispatcher("/gp");
        //2.调用forward()实现请求转发
        //requestDispatcher.forward(req, resp);
        context.getRequestDispatcher("/gp").forward(req,resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

### 读取资源文件

1. Properties
   - 在java目录下新建properties
   
     需要修改该模块的pom.xml文件，使得properties配置可以导出在classes中(改完多刷新)
   
   - 在resources目录下新建properties
   
2. 发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath

3. 思路：需要一个文件流；

```properties
#aa.properties
username=root
password=root
```

```java
public class ServletDemo05 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //此路径为target下的路径
        InputStream resourceAsStream = this.getServletContext().getResourceAsStream("/WEB-INF/classes/com/sun/servlet/aa.properties");

        Properties prop = new Properties();
        prop.load(resourceAsStream);
        String user = prop.getProperty("username");
        String pwd = prop.getProperty("password");
        resp.getWriter().print(user+":"+pwd);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

## HttpServletResponse

web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；

- 如果要获取客户端请求过来的参数：找HttpServletRequest
- 如果要给客户端响应一些信息：找HttpServletResponse

### 简单分类

1. 负责向浏览器**发送数据**的方法

   ```java
   ServletOutputStream getOutputStream() throws IOException;
   PrintWriter getWriter() throws IOException;
   ```

2. 负责向浏览器**发送响应头**的方法

   ```java
   void setCharacterEncoding(String var1);
   void setContentLength(int var1);
   void setContentLengthLong(long var1);
   void setContentType(String var1);
   void setDateHeader(String var1, long var2);
   void addDateHeader(String var1, long var2);
   void setHeader(String var1, String var2);
   void addHeader(String var1, String var2);
   void setIntHeader(String var1, int var2);
   void addIntHeader(String var1, int var2);
   ```

3. 响应的状态码

   ```java
   int SC_CONTINUE = 100;
   int SC_SWITCHING_PROTOCOLS = 101;
   int SC_OK = 200;
   int SC_CREATED = 201;
   int SC_ACCEPTED = 202;
   int SC_NON_AUTHORITATIVE_INFORMATION = 203;
   int SC_NO_CONTENT = 204;
   int SC_RESET_CONTENT = 205;
   int SC_PARTIAL_CONTENT = 206;
   int SC_MULTIPLE_CHOICES = 300;
   int SC_MOVED_PERMANENTLY = 301;
   int SC_MOVED_TEMPORARILY = 302;
   int SC_FOUND = 302;
   int SC_SEE_OTHER = 303;
   int SC_NOT_MODIFIED = 304;
   int SC_USE_PROXY = 305;
   int SC_TEMPORARY_REDIRECT = 307;
   int SC_BAD_REQUEST = 400;
   int SC_UNAUTHORIZED = 401;
   int SC_PAYMENT_REQUIRED = 402;
   int SC_FORBIDDEN = 403;
   int SC_NOT_FOUND = 404;
   int SC_METHOD_NOT_ALLOWED = 405;
   int SC_NOT_ACCEPTABLE = 406;
   int SC_PROXY_AUTHENTICATION_REQUIRED = 407;
   int SC_REQUEST_TIMEOUT = 408;
   int SC_CONFLICT = 409;
   int SC_GONE = 410;
   int SC_LENGTH_REQUIRED = 411;
   int SC_PRECONDITION_FAILED = 412;
   int SC_REQUEST_ENTITY_TOO_LARGE = 413;
   int SC_REQUEST_URI_TOO_LONG = 414;
   int SC_UNSUPPORTED_MEDIA_TYPE = 415;
   int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
   int SC_EXPECTATION_FAILED = 417;
   int SC_INTERNAL_SERVER_ERROR = 500;
   int SC_NOT_IMPLEMENTED = 501;
   int SC_BAD_GATEWAY = 502;
   int SC_SERVICE_UNAVAILABLE = 503;
   int SC_GATEWAY_TIMEOUT = 504;
   int SC_HTTP_VERSION_NOT_SUPPORTED = 505;
   ```

### 下载文件

1. 向浏览器输出消息 

   ```java
   resp.getWriter().print("123");
   ```

2. 下载文件
   1. 要获取下载文件的路径
   2. 下载的文件名是啥？
   3.  设置想办法让浏览器能够支持下载我们需要的东西
   4.  获取下载文件的输入流
   5.  创建缓冲区
   6. 获取OutputStream对象
   7. 将FileOutputStream流写入到buffer缓冲区
   8.  使用OutputStream将缓冲区中的数据输出到客户端！

```java
public class FileServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    //1. 要获取下载文件的路径
        String realPath = "D:\\JAVA Class\\javaweb-02-servlet\\response\\src\\main\\resources\\图片.jpg";
        System.out.println("下载文件的路径："+realPath);
    //2. 下载的文件名是啥？
        String filename = realPath.substring(realPath.lastIndexOf("\\") + 1);
    //3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西(attachment:附件)
        //中文名URLEncoder.encode()编码，否则有可能乱码
        resp.setHeader("Content-Disposition", "attachment; filename=\"" + URLEncoder.encode(filename,"UTF-8") + "\"");
        
    //4. 获取下载文件的输入流FileInputStream
        FileInputStream fis = new FileInputStream(realPath);
    //5. 创建缓冲区
        int length=0;
        byte[] buffer = new byte[1024];
    //6. 获取OutputStream对象
        ServletOutputStream outputStream = resp.getOutputStream();
    //7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！
        while ((length = fis.read(buffer)) >0) {
            outputStream.write(buffer, 0, length);
        }
    //8. 关闭流
        outputStream.close();
        fis.close();
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

### 验证码功能

验证怎么来的？

- 前端实现（js判断）
- 后端实现，需要用到 Java 的图片类（Image），生产一个图片

```java
public class ImageServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1.让浏览器3s自动刷新一次
        resp.setHeader("refresh", "3");
        //2.在内存中创建一个图片
        BufferedImage bufferedImage = new BufferedImage(800, 600, BufferedImage.TYPE_INT_RGB);
        //3.得到图片
        Graphics2D graphics =(Graphics2D) bufferedImage.getGraphics();
        //4.设置图片背景颜色
        graphics.setColor(Color.pink);
        graphics.fillRect(0, 0, 800, 600);
        //5.给图片写数据
        graphics.setColor(Color.blue);
        graphics.setFont(new Font("Serif", Font.PLAIN, 20));
        graphics.drawString(makeNum(),0,20);
        //6.告诉浏览器这个请求用图片的方式打开
        resp.setContentType("image/jpeg");
        //7.网站存在缓存，不让浏览器缓存
        resp.setHeader("expires", "-1");
        resp.setHeader("Cache-Control","no-cache");
        resp.setHeader("pragma","no-cache");

        //8.把图片写给浏览器
        boolean write = ImageIO.write(bufferedImage,"jpg", resp.getOutputStream());
    }

    //生成随机数
    private String makeNum(){
        Random random = new Random();
        String s = String.valueOf(random.nextInt(99999999));
        //保证输出的是8位数
        StringBuffer stringBuffer = new StringBuffer();
        for (int i = 0; i < 8-s.length(); i++) {
            stringBuffer.append("0");
        }
        String s1 = stringBuffer.toString() + s;
        return s;
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

```

### 实现重定向（重点）

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240419100356949-1811155496.png" alt="image-20240419100402410" width="400" />

一个web资源B收到客户端A请求后，B他会通知A客户端去访问另外一个web资源C，这个过程叫重定向。（URL会改变）

常见场景：  用户登录  

```java
void sendRedirect(String var1) throws IOException;
//测试
public class SendRedirect extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //重定向
        /*
        resp.setHeader("Location","/r/img");
        resp.setStatus(302);	//int SC_MOVED_TEMPORARILY = 302;
        */
        resp.sendRedirect("/r/img");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

### 重定向和转发的区别

面试题：请你聊聊

- 相同点

  页面都会实现跳转

- 不同点

  - 请求转发：url不会产生变化；307
  - 重定向：url地址栏会发生变化；302

### 简单实现登录重定向

```html
<!--index.jsp-->
<html>
<body>

<%--这里提交的路径需要寻找到项目的路径--%>
<%--${pageContext.request.contextPath}代表当前的项目--%>
<form action="${pageContext.request.contextPath}/login" method="get">
    用户名：<input type="text" name="username">
    <br>
    密码：<input type="password" name="password">
    <br>
    <input type="submit">
</form>

</body>
</html>
```

```java
public class Request extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("进入Get请求了");
        //处理请求
        String username = req.getParameter("username");
        String password = req.getParameter("password");

        System.out.println(username+":"+password);
        //重定向注意：路径问题，否则404
        resp.sendRedirect("/r/success.jsp");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

```xml
<!--web.xml-->
<servlet>
    <servlet-name>Request</servlet-name>
    <servlet-class>com.sun.servlet.Request</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>Request</servlet-name>
    <url-pattern>/login</url-pattern>
</servlet-mapping>
```

```jsp
<%--Success.jsp--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
	<h1>Success!</h1>
</body>
</html>
```

## HttpServletRequest

HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，

HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；  

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240419125048886-1464555172.png" alt="image-20240419125054452" width="300" /><img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240419125159276-2105152626.png" alt="image-20240419125204896" width="300" />

### 获取前端传递的参数

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240419125422129-1893629404.png" alt="image-20240419125427773" width="400" />

### 请求转发

```java
public class LoginServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("UTF-8");
        resp.setCharacterEncoding("UTF-8");

        String username = req.getParameter("username");
        String password = req.getParameter("password");
        String[] hobby = req.getParameterValues("hobby");

        System.out.println("==============================");
        //后台接收乱码问题
        System.out.println(username);
        System.out.println(password);
        System.out.println(Arrays.toString(hobby));
        System.out.println("==============================");

        System.out.println(req.getContextPath());   // /r
        //这里的 / 代表当前的Web应用即/r
        //请求转发
        req.getRequestDispatcher("/success.jsp").forward(req,resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

# Cookie、Session

## 会话

1. 会话：用户打开一个浏览器- - - >点击了很多超链接，访问多个web资源- - - >关闭浏览器。这个过程可以称之为会话。
2. 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；
3. 一个网站，怎么证明你来过？
    客户端- -服务端
    1. 服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie
    2. 服务器登记你来过了，下次你来的时候我来匹配你； seesion


## 保存会话的两种技术

常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！  

1. cookie
   客户端技术，保存在客户端 （响应，请求）

   存储有限制，不超过4KB

2. session
   服务器技术，保存在服务器端。

   存储无限制

   利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！

## Cookie

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240419160414047-1642697068.png" alt="image-20240419160418609" width="500" />

```java
//保存用户上一次访问的时间
public class CookieDemo01 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1.解决中文乱码
        req.setCharacterEncoding("UTF-8");
        resp.setContentType("text/html;charset=UTF-8");

        PrintWriter out = resp.getWriter();

        //2.服务器端从客户端获取Cookie   Cookie可能存在多个
        Cookie[] cookies = req.getCookies();
        //3.判断Cookie是否存在
        if(cookies!=null){
            //如果存在遍历取值
            out.write("您上一次访问的时间是：");
            for (int i = 0; i < cookies.length; i++) {
                Cookie cookie = cookies[i];
                //获取Cookie的名字
                if(cookie.getName().equals("lastLoginTime")){
                    //获取Cookie的值
                    Long lastLoginTime = Long.parseLong(cookie.getValue()); //字符串-->时间戳
                    Date date = new Date(lastLoginTime);    //时间戳-->日期类
                    out.write(date.toLocaleString());
                }
            }
        }else{
            out.write("这是您第一次访问本站");
        }
        //4.服务端给客户端响应一个Cookie
        Cookie cookie = new Cookie("lastLoginTime", String.valueOf(System.currentTimeMillis()));

        //设置Cookie有效期为1天
        cookie.setMaxAge(24*60*60);
        resp.addCookie(cookie);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

1. 从请求中拿到cookie信息

2. 服务器响应给客户端cookie

   ```js
   Cookie[] cookies = req.getCookies(); //获得Cookie
   cookie.getName(); //获得cookie中的key
   cookie.getValue(); //获得cookie中的vlaue
   new Cookie("lastLoginTime", System.currentTimeMillis()+""); //新建一个cookie(K-V)
   cookie.setMaxAge(24*60*60); //设置cookie的有效期
   resp.addCookie(cookie); //响应给客户端一个cookie
   ```

3. cookie：一般会保存在本地的 用户目录下 appdata

4. 一个网站cookie是否存在上限！

   - 一个Cookie只能保存一个信息；
   - 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；
   - Cookie大小有限制4kb；
   - 300个cookie浏览器上限

5. 删除Cookie；

   - 不设置有效期，关闭浏览器，自动失效；
   - 设置有效期时间为 0 ；

6. 编码解码

   ```java
   //编码
   Cookie cookie=new Cookie("name",URLEncoder.encode("秦疆","utf-8"))
   //解码
   URLDecoder.decode(cookie.getValue(),"UTF-8")
   ```

## Session（重点）

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240419160733062-72050196.png" alt="image-20240419160738206" width="500" />

1. 什么是Session：

   - 服务器会给每一个用户（浏览器）创建一个Seesion对象；

   - 一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；

   - 用户登录之后，整个网站它都可以访问！

     --> 保存用户的信息；保存购物车的信息…..

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417115352564-1235340116.png" alt="image-20240417115357863" width="250" />

2. Session和cookie的区别：

   - Cookie是：把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）
   - Session：把用户的数据写到用户独占的Session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费）
   - Session对象由服务器创建；

3. 使用场景：

   - 保存一个登录用户的信息；
   - 购物车信息；
   - 在整个网站中经常会使用的数据，我们将它保存在Session中；

4. 使用Session

   ```java
   //给Session存东西
   public class SessionDemo01 extends HttpServlet {
       @Override
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           //1.解决乱码问题
           req.setCharacterEncoding("UTF-8");
           resp.setCharacterEncoding("UTF-8");
           resp.setContentType("text/html;charset=UTF-8");
   
           //2.得到session
           HttpSession session = req.getSession();
   
           //3.给Session存东西
           //session.setAttribute("name","李四");
           session.setAttribute("name",new Person("王五",3));
   
           //4.获取Session的ID
           String sessionid = session.getId();
           //5.判断Session是不是新创建的
           boolean aNew = session.isNew();
           if(aNew){
               resp.getWriter().print("Session创建成功，ID："+sessionid);
           }else{
               resp.getWriter().print("Session已经在服务器中存在了，ID："+sessionid);
           }
       }
   
       @Override
       protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           doGet(req, resp);
       }
   }
   
   //获取Session存的东西
   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       //1.解决乱码问题
       req.setCharacterEncoding("UTF-8");
       resp.setCharacterEncoding("UTF-8");
       resp.setContentType("text/html;charset=UTF-8");
   
       //2.得到session
       HttpSession session = req.getSession();
   
       //String name =(String) session.getAttribute("name");
       Person person = (Person)session.getAttribute("name");
       System.out.println(person.toString());
   }
   
   //手动注销Session
   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       HttpSession session = req.getSession();
       session.removeAttribute("name");
       //手动注销Session
       session.invalidate();
   }
   ```

5. 会话自动过期：web.xml配置  

   ```xml
   <!--设置Session默认的失效时间-->
   <session-config>
       <!--15分钟后Session自动失效，以分钟为单位-->
       <session-timeout>15</session-timeout>
   </session-config>
   ```


# JSP

## 概述

1. Java Server Pages ： Java服务器端页面。和Servlet一样，用于动态Web技术！
2. 最大的特点：
   - 写JSP就像在写HTML
   - 区别：
     - HTML只给用户提供静态的数据
     - JSP页面中可以嵌入JAVA代码，为用户提供动态数据；

## JSP原理

思路：JSP到底怎么执行的！

1. 代码层面没有任何问题

2. 服务器内部工作

   - tomcat中有一个work目录；
   - IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240419185617668-1551966383.png" alt="image-20240419185622920" width="350" />

   电脑的地址：

   ```xml
   C:\Users\32354\AppData\Local\JetBrains\IntelliJIdea2024.1\tomcat\8924e4f3-b562-4c95-a1e2-eae2f4a6ea73\work\Catalina\localhost\ROOT\org\apache\jsp
   ```

   发现页面转变成了Java程序！

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417115750819-701109704.png" alt="image-20240417115756440" style="zoom:50%;" />

`浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！`

JSP最终也会被转换成为一个Java类！

JSP 本质上就是一个Servlet	(extends HttpJspBase- - >extends HttpServlet)

```java
//index_jsp.java
//初始化
public void _jspInit() {}
//销毁
public void _jspDestroy() {}
//JSPService
public void _jspService(.HttpServletRequest request,HttpServletResponse response)
```

1. 判断请求

2. 内置一些对象

   ```java
   final javax.servlet.jsp.PageContext pageContext; //页面上下文
   javax.servlet.http.HttpSession session = null; //session
   final javax.servlet.ServletContext application; //applicationContext
   final javax.servlet.ServletConfig config; //config
   javax.servlet.jsp.JspWriter out = null; //out
   final java.lang.Object page = this; //page：当前
   HttpServletRequest request //请求
   HttpServletResponse response //响应
   ```

3. 输出页面前增加的代码

   ```java
   response.setContentType("text/html");	//设置响应的页面类型
   pageContext = _jspxFactory.getPageContext(this, request, response,null, true, 8192, true);
   _jspx_page_context = pageContext;
   application = pageContext.getServletContext();
   config = pageContext.getServletConfig();
   session = pageContext.getSession();
   out = pageContext.getOut();
   _jspx_out = out;
   ```

4. 以上的这些个对象我们可以在JSP页面中直接使用！

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240419192417007-1738691560.png" alt="image-20240419192421755" width="400" />

5. 在JSP页面中：

   - 只要是 JAVA代码就会原封不动的输出
   - 如果是HTML代码，就会被转换为： 

   ```java
   out.write("<html>\r\n");
   //这样的格式，输出到前端！
   ```

## JSP基础语法

任何语言都有自己的语法，JAVA中有。 

JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可）Java所有语法都支持！  

```jsp
脚本片段：<%	%>
表达式：<%= %>
声明：<%!	%>
注释：<%--注释--%>
```

### JSP表达式

```jsp
<%--JSP表达式
<%= 变量或者表达式%>
作用：用来将程序的输出，输出到客户端
输出结果：Fri Apr 19 19:54:09 CST 2024 
--%>

<%= new java.util.Date()%>
```

### JSP脚本片段

```jsp
<%--JSP脚本片段
    脚本片段的代码，会被原封不动的生成到.jsp.java
    要求：保证Java语法的正确性
--%>
  <%
  	int sum=0;
    for (int i = 0; i <=100; i++) {
      sum+=i;
    }
    out.println("<h1>Sun="+sum+"<h1>");
%>
```

脚本片段的再实现

```jsp
<%
    int x=10;
    out.println(x);
%>
<p>这是一个JSP文档</p>
<%
    int y=20;
    out.println(y);
%>
<hr>
<%--在代码中嵌入HTML元素--%>
<%
	for (int i = 0; i < 5; i++) {
%>
<h1>hello,JSP!   <%= i%></h1>
<%
	}
%>
```

### JSP声明

1. 会被编译到JSP生成Java的类中！
2. 其他的，就会被生成到_jspService方法中！
3. 在JSP，嵌入Java代码即可！ 
4. JSP的注释，不会在客户端显示；HTML就会！

```jsp
<%!
    static {
    System.out.println("Loading Servlet!");
    }
    private int globalVar=0;
    public void sun(){
        System.out.println("进入了方法sun()");
    }
%>  
```

## JSP指令

```java
<%--1.设置页面信息args:contentType、language、import、errorPage--%>
<%@page args.... %>
    <%@ page import="java.util.Date" %>
	<%@ page contentType="text/html;charset=UTF-8" language="java" %>
	<%--定制错误页面--%>
	<%@ page errorPage="error/500.jsp" %>
    <%--直接在web.xml里定制错误页面
        <error-page>
            <error-code>404</error-code>
            <location>/error/404.jsp</location>
        </error-page>
        <error-page>
            <error-code>500</error-code>
            <location>/error/500.jsp</location>
        </error-page>
    --%>
    
	<%--显式的声明这是一个错误页面--%>
	<%@ page isErrorPage="true" %>

<%--提取公共页面--%>
<%@include file=""%>
    
<%--2.@include会将两个页面合二为一--%>
    <%@include file="common/header.jsp"%>
    <h1>网页主体</h1>
    <%@include file="common/footer.jsp"%>
    
<%--3.jSP标签
	jsp:include：拼接页面，本质还是三个（注意：与file不同的是前面多加了/）
--%>
    <jsp:include page="/common/header.jsp"/>
    <h1>网页主体</h1>
    <jsp:include page="/common/footer.jsp"/>
```

## 9大内置对象

```java
final javax.servlet.jsp.PageContext pageContext; //1.页面上下文
HttpServletRequest request //2.请求
HttpServletResponse response //3.响应
javax.servlet.http.HttpSession session = null; //4.session
final javax.servlet.ServletContext application; //5.applicationContext
final javax.servlet.ServletConfig config; //6.config
javax.servlet.jsp.JspWriter out = null; //7.out
final java.lang.Object page = this; //8.page：当前
```

1. **PageContext** 存东西

2. **Request** 存东西

3. Response

4. **Session** 存东西

5. **Application** 【ServletContext】 存东西

6. config 【SerlvetConfig】

7. out

8. page ，不用了解

9. exception


<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240420120650105-1119034042.png" alt="image-20240420120655553" width="500" />

1. page：页面

2. request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！

3. session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；

4. application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据

   ```jsp
   <%--1.存东西--%>
   <%
       pageContext.setAttribute("name1","我是1号");   //保存的数据只在一个页面中有效
       request.setAttribute("name2","我是2号");   //保存的数据只在一次请求中有效，请求转发会携带这个数据
   
       session.setAttribute("name3","我是3号");   //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器
       application.setAttribute("name4","我是4号");   //保存的数据在服务器中有效，从打开服务器到关闭服务器
   %>
   
   <%--2.取东西--%>
   <%
       //从pageContext取出，通过寻找的方式
       //从底层到高层(作用域)
       pageContext.getAttribute("name1");
       String name1 =(String) pageContext.findAttribute("name1");
       String name2 =(String)pageContext.findAttribute("name2");
       String name3 =(String)pageContext.findAttribute("name3");
       String name4 =(String)pageContext.findAttribute("name4");
       String name5 =(String)pageContext.findAttribute("name5");
   %>
   
   <%--3.使用EL表达式输出   ${}等价于<%=%> --%>
   <h1>取出的值为：</h1>
   <h3>${name1}</h3>
   <h3>${name2}</h3>
   <h3>${name3}</h3>
   <h3>${name4}</h3>
   <h3>${name5}</h3>
   
   <h3><%=name5%></h3>     <%--null--%>
   ```

5. 作用域

   ```jsp
   <%--
   scope:作用域
       从底层到高层：page-->request-->session-->application
       public static final int PAGE_SCOPE = 1;
       public static final int REQUEST_SCOPE = 2;
       public static final int SESSION_SCOPE = 3;
       public static final int APPLICATION_SCOPE = 4;
   public void setAttribute(String name, Object attribute, int scope) {
       switch (scope) {
           case 1:
               this.mPage.put(name, attribute);
               break;
           case 2:
               this.mRequest.put(name, attribute);
               break;
           case 3:
               this.mSession.put(name, attribute);
               break;
           case 4:
               this.mApp.put(name, attribute);
               break;
           default:
               throw new IllegalArgumentException("Bad scope " + scope);
       }
   
   }
   --%>
   
   <%
       pageContext.setAttribute("hello1","hello1",pageContext.SESSION_SCOPE);
       //等价于：session.setAttribute("hello1","hello1");
   %>
   ```

6. 转发

   ```jsp
   <%
       pageContext.forward("/index.jsp");
       //等价于 request.getRequestDispatcher("index.jsp").forward(request,response);
   %>
   ```

## JSP标签、JSTL标签、EL表达式

```xml
<dependencies>
        <!--Servlet依赖-->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
        </dependency>
        <!--JSP依赖-->
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>javax.servlet.jsp-api</artifactId>
            <version>2.3.3</version>
        </dependency>
        <!--JSTL表达式的依赖-->
        <dependency>
            <groupId>javax.servlet.jsp.jstl</groupId>
            <artifactId>jstl-api</artifactId>
            <version>1.2</version>
        </dependency>
        <!--standard标签库依赖-->
        <dependency>
            <groupId>taglibs</groupId>
            <artifactId>standard</artifactId>
            <version>1.1.2</version>
        </dependency>
    </dependencies>
```

1. EL表达式： ${ }

   - 获取数据：${name}
   - 执行运算
   - 获取web开发的常用对象：${param.参数名}
   - ~~调用Java方法~~

2. JSP标签

   ```jsp
   <%--1.jsp:include--%>
   <%--jsptag.jsp--%>
   <%--<jsp:include page=""></jsp:include>--%>
   
   <%--
   http://localhost:8080/jsptag.jsp?value1=value1&value2=value2
   --%>
   
   <%--2.jsp:forward--%>
   <jsp:forward page="/jsptag2.jsp">
       <jsp:param name="vlue1" value="value1"/>
       <jsp:param name="vlue2" value="value2"/>
   </jsp:forward>
   
   <%--jsptag2.jsp--%>
   <%--取参数--%>
   值1：<%=request.getParameter("value1")%>
   值2：<%=request.getParameter("value2")%>
   
   <%--3.jsp:useBean--%>
   <%
   //    People people=new People();
   //    people.setAge();
   //    people.setAddress();
   //    people.setId();
   %>
   <%--等价于--%>
   <jsp:useBean id="people" class="com.sun.pojo.People" scope="page"/>
   
   <%--4.jsp:setProperty--%>
   <jsp:setProperty name="people" property="address" value="西安"/>
   <jsp:setProperty name="people" property="age" value="56"/>
   <jsp:setProperty name="people" property="name" value="李四"/>
   
   <%--5.jsp:getProperty--%>
   姓名：<jsp:getProperty name="people" property="name"/>
   年龄：<jsp:getProperty name="people" property="age"/>
   地址：<jsp:getProperty name="people" property="address"/>
   ```

3. JSTL表达式

   JSTL：JSP标准标签库。

   学习地址：https://www.runoob.com/jsp/jsp-jstl.html

   作用：为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！

   - 格式化标签

   - SQL标签

   - XML 标签

   - 核心标签 （掌握部分)

     ```jsp
     <%--引入JSTL核心标签库--%>
     <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
     ```
     
     <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417121257418-378014138.png" alt="image-20240417121302235" style="zoom:50%;" />

4. JSTL标签库使用步骤

   1. 引入对应的 taglib
   2. 使用其中的方法
   3. 在Tomcat 的lib目录也需要引入 jstl的包，否则会报错：JSTL解析错误

   c:if

   ```html
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <%--引入JSTL核心标签库--%>
   <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
   
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
   
   <h1>if测试</h1>
   <hr>
   <form action="coreif.jsp" method="get">
       <%--
       EL表达式获取表单中的数据
       ${param.参数名}
       --%>
       <input type="text" name="username" value="${param.username}">
       <input type="submit" value="登录">
   </form>
   
   <%--判断如果提交的用户是管理员，则登录成功--%>
       
   <%
       if (request.getParameter("username").equals("admin")) {
           out.println("登录成功");
       }
   %>
   
   <c:if test="${param.username=='admin'}" var="isAdmin">
       <c:out value="管理员欢迎你"/>
   </c:if>
   <%--自闭合标签--%>
   <c:out value="${isAdmin}"/>
   
   </body>
   </html>
   ```

   c:choose c:when  

   ```html
   <%--定义一个变量score，值为85--%>
   <c:set var="score" value="85"/>
   <c:choose>
       <c:when test="${score>=90}">
           你的成绩为A
       </c:when>
       <c:when test="${score>=80}">
           你的成绩为B
       </c:when>
       <c:when test="${score>=70}">
           你的成绩为C
       </c:when>
       <c:when test="${score>=60}">
           你的成绩为D
       </c:when>
   </c:choose>
   ```

   c:forEach  

   ```html
   <%--下标需要规范从0开始--%>
   <%
       ArrayList<String> people = new ArrayList<>();
       people.add(0,"张三");
       people.add(1,"李四");
       people.add(2,"王五");
       people.add(3,"赵六");
       people.add(4,"田七");
       request.setAttribute("list",people);
   %>
   <%--
       var：每一次遍历出来的变量
       items：要遍历的对象
       begin: 开始
       end: 结束
       step：步长
   --%>
   <c:forEach var="people" items="${list}">
       <c:out value="${people}"/> <br>
   </c:forEach>
   
   <c:forEach var="people" items="${list}" begin="1" end="3" step="2">
       <c:out value="${people}"/> <br>
   </c:forEach>
   ```

# JavaBean

JavaBean 是特殊的 Java 类（实体类），使用 Java 语言书写，并且遵守 JavaBean API 规范。

接下来给出的是 JavaBean 与其它 Java 类相比而言独一无二的特征：

- 提供一个默认的无参构造函数。
- 需要被序列化并且实现了 Serializable 接口。
- 可能有一系列可读写属性。
- 可能有一系列的 getter 或 **setter** 方法。

1. JavaBean有特定的写法：

   - 必须要有一个无参构造
   - 属性必须私有化
   - 必须有对应的get/set方法；
   - 一般用来和数据库的字段做映射 ORM； 

2. ORM ：对象关系映射

   - 表--->类
   - 字段-->属性
   - 行记录---->对象

   people表  

   | id   | name    | age  | address |
   | ---- | ------- | ---- | ------- |
   | 1    | 我是1号 | 3    | 西安    |
   | 2    | 我是2号 | 18   | 西安    |
   | 3    | 我是3号 | 100  | 西安    |

   ```java
   class People{
       private int id;
       private String name;
       private int id;
       private String address;
   } 
   class A{
       new People(1,"我是1号",3，"西安");
       new People(2,"我是2号",3，"西安");
       new People(3,"我是3号",3，"西安");
   }
   ```

# MVC三层架构

什么是MVC： Model（模型） view（视图） Controller（控制器）

## 早些年

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240422140737553-2019685098.png" alt="image-20240422140745072" width="600" />

**用户直接访问控制层，控制层就可以直接操作数据库**

1. servlet--CRUD-->数据库

   弊端：程序十分臃肿，不利于维护

2. servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码

3. 架构：没有什么是加一层解决不了的！

   程序猿调用-->JDBC--> Mysql、Oracle、SqlServer ....

## MVC三层架构

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240422140647832-1844159708.png" alt="image-20240422140654800" width="700" />

1. Model业务处理 ：
   - 业务逻辑（Service）
   - 数据持久层：CRUD （Dao）
2. View
   - 展示数据
   - 提供链接发起Servlet请求 （a，form，img…）
3. Controller （Servlet）
   - 接收用户的请求 ：（req：请求参数、Session信息….）
   - 交给业务层处理对应的代码
   - 控制视图的跳转

```java
登录--->接收用户的登录请求--->处理用户的请求（获取用户登录的参数，username，password）---->
交给业务层处理登录业务（判断用户名密码是否正确：事务）--->Dao层查询用户名和密码是否正确-->数据库
```

# Filter(重点)

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240423095743892-1169448959.png" alt="image-20240423095751488" width="500" />

Filter：过滤器 ，用来过滤网站的数据；

- 处理中文乱码
- 登录验证….

Filter开发步骤：

1. 添加框架支持（Ctrl+shift+a）

2. 导包

   ```xml
   <dependencies>
           <dependency>
           <!-- servlet -->
               <groupId>javax.servlet</groupId>
               <artifactId>servlet-api</artifactId>
               <version>2.5</version>
           </dependency>
           <dependency>
           <!-- jsp -->
               <groupId>javax.servlet.jsp</groupId>
               <artifactId>javax.servlet.jsp-api</artifactId>
               <version>2.3.3</version>
           </dependency>
           <dependency>
           <!-- jstl -->
               <groupId>javax.servlet.jsp.jstl</groupId>
               <artifactId>jstl-api</artifactId>
               <version>1.2</version>
           </dependency>
           <dependency>
           <!--standard -->
               <groupId>taglibs</groupId>
               <artifactId>standard</artifactId>
               <version>1.1.2</version>
           </dependency>
           <!-- mysql -->
           <dependency>
               <groupId>mysql</groupId>
               <artifactId>mysql-connector-java</artifactId>
               <version>5.1.47</version>
           </dependency>
       </dependencies>
   ```

3. 编写过滤器

   导包不要错!	javax.servlet里的Filter

   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417135611800-1763753739.png" alt="image-20240417135617371" style="zoom:33%;" />

   实现Filter接口，重写对应的方法即可  

   ```java
   public class CharacterEncodingFilter implements Filter {
       //1.初始化：Web服务器启动，就已经开始初始化了，随时等待过滤对象出现
       @Override
       public void init(FilterConfig filterConfig) throws ServletException {
           System.out.println("CharacterEncodingFilter 初始化");
       }
       //2.FilterChain filterChain:链
       /*
           1.过滤器中的所有代码，在过滤特定请求的时候都会执行
           2.必须让过滤器继续通行（转交）
               filterChain.doFilter(servletRequest,servletResponse);
        */
       @Override
       public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
           servletRequest.setCharacterEncoding("UTF-8");
           servletResponse.setCharacterEncoding("UTF-8");
           servletResponse.setContentType("text/html;charset=UTF-8");
   
           System.out.println("CharacterEncodingFilter 执行前---");
           //让我们的请求继续走，如果不写，程序到这里就会被拦截停止
           filterChain.doFilter(servletRequest,servletResponse);
           System.out.println("CharacterEncodingFilter 执行后---");
       }
       //3.销毁：Web服务器关闭的时候，过滤器会销毁
       @Override
       public void destroy() {
           System.out.println("CharacterEncodingFilter 销毁");
       }
   }
   ```

4. 在web.xml中配置 Filter  

   ```xml
   <servlet>
       <servlet-name>ShowServlet</servlet-name>
       <servlet-class>com.sun.servlet.ShowServlet</servlet-class>
   </servlet>
   <servlet-mapping>
       <servlet-name>ShowServlet</servlet-name>
       <url-pattern>/servlet/show</url-pattern>
   </servlet-mapping>
   <servlet-mapping>
       <servlet-name>ShowServlet</servlet-name>
       <url-pattern>/show</url-pattern>
   </servlet-mapping>
   
   <filter>
       <filter-name>CharacterEncodingFilter</filter-name>
       <filter-class>com.sun.filter.CharacterEncodingFilter</filter-class>
   </filter>
   <filter-mapping>
       <filter-name>CharacterEncodingFilter</filter-name>
       <!--只要是/servlet下的任何请求，都会经过这个过滤器-->
       <url-pattern>/servlet/*</url-pattern>
   </filter-mapping>
   ```

# 监听器

实现一个监听器的接口；（有N种）

1. 编写一个监听器：实现监听器的接口…

   ```java
   //统计网站在线人数：统计Session
   public class OnlineCountListener implements HttpSessionListener {
       //创建Session监听：一旦创建session就会触发一次这个事件
       @Override
       public void sessionCreated(HttpSessionEvent httpSessionEvent) {
           ServletContext sct = httpSessionEvent.getSession().getServletContext();
           System.out.println(httpSessionEvent.getSession().getId());
           
           Integer onlineCount =(Integer) sct.getAttribute("OnlineCount");
   
           if (onlineCount == null) {
               onlineCount=new Integer(1);
           }else {
               onlineCount=onlineCount.intValue()+1;
           }
           sct.setAttribute("OnlineCount", onlineCount);
       }
       //销毁Session监听：一旦销毁session就会触发一次这个事件
       @Override
       public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
           ServletContext sct = httpSessionEvent.getSession().getServletContext();
           httpSessionEvent.getSession().invalidate();
   
           Integer onlineCount =(Integer) sct.getAttribute("OnlineCount");
   
           if (onlineCount == null) {
               onlineCount=new Integer(0);
           }else {
               onlineCount=onlineCount.intValue()-1;
           }
           sct.setAttribute("OnlineCount", onlineCount);
   
           /*
           1.手动销毁：httpSessionEvent.getSession().invalidate();
           2.自动销毁：
               <session-config>
                   <session-timeout>1</session-timeout>
               </session-config>
            */
       }
   }
   ```

2. web.xml中注册监听器

   ```xml
   <!--注册监听器-->
   <listener>
       <listener-class>com.sun.listener.OnlineCountListener</listener-class>
   </listener>
   ```

3. index.jsp

   ```jsp
   <body>
     <h1>当前有 
         <span style="color: plum"><%=this.getServletConfig().getServletContext().getAttribute("OnlineCount")%></span> 
         人在线</h1>
   </body>
   ```

# 过滤器、监听器常见应用

### 监听器

GUI编程中经常使用；

```java
public static void main(String[] args) {
        //新建一个窗体
        Frame frame = new Frame("Test Panel");
        //面板
        Panel panel = new Panel();
        frame.setLayout(null);

        //设置窗体的布局
        frame.setLayout(null);
        frame.setBounds(300,300,500,500);
        //设置背景颜色
        frame.setBackground(new Color(166, 166, 166));

        //设置背景颜色
        panel.setBounds(50,50,300,300);
        panel.setBackground(new Color(243, 99, 99));

        frame.add(panel);
        frame.setVisible(true);


        //监听关闭事件
        frame.addWindowListener(new WindowListener() {
            @Override
            public void windowOpened(WindowEvent e) {
                System.out.println("打开");
            }

            @Override
            public void windowClosing(WindowEvent e) {
                System.out.println("关闭中");
                System.exit(0);
            }
            //exit(0)：表示程序正常退出；除了0之外，其他参数均代表程序异常退出
            //exit(1)和exit(-1)是分别返回1和-1到主调程序。exit(0)则是返回0。
            //exit(0)表示程序正常退出，非0表示非正常退出

            @Override
            public void windowClosed(WindowEvent e) {
                System.out.println("已关闭");
            }

            @Override
            public void windowIconified(WindowEvent e) {
                System.out.println("windowIconified");
            }

            @Override
            public void windowDeiconified(WindowEvent e) {
                System.out.println("windowDeiconified");
            }

            @Override
            public void windowActivated(WindowEvent e) {
                System.out.println("激活");
            }

            @Override
            public void windowDeactivated(WindowEvent e) {
                System.out.println("未激活");
            }
        });
    }
```

### 过滤器

用户登录之后才能进入主页！用户注销后就不能进入主页了！

1. 进入登录页面

   ```jsp
   <body>
       <h1>登录</h1>
       <form action="/servlet/login" method="post">
           <input type="text" name="username">
           <input type="submit">
       </form>
   </body>
   ```

2. 用户登录之后，向Sesison中放入用户的数据

   ```java
   //LoginServlet.java
   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       //获取前端请求的参数
       String username = req.getParameter("username");
       if(username.equals("admin")){
           req.getSession().setAttribute(Constant.USER_SESSION,req.getSession().getId());
           resp.sendRedirect("/sys/success.jsp");
       }else{
           resp.sendRedirect("/error.jsp");
       }
   }
   ```

3. 登录成功进入success.jsp

   ```jsp
   <body>
   
       <%--<%--%>
       <%--    Object userSession = request.getSession().getAttribute("USER_SESSION");--%>
       <%--    if(userSession == null) {--%>
       <%--        response.sendRedirect("/login.jsp");--%>
       <%--    }--%>
       <%--%>--%>
       <h1>成功</h1>
       <p><a href="/servlet/logout">注销</a></p>
   
   </body>
   ```

4. 登录失败进入error.jsp

   ```jsp
   <body>
       <h1>错误</h1>
       <h3>有点问题</h3>
       <a href="/login.jsp">返回登录页面</a>
   </body>
   ```

5. 添加权限验证过滤器SysFilter.java

   ```java
   public class SysFilter implements Filter {
       @Override
       public void init(FilterConfig filterConfig) throws ServletException {}
   
       @Override
       public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
   		//进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！
           HttpServletRequest req = (HttpServletRequest) servletRequest;
           HttpServletResponse resp = (HttpServletResponse) servletResponse;
   
           Object userSession = req.getSession().getAttribute(Constant.USER_SESSION);
           if (userSession == null) {
               resp.sendRedirect("/error.jsp");
           }
           filterChain.doFilter(servletRequest, servletResponse);
       }
       
       @Override
       public void destroy() {}
   }
   ```

6. 优化常量：USER_SESSION

   ```java
   public class Constant {
       public final static String USER_SESSION="USER_SESSION";
   }
   ```

7. web.xml配置

   ```xml
   <!--登录-->
   <servlet>
       <servlet-name>LoginServlet</servlet-name>
       <servlet-class>com.sun.servlet.LoginServlet</servlet-class>
   </servlet>
   <servlet-mapping>
       <servlet-name>LoginServlet</servlet-name>
       <url-pattern>/servlet/login</url-pattern>
   </servlet-mapping>
   
   <!--注销-->
   <servlet>
       <servlet-name>LogoutServlet</servlet-name>
       <servlet-class>com.sun.servlet.LogoutServlet</servlet-class>
   </servlet>
   <servlet-mapping>
       <servlet-name>LogoutServlet</servlet-name>
       <url-pattern>/servlet/logout</url-pattern>
   </servlet-mapping>
   
   <!--过滤器SysFilter.java过滤所有/sys目录下的页面-->
   <filter>
       <filter-name>SysFilter</filter-name>
       <filter-class>com.sun.filter.SysFilter</filter-class>
   </filter>
   <filter-mapping>
       <filter-name>SysFilter</filter-name>
       <url-pattern>/sys/*</url-pattern>
   </filter-mapping>
   ```

# JDBC

什么是JDBC ： Java连接数据库

### JDBC 

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417140017271-1721384521.png" alt="image-20240417140022570" width="400" />

需要jar包的支持：

- java.sql
- javax.sqlmysql-conneter-java连接驱动（必须要导入）

实验环境搭建

```mysql
create database JDBC;
use JDBC;
CREATE TABLE users(
    id INT PRIMARY KEY,
    `name` VARCHAR(40),
    `password` VARCHAR(40),
    email VARCHAR(60),
    birthday DATE
);
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(1,'张三','123456','zs@qq.com','2000-01-01');
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(2,'李四','123456','ls@qq.com','2000-01-01');
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(3,'王五','123456','ww@qq.com','2000-01-01');
SELECT * FROM users;
```

导入数据库依赖

```xml
<!--mysql的驱动-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.47</version>
</dependency>
```

IDEA中连接数据库  

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417140146253-1760613434.png" alt="image-20240417140151749" width="500" />

JDBC 固定步骤：

```java
public class TestJdbc {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //配置信息
        String url="jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8";
        String user="root";
        String password="root";

        //1.加载驱动
        Class.forName("com.mysql.jdbc.Driver");

        //2.连接数据库
        Connection connection = DriverManager.getConnection(url, user, password);

        //3.数据库对象
        Statement statement = connection.createStatement();

        //4.sql对象 编写SQL
        String sql = "select * from users";
        //sql1 = "delete from users where id=1";

        //5.执行查询sql
        ResultSet resultSet = statement.executeQuery(sql);
        //int i = statement.executeUpdate(sql1);

        //6.返回结果集
        while (resultSet.next()) {
            System.out.println("id = "+resultSet.getObject("id"));
            System.out.println("name = "+resultSet.getObject("name"));
            System.out.println("password = "+resultSet.getObject("password"));
            System.out.println("email = "+resultSet.getObject("email"));
            System.out.println("birthday = "+resultSet.getObject("birthday"));
        }

        //7.关闭连接，释放资源
        resultSet.close();
        statement.close();
        connection.close();
    }
}
```

预编译SQL

```java
public static void main(String[] args) throws Exception{
        String url="jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8";
        String user="root";
        String password="root";

        //1.加载驱动
        Class.forName("com.mysql.jdbc.Driver");

        //2.连接数据库
        Connection connection = DriverManager.getConnection(url, user, password);

        //4.sql对象 编写SQL
        String sql = "insert into users(id, name, password, email, birthday) VALUES (?,?,?,?,?)";

        //3.预编译数据库对象
        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        preparedStatement.setInt(1,4);
        preparedStatement.setString(2,"admin");
        preparedStatement.setString(3,"admin");
        preparedStatement.setString(4,"admin");
        preparedStatement.setDate(5,new java.sql.Date(new java.util.Date().getTime()));

        //5.执行查询sql
        int i = preparedStatement.executeUpdate();

        //6.返回结果集
        if(i>0){
            System.out.println("插入成功");
        }

        //7.关闭连接，释放资源
        preparedStatement.close();
        connection.close();
    }
```

### 事务

1. 要么都成功，要么都失败！ 

2. ACID原则：保证数据的安全。原子性、一致性、隔离性、持久性

   ```java
   开启事务
   事务提交 commit()
   事务回滚 rollback()
   关闭事务
   转账：
   A:1000
   B:1000
   A(900) --100--> B(1100)
   ```

### Junit单元测试

1. 依赖

   ```xml
   <!--单元测试-->
   <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <version>4.12</version>
   </dependency>
   ```

2. 简单使用

   @Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！

   ```java
   @Test
   public void test(){
   	System.out.println("Hello");
   }
   /*
   	@Retention(RetentionPolicy.RUNTIME)
   	@Target({ElementType.METHOD})
   */
   ```
   
   <img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240417140549658-202459202.png" alt="image-20240417140554937" width="400" /><img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240423155737391-1458850423.png" alt="image-20240423155745098" width="400" />

搭建一个环境

```mysql
CREATE TABLE account(
    id INT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(40),
    money FLOAT
);
INSERT INTO account(`name`,money) VALUES('A',1000);
INSERT INTO account(`name`,money) VALUES('B',1000);
INSERT INTO account(`name`,money) VALUES('C',1000);
```

```java
@Test
public void test(){
    String url="jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8";
    String user="root";
    String password="root";
    Connection connection =null;

    try {
        Class.forName("com.mysql.jdbc.Driver");

        connection = DriverManager.getConnection(url, user, password);

        //1.通知数据库开启事务
        connection.setAutoCommit(false);

        String sql = "update account set money=money-100 where name='A'";
        connection.prepareStatement(sql).executeUpdate();

        //int i=1/0;

        String sql2="update account set money=money+100 where name='B'";
        connection.prepareStatement(sql2).executeUpdate();

        //2.提交事务
        connection.commit();
        System.out.println("提交成功");
    } catch (Exception e) {
        try {
            //3.出现异常，就回滚事务
            connection.rollback();
        } catch (SQLException ex) {
            throw new RuntimeException(ex);
        }
        throw new RuntimeException(e);
    }finally {
        try {
            connection.close();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
```


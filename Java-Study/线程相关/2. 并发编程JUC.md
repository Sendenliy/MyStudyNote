# 什么是JUC

java.util.concurrent 包是在并发编程中使用的工具类，有以下三个包  ：

- java.util .concurrent
- java.util .concurrent.atomic
- java.util .concurrent.locks

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240617111203962-1786309833.png" alt="image-20240617111204466" style="zoom:50%;" />

业务：普通的线程代码 Thread

- Runnable：没有返回值，效率相对于Callable较低

- Callable：属于java.util .concurrent包下的接口

  <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240617111632664-1536128582.png" alt="image-20240617111633548" style="zoom:40%;" />

- Lock：属于java.util .concurrent.locks包下的接口

  <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240617111754398-1094087801.png" alt="image-20240617111755290" style="zoom:33%;" />

# 进程和线程

## 进程、线程

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240617125639819-716846993.png" alt="image-20240617125640442" style="zoom: 33%;" />

进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。

- 它是操作系统动态执行的基本单元
- 在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。
- 进程：就是操作系统中运行的一个程序，QQ.exe, music.exe， word.exe ，这就是多个进程  

线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义，线程可以利用进程所有拥有的资源。

- 在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，

- 由于线程比进程小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度

- 线程：每个进程中都存在一个或者多个线程，比如用word写文章时，就会有一个线程默默帮你定时自动保存  

  - `Java默认有两个线程：main线程、GC线程`

- `Java本身不能开启线程`：

  ```java
  //新建线程并启动
  new Thread().start();
  
  //深入start()方法
  public synchronized void start() {
      if (threadStatus != 0)
          throw new IllegalThreadStateException();
  
      //1.把线程加入线程组
      group.add(this);
  
      boolean started = false;
      try {
          //2.调用本地native方法
          start0();
          //3.设置为真
          started = true;
      } finally {
          try {
              if (!started) {
                  group.threadStartFailed(this);
              }
          } catch (Throwable ignore) {
              /* do nothing. If start0 threw a Throwable then
                    it will be passed up the call stack */
          }
      }
  }
  //本地方法，底层的C++，java无法直接操作硬件
  private native void start0();
  ```

  

## 并发、并行

并发和并行是两个非常容易混淆的概念。它们都可以表示两个或多个任务一起执行，但是偏重点有点不同。

- 并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。并发是逻辑上的同时发生（simultaneous）
- 而并行是物理上的同时发生。然而并行的偏重点在于”同时执行”。

严格意义上来说，并行的多个任务是真实的同时执行，而对于并发来说，这个过程只是交替的，一会运行任务一,一会儿又运行任务二，系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务是串行并发的，也会造成是多个任务并行执行的错觉。

实际上，如果系统内只有一个CPU，而现在而使用多线程或者多线程任务，那么真实环境中这些任务不可能真实并行的，毕竟一个CPU一次只能执行一条指令，这种情况下多线程或者多线程任务就是并发的，而不是并行，操作系统会不停的切换任务。真正的并发也只能够出现在拥有多个CPU的系统中（多核CPU）。

**并发**的动机：

- CPU一核，模拟多条线程，快速`交替执行`。在计算能力恒定的情况下处理更多的任务
- 就像我们的大脑, 计算能力相对恒定, 要在一天中处理更多的问题, 我们就必须具备多任务的能力。现实工作中有很多事情可能会中断你的当前任务, 处理这种多任务的能力就是你的并发能力。
- **并发编程的目标是：充分的利用处理器的每一个核，以达到最高的处理性能。**

**并行**的动机：

- CPU多核，多个现场`同时执行`。用更多的CPU核心更快的完成任务。
- 就像一个团队, 一个脑袋不够用了, 一个团队来一起处理一个任务。

```java
public static void main(String[] args) {
    //获取CPU核数
    System.out.println(Runtime.getRuntime().availableProcessors());
    //8
}
```

## 线程的状态

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240617125813308-499417979.png" alt="image-20240617125814085" style="zoom:53%;" />

```java
//Java的线程有6种状态:
public enum State {
    //线程刚创建	which has not yet started
    NEW,
    
    //在JVM中正在运行的线程
    RUNNABLE,
    
    //阻塞状态；等待监视锁，可以重新进行同步代码块中执行
    BLOCKED,
    
    //等待状态；死等
    WAITING,
    
    //超时等待状态；调用sleep() join() wait()方法可能导致
    TIMED_WAITING,
    
    //终止状态；线程执行完毕，已经退出
    TERMINATED;
}
```

### wait/sleep的区别

**wait()和sleep()方法都是Java中用于线程控制的方法，它们都让线程暂停执行**

1. 来自不同的类

   - **wait来自Object类**。
   - **sleep来自Thread类**。sleep是Thread的静态类方法，谁调用的谁去睡觉。即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。

2. 使用范围不同

   - wait，notify和notifyAll`只能在同步控制方法或者同步控制块`里面使用，
   - 而sleep可以在`任何地方`使用

   ```java
   synchronized(x){
       //或者notify()
       x.wait()
   }
   ```

3. 有没有释放锁(释放资源)

   - **wait()方法会释放锁**，让出CPU资源，并且线程进入等待状态，直到被其他线程唤醒notify。

     使得其他线程可以使用同步控制块或者方法。但不同的是其他在等待池中的线程不被notify不会出来，但这个线程在等待后会自动进入就绪队列等待系统分配资源。

   - **sleep()方法不会释放锁**，线程会一直占用CPU资源，只是暂停执行一段时间，其他线程不能占用cpu。

   - sleep后肯定会运行，但wait的停止运行时间是不确定的。就是说sleep有时间限制的就像闹钟一样到时候就叫了，而wait是无限期的除非用户主动notify。  

4. 唤醒机制不同

   - wait()方法需要被notify()或notifyAll()方法唤醒。
   - sleep()方法会自动苏醒，不需要其他线程唤醒。

5. 用途

   - wait()方法通常用于线程间通信和协作，例如生产者-消费者模型。
   - sleep()方法通常用于让线程暂停执行一段时间，例如模拟延迟操作。

6. 是否需要异常处理

   - wait()方法可能会抛出InterruptedException异常，需要捕获处理。
   - sleep()方法不会抛出异常。

# Lock锁



## synchronized

用法：

1. 同步代码块

   ```java
   class Ticket {
       private int number = 50;
   
       public void sale() {
           synchronized (Ticket.class) {
               if (number > 0) {
               System.out.println(Thread.currentThread().getName() + "卖出了第" + number-- + "张票，剩余：" + number);
           	}
           }
       }
   }
   ```

2. 同步方法

```java
/*
* 题目：三个售票员 卖出 40张票
* 多线程编程的企业级套路：在高内聚低耦合的前提下， 线程 操作(对外暴露的调用方法) 资源类
*/
public class SaleTicketDemo01 {
    public static void main(String[] args) {
        //并发：多个线程操作同一个资源类,把资源丢入线程
        Ticket ticket = new Ticket();

        /**
         * 函数式接口：Runnable
         * @FunctionalInterface
         */
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.sale();
            }
        }, "A").start();
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.sale();
            }
        }, "B").start();
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.sale();
            }
        }, "C").start();
    }
}

/**
 * 降低耦合性
 * 线程就是一个单独的资源类，没有任何附属的操作。包括：
 * 		1.属性
 * 		2.方法
 */
class Ticket {//资源类   OOP
    //属性
    private int number = 50;

    //方法
    //synchronized本质：队列、锁
    public synchronized void sale() {
        if (number > 0) {
            System.out.println(Thread.currentThread().getName() + "卖出了第" + number-- + "张票，剩余：" + number);
        }
    }
}
```

## juc.locks 包下的类

操作Lock 锁 + Lambda 表达式  

Lock接口：

- `Lock`实现提供比使用`synchronized`方法和语句可以获得的更广泛的锁定操作。  它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象`Condition`。

- 随着这种增加的灵活性，额外的责任。  没有块结构化锁定会删除使用synchronized方法和语句发生的锁的自动释放。  当在不同范围内发生锁定和解锁时，必须注意确保在锁定时执行的所有代码由try-finally或try-catch保护，以确保在必要时释放锁定。如下： 

  ```java
  Lock l = ...; 
  //1. 加锁
  l.lock(); 	
  
  try { 
      // access the resource protected by this lock 
  } finally { 
      //2. 解锁
      l.unlock(); 
  }
  
  //Lock实现提供了使用synchronized方法和语句的附加功能，
  	1.通过提供非阻塞尝试来获取锁（ lock.tryLock() ），
      2.尝试获取可被中断的锁（ lock.lockInterruptibly()） ，
      3.以及尝试获取可以超时（ lock.tryLock(long, TimeUnit) ）。 
  ```

Lock接口的实现类：

1. ReentrantIock ：可重入锁

   - 公平锁：先来后到，先来先执行
   - 非公平锁：可以插队【默认】

   ```java
   Lock lock=new ReentrantLock();
   
   public ReentrantLock() {
       sync = new NonfairSync(); //无参构造为：非公平锁
   }
   
   //有参构造：true就是公平锁
   public ReentrantLock(boolean fair) {
       sync = fair ? new FairSync() : new NonfairSync();
   }
   ```

2. ReentrantReadWriteIock.ReadLock ：读锁

3. ReentrantReadWriteLock.WriteLock：写锁

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240617134622205-2143219269.png" alt="image-20240617134622819" style="zoom:50%;" />

使用Lock锁的实现类ReentrantLock()：

```java
public class SaleTicketDemo02 {
    public static void main(String[] args) {
        //并发：多个线程操作同一个资源类,把资源丢入线程
        Ticket2 ticket = new Ticket2();

        new Thread(() -> {
            for (int i = 0; i < 40; i++) ticket.sale();
        }, "A").start();
        new Thread(() -> {
            for (int i = 0; i < 40; i++) ticket.sale();
        }, "B").start();
        new Thread(() -> {
            for (int i = 0; i < 40; i++) ticket.sale();
        }, "C").start();
    }
}

//Lock
class Ticket2 {//资源类   OOP
    //属性、方法
    private int number = 50;

    //1.new ReentrantLock()
    Lock lock = new ReentrantLock();

    public void sale() {
        //2.加锁
        lock.lock();

        try {
            //3.业务代码
            if (number > 0) {
                System.out.println(Thread.currentThread().getName() + "卖出了第" + number-- + "张票，剩余：" + number);
            }
        } catch (Exception e) {

        } finally {
            //4.解锁
            lock.unlock();
        }
    }
}
```

## synchronized 和 lock 区别

|   方面   |                         synchronized                         |                             lock                             |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 存在层次 |                  java内置关键字，在jvm层面                   |                        Lock是个java类                        |
| 锁的状态 |                   无法判断是否获取锁的状态                   |                     可以判断是否获取到锁                     |
| 锁的释放 | 会**自动释放锁**(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁) | 需在finally中**手工释放锁**（unlock()方法释放锁），否则容易造成线程**死锁** |
| 是否死等 | 当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去 | Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； |
|  锁类型  |                   可重入、不可中断、非公平                   |          可重入、可判断中断、可/非公平（两者皆可）           |
| 适用场景 |             synchronized锁适合代码少量的同步问题             |              lock锁适合大量同步的代码的同步问题              |

# 生产者和消费者

## synchroinzed

```java
/**
 * 线程之间的通信问题：生产者和消费者问题
 * A、B操作同一个变量 num=0
 * A：num+1  B：num-1
* *
* 诀窍：
* 1. 高内聚低耦合的前提下，线程操作资源类
* 2. 判断等待、业务、通知
*/

public class A {
    public static void main(String[] args) {
        Data data = new Data();

        //+1
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }, "A").start();
        //-1
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }, "B").start();
    }
}

//判断等待--业务--通知
class Data {//资源类

    private int number = 0;

    //+1
    public synchronized void increment() throws InterruptedException {
        //1.判断
        if (number != 0) {
            //2.等待
            this.wait();
        }
        //3.业务
        number++;
        System.out.println(Thread.currentThread().getName() + ": " + number);
        //4.通知：+1完毕
        this.notifyAll();
    }

    //-1
    public synchronized void decrement() throws InterruptedException {
        //1.判断
        if (number == 0) {
            //2.等待
            this.wait();
        }
        //3.业务
        number--;
        System.out.println(Thread.currentThread().getName() + ": " + number);
        //4.通知：-1完毕
        this.notifyAll();
    }
}
/*	结果：
    A: 1
    B: 0
    A: 1
    B: 0
    ......
*/
```

## 防止虚假唤醒

**虚假唤醒**：线程不满足条件也可以被唤醒，而不会被通知，中断或超时，即所谓的虚假唤醒。虽然这很少发生，但是应用程序必须通过测试，应该使用线程唤醒的条件来防范，并且条件不满足则继续等待。换句话说，等待应该总是出现在循环中。如下：

```java
//防止虚假唤醒
synchronized (obj) {
    while (<condition does not hold>)
        obj.wait(timeout, nanos);
    ... // Perform action appropriate to condition
} 
```

两个进程->四个进程：

- 问题：虚假唤醒
- 解决方法：if换成while
- 原因：
  - if：只判断一次，判断完会接着向下执行if（）外边的。一旦线程被唤醒，并得到锁，就不会再判断if条件，而执行if语句块外的代码
  - while：再一次循环判断刚刚争抢到锁的线程是否满足继续执行下去的条件，条件通过才可以继续执行下去，不通过的线程只能再次进入wait状态，由其他活着的、就绪状态的线程进行争抢锁。

```java
public class B {
    public static void main(String[] args) throws Exception {
        Data data = new Data();
        
        new Thread(() -> {for (int i = 1; i <= 10; i++) {try {data.decrement();} catch (InterruptedException e) {e.printStackTrace();}}
        }, "A").start();
        
        new Thread(() -> {for (int i = 1; i <= 10; i++) {try {data.decrement();} catch (InterruptedException e) {e.printStackTrace();}}
        }, "B").start();
        
        new Thread(() -> {for (int i = 1; i <= 10; i++) {try {data.decrement();} catch (InterruptedException e) {e.printStackTrace();}}
        }, "C").start();
        
        new Thread(() -> {for (int i = 1; i <= 10; i++) {try {data.decrement();} catch (InterruptedException e) {e.printStackTrace();}}
        }, "D").start();
    }
}

class Data { // 资源类
    private int number = 0;

    public synchronized void increment() throws InterruptedException {
        // 判断该不该这个线程做
        while (number != 0) {
            this.wait();
        } 
        // 干活
        number++;
        System.out.println(Thread.currentThread().getName() + "\t" + number);
        // 通知
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        // 判断该不该这个线程做
        while (number == 0) {
            this.wait();
        } 
        // 干活
        number--;
        System.out.println(Thread.currentThread().getName() + "\t" + number);
        // 通知
        this.notifyAll();
    }
}
/*
A: 1
D: 0
C: 1
B: 0
C: 1
B: 0
C: 1
B: 0
C: 1
B: 0

====使用if的情况会产生如下问题：===========
C: 1
B: 0
D: -1
D: -2
D: -3
D: -4
D: -5
D: -6
D: -7
D: -8
D: -9
A: -8
*/
```

## JUC-Condition

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609204716861-1570668064.png" alt="image-20240609204718004" style="zoom:50%;" />

1. **传统**：synchronized、wait、notify

2. **JUC**：lock、await()、signal()

   - await()：导致当前线程等到发信号或 [interrupted] 。将在等待之前将原子释放锁，并在等待返回之前重新获取锁。
   - signal()：唤醒一个等待线程。如果任何线程正在等待此条件，则选择一个线程进行唤醒。  那个线程必须在从await之前重新获取锁。

3. **变化**：

   - `Lock`替换`synchronized`方法和语句的使用，
   - `Condition`取代了对象监视器方法的使用。 

   ```java
   //Condition实现：
   class BoundedBuffer {
       //1.创建锁
       final Lock lock = new ReentrantLock();
       //2.绑定获得Condition实例
       final Condition notFull = lock.newCondition();
       final Condition notEmpty = lock.newCondition();
   
       //3.缓冲区
       final Object[] items = new Object[100];
       int putptr, takeptr, count;
   
       //生产者
       public void put(Object x) throws InterruptedException {
           //1.上锁
           lock.lock();
           try {
               //2.判断等待
               while (count == items.length)
                   notFull.await();
               //3.业务
               items[putptr] = x;
               if (++putptr == items.length) putptr = 0;
               ++count;
               notEmpty.signal();
           } finally {
               //4.解锁
               lock.unlock();
           }
       }
   
       //消费者
       public Object take() throws InterruptedException {
           //1.上锁
           lock.lock();
           try {
               //2.判断等待
               while (count == 0)
                   notEmpty.await();
               //3.业务
               Object x = items[takeptr];
               if (++takeptr == items.length) takeptr = 0;
               --count;
               notFull.signal();
               return x;
           } finally {
               //4.解锁
               lock.unlock();
           }
       }
   }
   ```

修改上述传统代码示例：

```java
/**
 * 题目：现在四个线程，可以操作初始值为0的一个变量
 * 实现两个线程对该变量 + 1，两个线程对该变量 -1
 * 实现交替10次
 * 诀窍：
 * 1. 高内聚低耦合的前提下，线程操作资源类
 * 2. 判断 、干活、通知
 * 3. 多线程交互中，必须要防止多线程的虚假唤醒，也即（判断不能用if，只能用while）
 */

//判断等待--业务--通知
class Data2 {//资源类
    private int number = 0;

    //创建lock锁并绑定Condition实例
    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
	//+1
    public void increment() throws InterruptedException {
        //1.加锁
        lock.lock();
        try {
            //2.业务
            while (number != 0) {
                //等待
                condition.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName() + ": " + number);
            //通知：+1完毕
            condition.signalAll();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            //3.解锁
            lock.unlock();
        }
    }

    //-1
    public void decrement() throws InterruptedException {
        lock.lock();
        try {
            while (number == 0) {
                //等待
                condition.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName() + ": " + number);
            //通知：-1完毕
            condition.signalAll();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }
}
```

## 精确通知唤醒-顺序访问

```java
/**
 * 题目：多线程之间按顺序调用，实现 A->B->C
 * 方法：设置多个Condition监视器
 *
 * 重点：标志位
 */
public class C {
    public static void main(String[] args) {
        Data3 data = new Data3();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                data.printA();
            }
        }, "A").start();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                data.printB();
            }
        }, "B").start();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                data.printC();
            }
        }, "C").start();
    }
}

class Data3 {//资源类
    private Lock lock = new ReentrantLock();
    //设置多个监视器，指定精确的顺序
    private Condition conditionA = lock.newCondition();
    private Condition conditionB = lock.newCondition();
    private Condition conditionC = lock.newCondition();
    private int flag = 1;

    public void printA() {
        lock.lock();

        try {
            while (flag != 1) {
                conditionA.await();
            }
            System.out.println(Thread.currentThread().getName() + "=>AAA");
            flag = 2;
            conditionB.signal();
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }

    public void printB() {
        lock.lock();

        try {
            while (flag != 2) {
                conditionB.await();
            }
            System.out.println(Thread.currentThread().getName() + "=>BBB");
            flag = 3;
            conditionC.signal();
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }

    public void printC() {
        lock.lock();

        try {
            while (flag != 3) {
                conditionC.await();
            }
            System.out.println(Thread.currentThread().getName() + "=>CCC");
            flag = 1;
            conditionA.signal();
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }
}
```

# 8锁-锁的对象

锁的对象：new出来的对象；Class模版

## 8锁现象

1. 标准访问，请问先发短信还是打电话  ：发短信-打电话

   - synchronized修饰的方法，锁的对象是`方法的调用者`。

   - 因为两个方法的调用者是同一个phone，所以两个方法用的是同一个锁，先调用方法的先执行。 


   ```java
/**
* 多线程的8锁
* 1、标准访问，请问先发短信还是打电话？
*/
public class Test1 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(() -> {
            phone.sendMsg();
        }, "A").start();

        try {
            //休眠1秒
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone.call();
        }, "B").start();
    }
}

class Phone {
    public synchronized void sendMsg() {
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }
} 
   ```

2. 发短信方法暂停4秒钟，请问先发短信还是打电话  ：发短信-打电话 

   - 被synchronized修饰的方法，锁的对象是方法的调用者。

   - 因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行

   - 第二个方法只有在第一个方法执行完释放锁之后才能执行。 


   ```java
/**
* 多线程的8锁
* 1、标准访问，请问先发短信还是打电话？
* 2、发短信方法暂停4秒钟，请问先发短信还是打电话？
*/
public class Test1 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(() -> {
            phone.sendMsg();
        }, "A").start();

        try {
            //休眠1秒
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone.call();
        }, "B").start();
    }
}

class Phone {
    public synchronized void sendMsg() {
        try {
            //休眠4秒
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }
}  
   ```

3. 新增一个普通方法hello()没有同步，请问先发短信还是hello()  ：普通方法hello-发短信

   - 新增的方法没有被synchronized修饰，不是同步方法，不受锁的影响，所以不需要等待。

   - 其他线程共用了一把锁，所以还需要等待。


   ```java
import java.util.concurrent.TimeUnit;
/**
* 多线程的8锁
* 1、标准访问，请问先发短信还是打电话？
* 2、发短信方法暂停4秒钟，请问先发短信还是打电话？
* 3、新增一个普通方法hello()没有同步,请问先发短信还是hello？
*/
public class Test1 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(() -> {
            phone.sendMsg();
        }, "A").start();

        try {
            //休眠1秒
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone.hello();
        }, "B").start();
    }
}

class Phone {
    public synchronized void sendMsg() {
        try {
            //休眠4秒
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }

    public void hello() {
        System.out.println("你好啊");
    }
}  
   ```

4. 两部手机、两个同步方法，请问先发短信还是打电话  ：打电话-发短信 

   - 被synchronized修饰的方法，锁的对象是方法的调用者。

   - 两个调用者，两把锁

   - 后调用的方法不需要等待先调用的方法  


   ```java
import java.util.concurrent.TimeUnit;
/**
* 多线程的8锁
* 1、标准访问，请问先发短信还是打电话？
* 2、发短信方法暂停4秒钟，请问先发短信还是打电话？
* 3、新增一个普通方法hello()没有同步,请问先发短信还是hello？
* 4、两部手机、两个同步方法，请问先发短信还是打电话？
*/
public class Test1 {
    public static void main(String[] args) {
        Phone phone1 = new Phone();
        Phone phone2 = new Phone();

        new Thread(() -> {
            phone1.sendMsg();
        }, "A").start();

        try {
            //休眠1秒
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone2.call();
        }, "B").start();
    }
}

class Phone {
    public synchronized void sendMsg() {
        try {
            //休眠4秒
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }

    public void hello() {
        System.out.println("你好啊");
    }
}
   ```

5. 两个静态同步方法，同一部手机，请问先发短信还是打电话  ：发短信-打电话 

   - 被synchronized修饰的方法，锁的对象是类方法的调用者。

   - 被static修饰的方法，类一加载就有了，锁的对象是类的class模板对象。

   - 因为两个同步方法都被static修饰了，所以两个方法用的是同一个锁，后调用的方法需要等待先调用的方法。


   ```java
import java.util.concurrent.TimeUnit;
/**
* 多线程的8锁
* 1、标准访问，请问先发短信还是打电话？
* 2、发短信方法暂停4秒钟，请问先发短信还是打电话？
* 3、新增一个普通方法hello()没有同步,请问先发短信还是hello？
* 4、两部手机、两个同步方法，请问先发短信还是打电话？
* 5、两个静态同步方法，同一部手机，请问先发短信还是打电话？
*/
class Phone3 {//Phone3仅有全局唯一的Class对象
    public static synchronized void sendMsg() {
        try {
            //休眠4秒
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public static synchronized void call() {
        System.out.println("打电话");
    }
}
   ```

6. 两个静态同步方法，2部手机，请问先发短信还是打电话  ：发短信-打电话 

   - 结论：被synchronized和static修饰的方法，锁的对象是类的class对象。

   - 因为两个同步方法都被static修饰了，即便用了两个不同的对象调用方法，两个方法用的还是同一个锁，后调用的方法需要等待先调用的方法。 


   ```java
import java.util.concurrent.TimeUnit;
/**
* 多线程的8锁
* 1、标准访问，请问先发短信还是打电话？
* 2、发短信方法暂停4秒钟，请问先发短信还是打电话？
* 3、新增一个普通方法hello()没有同步,请问先发短信还是hello？
* 4、两部手机、两个同步方法，请问先发短信还是打电话？
* 5、两个静态同步方法，同一部手机，请问先发短信还是打电话？
* 6、两个静态同步方法，2部手机，请问先发短信还是打电话？
*/
public class Test2 {
    public static void main(String[] args) {
        Phone3 phone1 = new Phone3();
        Phone3 phone2 = new Phone3();

        new Thread(() -> {
            phone1.sendMsg();
        }, "A").start();

        try {
            //休眠1秒
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone2.call();
        }, "B").start();
    }
}

class Phone3 {
    public static synchronized void sendMsg() {
        try {
            //休眠4秒
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public static synchronized void call() {
        System.out.println("打电话");
    }
} 
   ```

7. 一个普通同步方法，一个静态同步方法，同一部手机，请问先发短信还是打电话  ：打电话 -发短信

   - 结论：被synchronized和static修饰的方法，锁的对象是类的class对象。

   - 仅仅被synchronized修饰的方法，锁的对象是方法的调用者。

   - 因为两个方法锁的对象不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。  


   ```java
import java.util.concurrent.TimeUnit;
/**
* 多线程的8锁
* 1、标准访问，请问先发短信还是打电话？
* 2、发短信方法暂停4秒钟，请问先发短信还是打电话？
* 3、新增一个普通方法hello()没有同步,请问先发短信还是hello？
* 4、两部手机、两个同步方法，请问先发短信还是打电话？
* 5、两个静态同步方法，同一部手机，请问先发短信还是打电话？
* 6、两个静态同步方法，2部手机，请问先发短信还是打电话？
* 7、一个普通同步方法，一个静态同步方法，同一部手机，请问先发短信还是打电话？
*/
public class Test3 {
    public static void main(String[] args) {
        Phone4 phone = new Phone4();

        new Thread(() -> {
            phone.sendMsg();
        }, "A").start();

        try {
            //休眠1秒
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone.call();
        }, "B").start();
    }
}

class Phone4 {
    public static synchronized void sendMsg() {
        try {
            //休眠4秒
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }
}
   ```

8. 一个普通同步方法，一个静态同步方法，2部手机，请问先发短信还是打电话  ：打电话-发短信

   - 结论：被synchronized和static修饰的方法，锁的对象是类的class对象。
   - 仅仅被synchronized修饰的方法，锁的对象是方法的调用者。即
   - 便是用同一个对象调用两个方法，锁的对象也不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。

   ```java
   /**
   * 多线程的8锁
   * 1、标准访问，请问先发短信还是打电话？
   * 2、发短信方法暂停4秒钟，请问先发短信还是打电话？
   * 3、新增一个普通方法hello()没有同步,请问先发短信还是hello？
   * 4、两部手机、两个同步方法，请问先发短信还是打电话？
   * 5、两个静态同步方法，同一部手机，请问先发短信还是打电话？
   * 6、两个静态同步方法，2部手机，请问先发短信还是打电话？
   * 7、一个普通同步方法，一个静态同步方法，同一部手机，请问先发短信还是打电话？
   * 8、一个普通同步方法，一个静态同步方法，2部手机，请问先发短信还是打电话？
   */
   public class Test3 {
       public static void main(String[] args) {
           Phone4 phone1 = new Phone4();
           Phone4 phone2 = new Phone4();
   
           new Thread(() -> {
               phone1.sendMsg();
           }, "A").start();
   
           try {
               //休眠1秒
               TimeUnit.SECONDS.sleep(1);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
   
           new Thread(() -> {
               phone2.call();
           }, "B").start();
       }
   }
   
   class Phone4 {
       public static synchronized void sendMsg() {
           try {
               //休眠4秒
               TimeUnit.SECONDS.sleep(4);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           System.out.println("发短信");
       }
   
       public synchronized void call() {
           System.out.println("打电话");
       }
   }
   ```


## 小结

1. 锁的对象：
   - new ：this 具体的一个对象
   - static ：Class 唯一的一个模板
2. 一个对象里面如果有多个synchronized方法：
   - 某个时刻内，只要一个线程去调用其中一个synchronized方法了，其他的线程都要等待。换句话说，在某个时刻内，只能有唯一一个线程去访问这些synchronized方法。
   - 锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他的synchronized方法
3. 加个普通方法后：发现和同步锁无关
4. 换成两个对象后：不是同一把锁，情况立刻变化
5. 都换成静态同步方法后：所有的非静态的同步方法用的都是同一把锁，----类对象本身。实例对象本身synchronized实现同步的基础: java中的每一个对象都可以作为锁
6. 同步代码块:
   - 当一个线程试图访问同步代码块时，他首先必须得到锁，退出或者是抛出异常时必须释放锁，
   - 也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可以是别的实例对象的非静态同步方法，因为跟该实例对象的非静态同步方法用的是不同的锁，所以必须等待该实例对象已经获取锁的非静态同步方法释放锁就可以获取他们自己的锁。
   - 这两把锁的是两个不同的对象，所以静态的同步方法与非静态的同步方法之间是不会有竞争条件的，但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要他们用一个的是同一个类的实例对象。
7. 具体的表现为以下三种形式:
   - 对于普通同步方法，锁的是当前实例对象
   - 对于静态同步方法，锁的是当前的Class对象。
   - 对于同步方法块，锁是synchronized括号里面的配置对象

# 集合类不安全

## List不安全

单线程下：

```java
// 单线程十分安全
public class UnSafeList {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("a","b","c");
        list.forEach(System.out::println);
    }
}
```

多线程下线程不安全：

```java
public class ListTest {
    public static void main(String[] args) throws InterruptedException {

        List<String> list = new ArrayList<>();
        for (int i = 1; i <= 100; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
```

多线程下的并发修改错误：Java.util.ConcurrentModificationException

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618103410731-916510082.png" alt="image-20240618103411425" style="zoom:50%;" />

解决方法：

1. 使用synchronized修饰

2. 不使用ArrayList，使用Vector

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618104123682-1254547876.png" alt="image-20240618104124583" style="zoom:50%;" />

3. 使用工具类Collections的方法：synchronizedList

   ```java
   /**
   * 1、 故障现象：ConcurrentModificationException
   * 2、 导致原因：add 方法没有加锁
   * 3、 解决方案：换一个集合类
   * 		1、List<String> list = new Vector<>(); JDK1.0 就存在了！
   * 		2、List<String> list = Collections.synchronizedList(new ArrayList<>());
   * 		3、List<String> list = new CopyOnWriteArrayList<>();
   */
   public class ListTest {
       public static void main(String[] args) throws InterruptedException {
   
           List<String> list = Collections.synchronizedList(new ArrayList<>());
           for (int i = 1; i <= 100; i++) {
               new Thread(() -> {
                   list.add(UUID.randomUUID().toString().substring(0, 5));
                   System.out.println(list);
               }, String.valueOf(i)).start();
           }
       }
   }
   ```

4. 使用JUC包下的类：CopyOnWriteArrayList

   ```java
   public class ListTest {
       public static void main(String[] args) throws InterruptedException {
   
           List<String> list = new CopyOnWriteArrayList<String>();
           for (int i = 1; i <= 100; i++) {
               new Thread(() -> {
                   list.add(UUID.randomUUID().toString().substring(0, 5));
                   System.out.println(list);
               }, String.valueOf(i)).start();
           }
       }
   }
   ```

   探究CopyOnWriteArrayList：

   ```java
   public CopyOnWriteArrayList() {
       setArray(new Object[0]);
   }
   
   final void setArray(Object[] a) {
       array = a;
   }
   
   private transient volatile Object[] array;
   ```

**写入时复制（CopyOnWrite）思想**

写入时复制（CopyOnWrite简称COW）思想是计算机程序设计领域中的一种优化策略。其核心思想是：

- 如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，
- 直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。【避免在写入时覆盖，造成数据问题】
- 这过程对其他的调用者都是透明的（transparently）。
- 此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。

读写分离，写时复制出一个新的数组，完成插入、修改或者移除操作后将新数组赋值给array

**CopyOnWriteArrayList为什么并发安全且性能比Vector好？**

1. Vector：
   - 增删改查方法都加了synchronized，保证同步，
   - 但是每个方法执行的时候都要去获得锁，性能就会大大下降
2. CopyOnWriteArrayList ：
   - 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，
   - CopyOnWriteArrayList支持读多写少的并发情况。

## Set不安全

多线程实例：

```java
/**
* 1 故障现象：ConcurrentModificationException
* 2 导致原因：add 方法没有加锁
* 3 解决方案：换一个集合类
* 	1、Set<String> set = new HashSet<>(); 默认
* 	2、Set<String> set = Collections.synchronizedSet(new HashSet<>());
* 	3、Set<String> set = new CopyOnWriteArraySet();
* 	4 优化建议：（同样的错误，不出现第2次）
* */
public class SetTest {
    public static void main(String[] args) {
        Set<String> set = new HashSet<String>();

        for (int i = 0; i < 85; i++) {
            new Thread(() -> {
                set.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(set);
            }, String.valueOf(i)).start();
        }
    }
}
```

同理可证：多线程下的并发修改错误：Java.util.ConcurrentModificationException

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618111820073-833369766.png" alt="image-20240618111820597" style="zoom:50%;" />

解决方法：

1. 使用集合类Collections的方法：synchronizedSet
2. 使用JUC包下的类：CopyOnWriteArraySet

`hashset底层就是hashMap`：set本质就是map的key，无序且不允许重复

```java
Set<String> set = new HashSet<>();

// 点进去
public HashSet() {
	map = new HashMap<>();
} 

//add方法：就是map的put方法
public boolean add(E e) {
	return map.put(e, PRESENT)==null;
} 

//private static final Object PRESENT = new Object(); 不变得值
```

## Map不安全

hashMap底层是：数组+链表+红黑树  

```java
Map<String,String> map = new HashMap<>();
//等价于：初始化容量，默认加载因子
Map<String,String> map = new HashMap<>(16,0.75);

// 工作中，常常会自己根据业务来写参数，提高效率
```

map多线程不安全测试：

```java
public class MapTest {
    public static void main(String[] args) {
        Map<String, String> map = new HashMap<>();

        for (int i = 1; i <= 80; i++) {
            new Thread(() -> {
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5));
                System.out.println(map);
            }, String.valueOf(i)).start();
        }
    }
}
```

同理可证：多线程下的并发修改错误：Java.util.ConcurrentModificationException

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618111820073-833369766.png" alt="image-20240618111820597" style="zoom:50%;" />

解决方法：

1. 使用Collections工具类的**synchronized** 包装的Map类；
2. 使用JUC包下的类：ConcurrentHashMap

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618113736775-311631793.png" alt="image-20240618113737311" style="zoom:50%;" />

```java
public class UnSafeList {
public static void main(String[] args) {
// Map<String,String> map = new HashMap<>();
Map<String,String> map = new ConcurrentHashMap<>();
for (int i = 1; i <= 30; i++) {
new Thread(()->{
map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().subst
ring(0,8));
System.out.println(map);
},String.valueOf(i)).start();
}
}
}
```

# Callable

Callable与Runnable有什么区别呢？

- Callable有返回值
- Callable可以抛异常
- 方法不一样，Callable是call()，Runnable是run()

## 基础入门

1. Runnable接口实现

   ```java
   public class CallableTest {
       public static void main(String[] args) {
           new Thread(new MyThread()).start();
       }
   }
   class MyThread implements Runnable {
   
       @Override
       public void run() {
           //方法体
       }
   }
   ```

2. Callable接口实现

   ```java
   //函数式接口
   @FunctionalInterface
   public interface Callable<V> {
       //泛型的参数 = 函数的返回值
       V call() throws Exception;
   }
   ```

   Thread构造器不能直接接受Callable：

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618123452674-1512324027.png" alt="image-20240618123453078" style="zoom:50%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618124557479-583762277.png" alt="image-20240618124557839" style="zoom:33%;" />

   使用Runnable接口的实现类FutureTask来实现Callable接口：

   ```java
   public class CallableTest {
       public static void main(String[] args) {
           MyThread myThread = new MyThread();
           FutureTask<String> futureTask = new FutureTask<>(myThread);	// 适配类
           
           new Thread(futureTask, "A").start();	// 调用执行
           String string = futureTask.get();	// 获取Callable返回值
           System.out.println(string);
       }
   }
   class MyThread implements Callable<String> {
       @Override
       public String call() throws Exception {
           System.out.println("call()");
           return "call()";
       }
   }
   ```

## Callable 细节

1. get()方法获取返回值有缓存
2. get()方法可能会产生阻塞：
   - 把该方法放到最后
   - 使用异步通信来处理

- 

```java
public class CallableTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyThread myThread = new MyThread();
        FutureTask<String> futureTask = new FutureTask<>(myThread);
        new Thread(futureTask, "A").start();
        new Thread(futureTask, "B").start();

        String string = futureTask.get();
        System.out.println(string);
    }
}

class MyThread implements Callable<String> {

    @Override
    public String call() throws Exception {
        System.out.println("call()");
        return "call()返回值";
    }
}
/*结果：
call()
call()返回值
*/
```

# JUC常用辅助类

## CountDownLatch

1. 作用：允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。 【加法计数器】

2. CountDownLatch：用给定的**计数**初始化

   - `await`方法阻塞，直到由于`countDown()`方法的调用而导致当前计数达到零，之后所有等待线程被释放，并且任何后续的`await`  调用立即返回。  
   - 这是一个一次性的现象 - 计数无法重置。 如果您需要重置计数的版本，请考虑使用`CyclicBarrier`  。

3. 示例：

   ```java
   //计数
   public class CountDownLatchDemo {
       public static void main(String[] args) throws InterruptedException {
           //1.必须要执行任务的时候，再使用
           CountDownLatch countDownLatch = new CountDownLatch(6);
   
           for (int i = 1; i <= 6; i++) {
               new Thread(() -> {
                   System.out.println(Thread.currentThread().getName() + " GO out");
                   //2.倒计时：-1
                   countDownLatch.countDown();
               }, String.valueOf(i)).start();
           }
           //3.阻塞等待计数器归零，然后再向下执行
           countDownLatch.await();
   
           System.out.println("Close Door");
       }
   }
   /*
   5 GO out
   3 GO out
   6 GO out
   2 GO out
   4 GO out
   1 GO out
   Close Door
   */
   ```

4. 原理：CountDownLatch 主要有两个方法：

   - CountDown()：其他线程调用CountDown方法会将**计数器减1**（调用CountDown方法的线程不会阻塞）
   - await()：当一个或多个线程调用 await 方法时，这些线程会**阻塞等待计数器归零**，然后再向下执行
     - 当计数器变为0时，await 方法阻塞的线程会被唤醒，继续执行

## CyclicBarrier

CyclicBarrier 篱栅

1. 作用：允许一组线程全部等待彼此达到共同屏障点的同步辅助。  【加法计数器】

   - 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 
   - 屏障被称为*循环*  ，因为它可以在等待的线程被释放之后重新使用。 

2. `CyclicBarrier`：

   - 支持一个可选的`Runnable`命令，每个屏障点运行一次。
   - 在派对中的最后一个线程到达之后，但在任何线程释放之前。 在任何一方继续进行之前，此*屏障操作*对更新共享状态很有用。

   ```java
   public CyclicBarrier(int parties, Runnable barrierAction) {
       if (parties <= 0) throw new IllegalArgumentException();
       this.parties = parties;
       this.count = parties;
       this.barrierCommand = barrierAction;
   }
   ```

3. 示例：

   ```java
   public class CycliBarrierDemo {
       public static void main(String[] args) {
   
           CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
               System.out.println("召唤神龙成功！");
           });
           for (int i = 0; i < 7; i++) {
               final int temp = i;
               new Thread(() -> {
                   System.out.println(Thread.currentThread().getName() + "收集" + temp + "个龙珠");
   
                   try {
                       cyclicBarrier.await();  //等待CyclicBarrier达到7
                   } catch (InterruptedException e) {
                       throw new RuntimeException(e);
                   } catch (BrokenBarrierException e) {
                       throw new RuntimeException(e);
                   }
               }).start();
           }
       }
   }
   /*	结果：
   Thread-3收集3个龙珠
   Thread-0收集0个龙珠
   Thread-6收集6个龙珠
   Thread-2收集2个龙珠
   Thread-1收集1个龙珠
   Thread-5收集5个龙珠
   召唤神龙成功！
   =================
   如果改为：new CyclicBarrier(8, () -> {System.out.println("召唤神龙成功！");
   		那么：7个线程执行后就会一直阻塞等待
   */
   ```

## Semaphore

1. Semaphore：一个计数信号量。在概念上，信号量维持一组许可证。

   - 如果有必要，每个`acquire()`都会阻塞，直到许可证可用，然后才能使用它。
   - 每个`release()`添加许可证，潜在地释放阻塞获取方。
   - 但是，没有使用实际的许可证对象；`Semaphore`只保留可用数量的计数，并相应地执行。

2. 作用：信号量通常用于限制线程数，而不是访问某些（物理或逻辑）资源【抢车位】。   

   信号量主要用于两个目的：

   - 多个共享资源的互斥使用，
   - 并发限流，控制最大的线程数

3. 原理：在信号量上我们定义两种操作：

   - acquire（获取）

     - 当一个线程调用 acquire 操作时，他要么通过成功，获取信号量（信号量-1）；
     - 要么一直等下去，直到有线程释放信号量，或超时

   - release （释放）

     实际上会将信号量的值 + 1，然后唤醒等待的线程。

4. 示例：

   ```java
   /**
   * 信号灯
   */
   public class SemaphoreDemo {
       public static void main(String[] args) {
           //线程数量
           Semaphore semaphore = new Semaphore(3);
   
           for (int i = 1; i <= 6; i++) {
               new Thread(() -> {
                   try {
                   	//acquie()得到
                       semaphore.acquire();
                       System.out.println(Thread.currentThread().getName() + "抢到车位");
                       //休眠2秒
                       TimeUnit.SECONDS.sleep(2);
                       System.out.println(Thread.currentThread().getName() + "离开车位");
                   } catch (InterruptedException e) {
                       throw new RuntimeException(e);
                   } finally {
                       //release()释放
                       semaphore.release();
                   }
               }, String.valueOf(i)).start();
           }
       }
   }
   /*结果：
       2抢到车位
       1抢到车位
       3抢到车位
       1离开车位
       2离开车位
       6抢到车位
       5抢到车位
       3离开车位
       4抢到车位
       6离开车位
       5离开车位
       4离开车位
    */
   ```

# 读写锁ReadWriteLock

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618155604756-584528446.png" alt="image-20240618155605467" style="zoom:40%;" />

1. 独占锁（写锁）：指该锁一次只能被一个线程锁持有。对于ReentranrLock和 Synchronized 而言都是独占锁。
2. 共享锁（读锁）：该锁可被多个线程所持有。
3. 对于ReentrantReadWriteLock：
   - 读锁是：共享锁，读锁的共享锁可保证并发读是非常高效的。
   - 写锁是：独占锁，


测试：

1. 普通读写：写入冲突

   ```java
   public class ReadWriteLockDemo {
       public static void main(String[] args) {
           MyCache myCache = new MyCache();
   
           for (int i = 1; i <= 5; i++) {
               final int temp = i;
               new Thread(() -> {
                   myCache.put(temp + "", temp + "");
               }, String.valueOf(i)).start();
           }
       }
   }
   
   class MyCache {
       private volatile Map<String, Object> map = new HashMap<>();
   
       //写
       public void put(String key, Object value) {
           System.out.println(Thread.currentThread().getName() + "写入" + key);
           map.put(key, value);
           System.out.println(Thread.currentThread().getName() + "写入完毕");
       }
   
       //读
       public Object get(String key) {
           System.out.println(Thread.currentThread().getName() + "读取" + key);
           Object o = map.get(key);
           System.out.println(Thread.currentThread().getName() + "读取完毕");
           return o;
       }
   }
   /*结果：
       5写入5
       1写入1
       1写入完毕
       5写入完毕
       3写入3
       4写入4
       4写入完毕
       2写入2
       2写入完毕
       3写入完毕
   */
   ```

2. 使用读写锁：

   ```java
   /**
   * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。
   * 但是，如果有一个线程想去写共享资源，就不应该再有其他线程可以对该资源进行读或写。
   * 1. 读-读 可以共存
   * 2. 读-写 不能共存
   * 3. 写-写 不能共存
   */
   class MyCacheLock {
       private volatile Map<String, Object> map = new HashMap<>();
       //读写锁：更加细粒度的控制
       private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
   
       //写：同时只有一个线程写
       public void put(String key, Object value) {
           //1.加锁
           readWriteLock.writeLock().lock();
           try {
               //2.业务
               System.out.println(Thread.currentThread().getName() + "写入" + key);
               map.put(key, value);
               System.out.println(Thread.currentThread().getName() + "写入完毕");
           } catch (Exception e) {
               throw new RuntimeException(e);
           } finally {
               //3.解锁
               readWriteLock.writeLock().unlock();
           }
       }
   
       //读：所有人都可以读
       public void get(String key) {
           readWriteLock.readLock().lock();
   
           try {
               System.out.println(Thread.currentThread().getName() + "读取" + key);
               Object o = map.get(key);
               System.out.println(Thread.currentThread().getName() + "读取完毕");
           } catch (Exception e) {
               throw new RuntimeException(e);
           } finally {
               readWriteLock.readLock().unlock();
           }
   
       }
   }
   /*结果：
       4写入4
       4写入完毕
       2写入2
       2写入完毕
       5写入5
       5写入完毕
       3写入3
       3写入完毕
       1写入1
       1写入完毕
   */
   ```

# 阻塞队列BlockingQueue

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618162151349-972708087.png" alt="image-20240618162152087" style="zoom:40%;" />

## 阻塞队列简介

1. 阻塞队列是一个队列，在数据结构中起的作用如下图：

   - 阻塞：必须要阻塞、不得不阻塞

     - 当队列是空的，从队列中获取元素的操作将会被阻塞。

       试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素。

     - 当队列是满的，从队列中添加元素的操作将会被阻塞。

       试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增。

   - 队列：先进先出；写入、读取；

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609210914923-180480194.png" alt="image-20240609210916007" style="zoom:50%;" />

2. 阻塞队列的用处：

   在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起。

3. 为什么需要 BlockingQueue？

   - 好处：我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都给你一手包办了。在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。
   - 适用场景：多线程并发处理，线程池！

## 接口架构图

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618171408635-1428875747.png" alt="image-20240618171409345" style="zoom:40%;" />

- ArrayBlockingQueue：由数组结构组成的有界阻塞队列。
- LinkedBlockingQueue：由链表结构组成的有界（默认值为：integer.MAX_VALUE）阻塞队列。
- PriorityBlockingQueue：支持优先级排序的无界阻塞队列
- DelayQueue：使用优先级队列实现的延迟无界阻塞队列。
- SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。
- LinkedTransferQueue：由链表组成的无界阻塞队列。
- LinkedBlockingDeque：由链表组成的双向阻塞队列。

## API 的使用

四组常用API：

1. 抛出异常

   - 当阻塞队列满时．再往队列里add插入元素会抛IlegalStateException:Queue full
   - 当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException

2. 特殊值

   - 插入方法，成功ture失败false
   - 移除方法,成功返回出队列的元素，队列里没有就返回null

3. 一直阻塞

   - 当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出
   - 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用

4. 超时退出

   当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出

| 操作方式     | 抛出异常  | 不会抛出异常，有返回值 | 阻塞，死等 | 超时，退出              |
| ------------ | --------- | ---------------------- | ---------- | ----------------------- |
| 添加         | add(“e”)  | offer(“e”)             | put(“e”)   | offer(timenum.timeUnit) |
| 移除         | remove()  | poll()                 | take()     | poll(timenum,timeUnit)  |
| 判断队首元素 | element() | peek()                 |            |                         |

测试：

1. 抛出异常：

   ```java
   /**
    * 抛出异常
    */
   public static void test1() {
       //队列大小: 3
       ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
   
       //add
       System.out.println(arrayBlockingQueue.add("a"));    //true
       System.out.println(arrayBlockingQueue.add("b"));    //true
       System.out.println(arrayBlockingQueue.add("c"));    //true
   
       System.out.println(arrayBlockingQueue.add("d"));    //.IllegalStateException: Queue full
   
       //element
       System.out.println(arrayBlockingQueue.element());   //a
       
       //remove
       System.out.println(arrayBlockingQueue.remove());    //a
       System.out.println(arrayBlockingQueue.remove());    //b
       System.out.println(arrayBlockingQueue.remove());    //c
       System.out.println(arrayBlockingQueue.remove());    //.NoSuchElementException
   }
   ```

2. 不会抛出异常，有返回值：

   ```java
   /**
    * 不抛出异常，有返回值
    */
   public static void test2() {
       //队列大小
       ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
   
       //offer
       System.out.println(arrayBlockingQueue.offer("a"));    //true
       System.out.println(arrayBlockingQueue.offer("b"));    //true
       System.out.println(arrayBlockingQueue.offer("c"));    //true
   
       System.out.println(arrayBlockingQueue.offer("d"));    //false
   
       //peek
       System.out.println(arrayBlockingQueue.peek());  //a
   
       //poll
       System.out.println(arrayBlockingQueue.poll());    //a
       System.out.println(arrayBlockingQueue.poll());    //b
       System.out.println(arrayBlockingQueue.poll());    //c
   
       System.out.println(arrayBlockingQueue.poll());    //null
   }
   ```

3. 一直阻塞：

   ```java
   /**
    * 一直阻塞：
    */
   public static void test3() throws InterruptedException {
       //队列大小
       ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
   
       //put   无返回值，满了死等
       arrayBlockingQueue.put("a");
       arrayBlockingQueue.put("b");
       arrayBlockingQueue.put("c");
   
       arrayBlockingQueue.put("d");    //死等
   
       //take
       System.out.println(arrayBlockingQueue.take());    //a
       System.out.println(arrayBlockingQueue.take());    //b
       System.out.println(arrayBlockingQueue.take());    //c
   
       System.out.println(arrayBlockingQueue.take());    //死等
   }
   ```

4. 超时退出：

   ```java
   /**
    * 超时退出：
    */
   public static void test4() throws InterruptedException {
       //队列大小
       ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
   
       //offer
       System.out.println(arrayBlockingQueue.offer("a"));    //true
       System.out.println(arrayBlockingQueue.offer("b"));    //true
       System.out.println(arrayBlockingQueue.offer("c"));    //true
   
       System.out.println(arrayBlockingQueue.offer("d", 1, TimeUnit.SECONDS));    //等待超过2s退出,false
   
   
       //poll
       System.out.println(arrayBlockingQueue.poll());    //a
       System.out.println(arrayBlockingQueue.poll());    //b
       System.out.println(arrayBlockingQueue.poll());    //c
   
       System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS));    //等待超过2s退出,null
   }
   ```

## SynchronousQueue同步队列

SynchronousQueue ：

1. 同步队列没有任何内部容量，甚至没有一个容量。与其他的 BlockingQueue 不同，SynchronousQueue是一个不存储元素的 BlockingQueue 。
2. 每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。
3. 为了其他Collection方法（例如contains ）的目的，  SynchronousQueue充当空集合。  此队列不允许`null`元素。 

```java
public static void main(String[] args) {
    BlockingQueue<String> synchronousQueue = new SynchronousQueue<>();  //同步队列

    new Thread(() -> {
        try {
            System.out.println(Thread.currentThread().getName() + " put 1");
            synchronousQueue.put("1");
            System.out.println(Thread.currentThread().getName() + " put 2");
            synchronousQueue.put("2");
            System.out.println(Thread.currentThread().getName() + " put 3");
            synchronousQueue.put("3");
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }, "T1").start();
    new Thread(() -> {
        try {
            TimeUnit.SECONDS.sleep(3);
            System.out.println(Thread.currentThread().getName() + " take " + synchronousQueue.take());
            TimeUnit.SECONDS.sleep(3);
            System.out.println(Thread.currentThread().getName() + " take " + synchronousQueue.take());
            TimeUnit.SECONDS.sleep(3);
            System.out.println(Thread.currentThread().getName() + " take " + synchronousQueue.take());
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }, "T2").start();
}
/*
T1 put 1
T1 put 2
T2 take 1
T1 put 3
T2 take 2
T2 take 3
*/
```

# 线程池

`三大方法、七大参数、四大拒绝策略`

## 池化技术

程序的运行本质是：对系统资源(CPU、内存、磁盘、网络等等)的使用。

- 如何高效的使用这些资源是我们编程优化演进的一个方向。
- 今天说的线程池就是一种对CPU利用的优化手段。

**池化技术**

1. 池化技术简单点来说就是：提前保存大量的资源，以备不时之需，有人用就来拿，用完之后还回去。在机器资源有限的情况下，使用池化技术可以大大的提高资源的利用率，提升性能等。
2. 在编程领域，比较典型的池化技术有：
   - 线程池、
   - 连接池、【JDBC】
   - 内存池、
   - 对象池等。
3. 线程池的实现原理
   - 我们通过创建一个线程对象，并且实现Runnable接口就可以实现一个简单的线程。
   - 可以利用上多核CPU。当一个任务结束，当前线程就接收。但很多时候，我们不止会执行一个任务。如果每次都是如此的创建线程->执行任务->销毁线程，会造成很大的性能开销。
   - 那能否一个线程创建后，执行完一个任务后，又去执行另一个任务，而不是销毁。这就是线程池。
   - 这也就是池化技术的思想，**通过预先创建好多个线程，放在池中，这样可以在需要使用线程的时候直接获取，避免多次重复创建、销毁带来的开销**。

## 为什么使用线程池

- 单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。
- 多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。

1. 线程池做的工作主要是：
   - 控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，
   - 如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。
2. 线程池的主要优点为：

   - 第一：【线程复用】降低资源消耗，通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。
   - 第二：【控制最大并发数】提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。
   - 第三：【管理线程】提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。

## 线程池的三大方法

Java中的线程池是通过Executor 框架实现的：

1. 该框架中用到了Executor ，Executors【工具类】，ExecutorService，ThreadPoolExecutor 这几个类。
2. 【阿里规约：线程池不允许使用Excutors去创建，而是通过ThreadPoolExcutor的方式，规避资源耗尽的风险】
3. Excutors弊端：
   - FixedThreadPool和SingleThreadExecutor:
     主要问题是：允许的请求队列长度最大数是Integer.MAX_VALUE(约为21亿)，可能会堆积的大量请求处理队列，甚至OOM。
   - CachedThreadPool和ScheduledThreadPool:
     主要问题是：允许的创建线程最大数是Integer.MAX_VALUE(约为21亿)，可能会创建数量非常多的线程，甚至OOM。

Executors【工具类】三大方法说明：

```java
//1.单个线程
Executors.newSingleThreadExecutor();   
//2.创建一个固定大小的线程池
Executors.newFixedThreadPool(5);    
//3.可伸缩的线程池
Executors.newCachedThreadPool();    
```

1. Executors.newSingleThreadExecutor()

  **只有一个线程**

  ```java
public static void main(String[] args) {
    ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程

    try {
        for (int i = 0; i < 10; i++) {
            //new Thread().start();
            threadPool.execute(() -> {
                System.out.println(Thread.currentThread().getName() + ": OK");
            });
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        //程序结束，需要关闭线程池
        threadPool.shutdown();
    }
}
/*结果：单个线程
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
*/
  ```

2. Executors.newFixedThreadPool(int)

  执行长期任务性能好，创建一个线程池，**一池有N个固定的线程**，有固定线程数的线程。

  ```java
public static void main(String[] args) {
    ExecutorService threadPool = Executors.newFixedThreadPool(5);//创建一个固定大小的线程池

    try {
        for (int i = 0; i < 10; i++) {
            //new Thread().start();
            threadPool.execute(() -> {
                System.out.println(Thread.currentThread().getName() + ": OK");
            });
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        //程序结束，需要关闭线程池
        threadPool.shutdown();
    }
}
/*结果：固定5个线程
pool-1-thread-1: OK
pool-1-thread-4: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-1: OK
pool-1-thread-2: OK
pool-1-thread-3: OK
pool-1-thread-5: OK
pool-1-thread-4: OK
*/
  ```

3. Executors.newCachedThreadPool()

  执行很多短期异步任务，**线程池根据需要创建新线程**，但在先构建的线程可用时将重用他们。可扩容，遇强则强

  ```java
public static void main(String[] args) {
    ExecutorService threadPool = Executors.newCachedThreadPool();//可伸缩的线程池

    try {
        for (int i = 0; i < 10; i++) {
            //new Thread().start();
            threadPool.execute(() -> {
                System.out.println(Thread.currentThread().getName() + ": OK");
            });
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        //程序结束，需要关闭线程池
        threadPool.shutdown();
    }
}
/*结果：10个线程
pool-1-thread-5: OK
pool-1-thread-6: OK
pool-1-thread-8: OK
pool-1-thread-1: OK
pool-1-thread-7: OK
pool-1-thread-4: OK
pool-1-thread-9: OK
pool-1-thread-3: OK
pool-1-thread-10: OK
pool-1-thread-2: OK
*/
  ```

## ThreadPoolExecutor七大参数

操作：查看三大方法的底层源码

- 发现本质都是调用了 new ThreadPoolExecutor ( 7 大参数 )

```java
//1.Executors.newSingleThreadExecutor()
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        //核心线程数和最大线程数为：1
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
//2.Executors.newFixedThreadPool(5)
public static ExecutorService newFixedThreadPool(int nThreads) {
    //核心线程数和最大线程数为：传进来的进程数
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
//3.Executors.newCachedThreadPool()
public static ExecutorService newCachedThreadPool() {
    //核心线程数：默认为0	最大线程数为：Integer.MAX_VALUE~21亿
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}

//本质：ThreadPoolExecutor
public ThreadPoolExecutor(int corePoolSize,	//核心线程池大小
                          int maximumPoolSize,	//最大核心线程池大小
                          long keepAliveTime,	//超时了 没有人调用就会释放
                          TimeUnit unit,	//超时单位
                          BlockingQueue<Runnable> workQueue,	//阻塞队列
                          ThreadFactory threadFactory,	//线程工厂，创建线程，一般不用动
                          RejectedExecutionHandler handler	//拒绝策略
                         ) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

参数理解：

1. corePollSize ：核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。

2. maximumPoolSize ：最大线程数。表明线程中最多能够创建的线程数量，此值必须大于等于1。

3. keepAliveTime ：空闲的线程保留的时间。

4. TimeUnit ：空闲线程的保留时间单位。

   ```java
   TimeUnit.DAYS; //天
   TimeUnit.HOURS; //小时
   TimeUnit.MINUTES; //分钟
   TimeUnit.SECONDS; //秒
   TimeUnit.MILLISECONDS; //毫秒
   TimeUnit.MICROSECONDS; //微妙
   TimeUnit.NANOSECONDS; //纳秒
   ```

5. BlockingQueue< Runnable> ：阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue可选。

6. ThreadFactory ：线程工厂，用来创建线程，一般默认即可

7. RejectedExecutionHandler ：队列已满，而且任务量大于最大线程的异常处理策略。有以下四种拒绝策略：  

```java
//1.丢弃任务；并抛出RejectedExecutionException异常。
ThreadPoolExecutor.AbortPolicy
//2.也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardPolicy
//3.丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.DiscardOldestPolicy
//4.由调用线程处理该任务
ThreadPoolExecutor.CallerRunsPolicy
```

## ThreadPoolExecutor工作原理

1. 判断流程：

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618213722661-1193764433.png" alt="image-20240618213721921" style="zoom:50%;" />

2. 实例：8个人进银行办理业务

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618213550594-517141415.png" alt="image-20240618213549711" style="zoom:50%;" />

   1. 1-2人：被受理（核心大小core）
   2. 3-5人：进入队列（Queue）
   3. 6~8人：到最大线程池（扩容大小max = 阻塞队列+核心线程）
   4. 再有人进来：就要被拒绝策略接受了

3. 执行过程：

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618214005995-61079208.png" alt="image-20240618214004972" style="zoom:50%;" />

   1. 在创建了线程池后，开始等待请求。
   2. 当调用execute()方法添加一个请求任务时，线程池会做出如下判断：
      1.  如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务：
      2.  如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列：
      3.  如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务
      4.  如果队列满了且正在运行的线程数量大于或等于1Size，那么线程池会启动饱和拒绝策略来执行。
   3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。
   4. 当一个线程无事可做超过一定的时间(keepA1iveTime)时，线程会判断：
      - 如果当前运行的线程数大于coreP佣1Size，那么这个线程就被停掉。
      - 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小

## 自定义线程池

问题：线程池用哪个？生产中如何设置合理参数？在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多? 

答案是：一个都不用，我们工作中只能使用自定义的；

1. 自定义线程池：

   ```java
   ExecutorService threadPool = new ThreadPoolExecutor(2,
           5,
           3,
           TimeUnit.SECONDS,
           new LinkedBlockingQueue<>(3),
           Executors.defaultThreadFactory(),
           new ThreadPoolExecutor.AbortPolicy());
   ```

2. 使用自定义的线程池执行：

   ```java
   //此时的线程池配置：核心2个，最大5个，阻塞队列3个
   try {
       for (int i = 1; i <= 5; i++) {
           //new Thread().start();
           threadPool.execute(() -> {
               System.out.println(Thread.currentThread().getName() + ": OK");
           });
       }
   } catch (Exception e) {
       throw new RuntimeException(e);
   } finally {
       //程序结束，需要关闭线程池
       threadPool.shutdown();
   }
   /*
   当1个人进入时：只使用了核心进程
   	pool-1-thread-1: OK
   当5个人进入时：只使用了核心进程
   	pool-1-thread-2: OK
       pool-1-thread-1: OK
       pool-1-thread-2: OK
       pool-1-thread-1: OK
       pool-1-thread-2: OK
   当6个人进入时：触发了一个最大线程
       pool-1-thread-2: OK
       pool-1-thread-3: OK
       pool-1-thread-1: OK
       pool-1-thread-3: OK
       pool-1-thread-2: OK
       pool-1-thread-1: OK
   当8个人进入时：达到了最大线程数5
       pool-1-thread-3: OK
       pool-1-thread-1: OK
       pool-1-thread-2: OK
       pool-1-thread-4: OK
       pool-1-thread-4: OK
       pool-1-thread-5: OK
       pool-1-thread-2: OK
       pool-1-thread-3: OK
   当9个人进入时：超过最大承载
   	抛出异常-java.util.concurrent.RejectedExecutionException
   */
   ```

3. 线程池的拒绝策略：

   ```java
   RejectedExecutionHandler rejected = null;
   //1.默认，队列满了丢任务，抛出异常-java.util.concurrent.RejectedExecutionException
   rejected = new ThreadPoolExecutor.AbortPolicy();
   
   //2.队列满了丢任务，不抛出异常【如果允许任务丢失这是最好的】
   rejected = new ThreadPoolExecutor.DiscardPolicy();
   
   //3.将最早进入队列的任务删，之后再尝试加入队列，不会抛出异常。
   rejected = new ThreadPoolExecutor.DiscardOldestPolicy();
   
   //4.如果添加到线程池失败，那么主线程会自己去执行该任务，回退。哪来的回哪去
   rejected = new ThreadPoolExecutor.CallerRunsPolicy();
   /*
       pool-1-thread-3: OK
       pool-1-thread-2: OK
       main: OK
       pool-1-thread-4: OK
       pool-1-thread-1: OK
       pool-1-thread-5: OK
       pool-1-thread-4: OK
       pool-1-thread-3: OK
       pool-1-thread-2: OK
   */
   ```


## 设置池的最大线程数

池的最大线程数应该如何定义？

1. CPU密集型：线程数等于`CPU数`是最好的。

   ```java
   //获取CPU核数
   Runtime.getRuntime().availableProcessors()；
   ```

   - 一个计算为主的程序（专业一点称为CPU密集型程序）。
   - 多线程跑的时候，可以充分利用起所有的cpu核心，比如说4个核心的cpu,开4个线程的时候，可以同时跑4个线程的运算任务，此时是最大效率。
   - 但是如果线程远远超出cpu核心数量 反而会使得任务效率下降，因为频繁的切换线程也是要消耗时间的。

2. IO密集型：线程数大于`IO任务数`是最佳的。

   - 如果是一个磁盘或网络为主的程序（IO密集型）。
   - 一个线程处在IO等待的时候，另一个线程还可以在CPU里面跑，有时候CPU闲着没事干，所有的线程都在等着IO，这时候他们就是同时的了，而单线程的话此时还是在一个一个等待的。我们都知道IO的速度比起CPU来是慢到令人发指的。
   - 所以开多线程，比方说多线程网络传输，多线程往不同的目录写文件，等等。

# 四大函数式接口

函数式接口、链式编程、流式计算、lambda表达式

## 简介

### 函数式接口

1. 函数式接口：只有一个方法的接口

   ```java
   //函数式接口：只有一个方法的接口
   @FunctionalInterface
   public interface Runnable {
       public abstract void run();
   }
   ```

2. 作用：简化编程模型，在框架底层大量应用

3. 例子：foreach(消费型的函数式接口)

   ```java
   default void forEach(Consumer<? super T> action) {
       Objects.requireNonNull(action);
       for (T t : this) {
           action.accept(t);
       }
   }
   ```

### java.util.function

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240618221737307-779918233.png" alt="image-20240618221736453" style="zoom:30%;" />

|        函数式接口        | 参数类型 | 返回类型 | 用途                                                         |
| :----------------------: | :------: | :------: | ------------------------------------------------------------ |
| Function<T，R>函数型接口 |    T     |    R     | 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法:R apply(T t); |
|  Predicate<T>断定型接口  |    T     | boolean  | 确定类型为T的对象是否满足某约束，并返回boolean值。包含方法boolean test(T t); |
|  Consumer<T>消费型接口   |    T     |   void   | 对类型为T的对象应用操作，包含方法:void accept(T t)           |
|  Supplier<T>供给型接口   |    无    |    T     | 返回类型为T的对象，包含方法：T get()                         |

## Function函数型接口

1. 特点：

   1. 有一个输入参数，有一个输出参数
   2. 只要是Function函数型接口，都可以用Lambda表达式简化

2. 源码：

   ```java
   @FunctionalInterface
   public interface Function<T, R> {//1个方法，2个默认方法，1个静态方法
       /**
        * 传入参数：T
        * 返回参数：R
        */
       R apply(T t);
   
       default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
           Objects.requireNonNull(before);
           return (V v) -> apply(before.apply(v));
       }
   
       default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
           Objects.requireNonNull(after);
           return (T t) -> after.apply(apply(t));
       }
   
       static <T> Function<T, T> identity() {
           return t -> t;
       }
   }
   ```

3. 举例：

   ```java
   /**
    * 函数型接口：
    */
   public class Demo01 {
       public static void main(String[] args) {
           //该匿名内部类功能：输出输入的值
           Function function = new Function<Integer, String>() {
               @Override
               public String apply(Integer number) {
                   return String.valueOf(number);
               }
           };
           //调用该匿名内部类
           System.out.println(function.apply(5));  //5
       }
   }
   //=======使用Lambda表达式简化==========
   Function<Integer,String> function=(number)->{
       return String.valueOf(number);
   };
   ```

## Predicate断定型接口

1. 特点：

   - 有一个输入参数，返回只有布尔值。
   - 都可以用Lambda表达式简化

2. 源码：

   ```java
   @FunctionalInterface
   public interface Predicate<T> {//1个方法，3个默认方法，2个静态方法
       /**
        * 只有一个输入参数：T
        * 返回：boolean值
        */
       boolean test(T t);
   
       default Predicate<T> and(Predicate<? super T> other) {
           Objects.requireNonNull(other);
           return (t) -> test(t) && other.test(t);
       }
   
       default Predicate<T> negate() {
           return (t) -> !test(t);
       }
   
       default Predicate<T> or(Predicate<? super T> other) {
           Objects.requireNonNull(other);
           return (t) -> test(t) || other.test(t);
       }
   
       static <T> Predicate<T> isEqual(Object targetRef) {
           return (null == targetRef)
                   ? Objects::isNull
                   : object -> targetRef.equals(object);
       }
   
       @SuppressWarnings("unchecked")
       static <T> Predicate<T> not(Predicate<? super T> target) {
           Objects.requireNonNull(target);
           return (Predicate<T>)target.negate();
       }
   }
   ```

3. 实例：

   ```java
   public static void main(String[] args) {
       //该匿名内部类功能：判断字符串是否为空
       Predicate<String> predicate = new Predicate<>() {
           @Override
           public boolean test(String s) {
               return s.isEmpty();
           }
       };
       //调用该匿名内部类
       System.out.println(predicate.test("abc"));  //false
   }
   //=======使用Lambda表达式简化==========
   Predicate<String> predicate =(str)->{
       return str.isEmpty();
   };
   ```

## Consumer消费型接口

1. 特点：

   - 有一个输入参数，没有返回值

2. 源码：

   ```java
   @FunctionalInterface
   public interface Consumer<T> {
   
       /**
        * 只有一个输入参数：T
        * 没有返回值
        */
       void accept(T t);
   
       
       default Consumer<T> andThen(Consumer<? super T> after) {
           Objects.requireNonNull(after);
           return (T t) -> { accept(t); after.accept(t); };
       }
   }
   ```

3. 实例：

   ```java
   public static void main(String[] args) {
       //该匿名内部类功能：打印字符串
       Consumer<String> objectConsumer = new Consumer<>() {
           @Override
           public void accept(String str) {
               System.out.println(str);
           }
       };
       
       //调用该匿名内部类
       objectConsumer.accept("Hello");
   }
   //=======使用Lambda表达式简化==========
       Consumer<String> consumer =(str)->{
           System.out.println(str);
       };
   ```

## Supplier供给型接口

1. 特点：

   - 没有输入参数，只有返回参数

2. 源码：

   ```java
   @FunctionalInterface
   public interface Supplier<T> {
   
       /**
        * 只有一个返回参数：T
        * 没有输入参数
        */
       T get();
   }
   ```

3. 实例：

   ```java
   public static void main(String[] args) {
       //该匿名内部类功能：判断字符串是否为空
       Supplier<Integer> supplier = new Supplier<>() {
           @Override
           public Integer get() {
               System.out.println("get()");
               return 1024;
           }
       };
   
       //调用该匿名内部类
       System.out.println(supplier.get());
       //get()
       //1024
   }
   //=======使用Lambda表达式简化==========
       Supplier<Integer> supplier = () -> {
           return 1024;
       };
   ```

# Stream流式计算

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609212432780-1379417000.png" alt="image-20240609212433471" style="zoom:50%;" />

## 流（Stream）是什么

流：是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。

“集合讲的是数据存储，流讲的是计算！”

特点：

- Stream 自己不会存储元素。

- Stream 不会改变源对象，相反，他们会返回一个持有结果的新Stream。

- Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。

  <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240619093542213-592686475.png" alt="image-20240619093541815" style="zoom: 67%;" />

## 代码验证

User实体类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private int id;
    private String userName;
    private int age;

    //get、set、有参/无参构造器、toString
}
```

Stream算法题  

```java
/**
 * 题目：请按照给出数据，找出同时满足以下条件的用户
 * 也即以下条件：
 * 1、全部满足偶数ID
 * 2、年龄大于24
 * 3、用户名转为大写
 * 4、用户名字母倒排序
 * 5、只输出一个用户名字 limit
 **/
public class Test {
    public static void main(String[] args) {
        User u1 = new User(11, "a", 23);
        User u2 = new User(12, "b", 24);
        User u3 = new User(13, "c", 22);
        User u4 = new User(14, "d", 28);
        User u5 = new User(16, "e", 26);

        List<User> list = Arrays.asList(u1, u2, u3, u4, u5);

        /**
         * 1. 首先我们需要将 list 转化为stream流
         * 2. 然后将用户过滤出来，这里用到一个函数式接口Predicate<? super T>，我们可以使用lambda表达式简化
         * 3. 这里面传递的参数，就是Stream流的泛型类型，也就是User，所以，这里可以直接返回用户id为偶数的用户信息;
         * 4. 通过forEach进行遍历，直接简化输出 System.out::println ，等价于System.out.println(u);
         **/
        list.stream()
                .filter(u -> {
                    return u.getId() % 2 == 0;
                })
                .filter(u -> {
                    return u.getAge() > 24;
                })
                .map(u -> {
                    return u.getUserName().toUpperCase();
                })
                .sorted((uu1, uu2) -> { //默认正排序 自己用 compareTo 比较
                    return uu2.compareTo(uu1);
                })
                .limit(1)
                .forEach(System.out::println);
    }
}
```

# 分支合并

## 什么是ForkJoin

从JDK1.7开始，Java提供Fork/Join框架用于并行执行任务！提高大数据量的效率。

- 它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。
- 这种思想和MapReduce很像（input --> split --> map --> reduce --> output）
- 主要有两步：`第一、任务切分；第二、结果合并`

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609212655768-1464166180.png" alt="image-20240609212656786" style="zoom:50%;" />

它的模型大致是这样的：

- 线程池中的每个线程都有自己的工作队列（PS：这一点和ThreadPoolExecutor不同，ThreadPoolExecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务），
- 当自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。

## 工作窃取

forkjoin工作窃取：简单理解，就是一个工作线程下会维护一个包含多个子任务的`双端队列`。

- 而对于每个工作线程来说，会从头部到尾部依次执行任务。
- 这时，总会有一些线程执行的速度较快，很快就把所有任务消耗完了。那这个时候怎么办呢，总不能空等着吧，多浪费资源啊。【工作窃取】

`工作窃取（work-stealing）算法`是指：某个线程从其他队列里窃取任务来执行。

- 核心类ForkJoinPoolWorkQueue是一个ForkJoinPool中的内部类，它是线程池中线程的工作队列的一个封装，支持任务窃取
- 工作窃取的运行流程图如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609212730571-603904740.png" alt="image-20240609212731486" style="zoom:67%;" />

1. 那么为什么需要使用工作窃取算法呢？

   假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。

   但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。

   而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，**通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。**

2. 工作窃取算法的优点是：

   - 充分利用线程进行并行计算，并减少了线程间的竞争，
   - 先做完任务的工作线程会从其他未完成任务的线程尾部依次获取任务去执行。这样就可以充分利用CPU的资源。

3. 工作窃取算法的缺点是：

   - 在某些情况下还是存在竞争，比如双端队列里只有一个任务时。
   - 并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。

## 核心类

### ForkJoinPool

WorkQueue是一个ForkJoinPool中的内部类，它是线程池中线程的工作队列的一个封装，支持任务窃取

- 每个线程都有一个WorkQueue，
- 而WorkQueue中有执行任务的线程（ForkJoinWorkerThread owner），
- 还有这个线程需要处理的任务（ForkJoinTask<?>[] array）。
- 那么这个新提交的任务就是加到array中。

### ForkJoinTask

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240619101546950-158310922.png" alt="image-20240619101546579" style="zoom:50%;" />

ForkJoinTask代表运行在ForkJoinPool中的任务。

子类： Recursive ：递归

- RecursiveAction ：一个递归无结果的ForkJoinTask（没有返回值）

- RecursiveTask ：一个递归有结果的ForkJoinTask（有返回值）

  ```java
  //示例
  class Fibonacci extends RecursiveTask<Integer> { 
      final int n; 
      Fibonacci(int n) { 
          this.n = n; 
      } 
      
      Integer compute() { 
          if (n <= 1) 
              return n; 
          Fibonacci f1 = new Fibonacci(n - 1); 
          f1.fork(); Fibonacci f2 = new Fibonacci(n - 2); 
          
          return f2.compute() + f1.join(); 
      } 
  } 
  ```

主要方法：

- fork() 在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务。
- join() 当任务完成的时候返回计算结果。
- invoke() 开始执行任务，如果必要，等待计算完成。

## 代码验证

核心代码

```java
//求和计算
import java.util.concurrent.RecursiveTask;

/**
 * 使用ForkJoin：
 * 1.forkjoinpool 通过它来执行
 * 2.计算任务：execute(ForkJoinTask<?> task)
 * 3.计算类继承ForkJoinTask
 */
public class ForkJoinDemo extends RecursiveTask<Long> {

    private Long start;
    private Long end;
    //临界值
    private Long temp = 10000L;

    public ForkJoinDemo(Long start, Long end) {
        this.start = start;
        this.end = end;
    }

    //计算方法
    @Override
    protected Long compute() {
        if ((end - start) < temp) {
            Long sum = 0L;
            for (Long i = start; i <= end; i++) {
                sum += i;
            }
            return sum;
        } else {
            //分支合并计算
            Long middle = (start + end) / 2;

            ForkJoinDemo fork1 = new ForkJoinDemo(start, middle);
            fork1.fork();   //拆分任务，把任务压入线程队列
            ForkJoinDemo fork2 = new ForkJoinDemo(middle + 1, end);
            fork2.fork();	//拆分任务，把任务压入线程队列
			//合并结果
            return fork1.join() + fork2.join();
        }
    }
}
```

三种测试  

```java
public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        test2();
    }
	//普通方式
    public static void test1() {
        Long sum = 0L;

        long start = System.currentTimeMillis();
        for (Long i = 1L; i <= 10_0000_0000L; i++) {
            sum += i;
        }
        long end = System.currentTimeMillis();

        System.out.println("sum = " + sum + " 耗时: " + (end - start));
        //sum = 500000000500000000 耗时: 5387
    }

    //ForkJoin
    public static void test2() throws ExecutionException, InterruptedException {
        long start = System.currentTimeMillis();

        ForkJoinPool forkJoinPool = new ForkJoinPool();	//实现ForkJoin 就必须有ForkJoinPool的支持
        ForkJoinTask<Long> task = new ForkJoinDemo(1L, 10_0000_0000L);
        ForkJoinTask<Long> submit = forkJoinPool.submit(task);	//提交任务
        Long sum = submit.get();

        long end = System.currentTimeMillis();
        System.out.println("sum = " + sum + " 耗时: " + (end - start));
        //sum = 500000000500000000 耗时: 5323
    }

    //Stream并行流
    public static void test3() {
        long start = System.currentTimeMillis();

        long sum = LongStream.rangeClosed(1L, 10_0000_0000L).parallel().reduce(0, Long::sum);

        long end = System.currentTimeMillis();
        System.out.println("sum = " + sum + " 耗时: " + (end - start));
        //sum = 500000000500000000 耗时: 91
    }
}
```

# 异步回调

## 概述

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240619110249937-1538224970.png" alt="image-20240619110249503" style="zoom:40%;" />

1. Future设计的初衷：对将来某个时刻会发生的结果进行建模。

   - 当我们需要调用一个函数方法时。如果这个函数执行很慢,那么我们就要进行等待。但有时候,我们可能并不急着要结果。
   - 因此,我们可以让被调用者立即返回,让他在后台慢慢处理这个请求。
   - 对于调用者来说,则可以先处理一些其他任务,在真正需要数据的场合再去尝试获取需要的数据。

   它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在Future中出发那些潜在耗时的操作把调用线程解放出来，让它能继续执行其他有价值的工作，不再需要等待耗时的操作完成。

2. Future的优点：比更底层的Thread更易用。

   要使用Future，通常只需要将耗时的操作封装在一个Callable对象中，再将它提交给ExecutorService。

3. 为了让程序更加高效，让CPU最大效率的工作，我们会采用`异步编程`。

   - 首先想到的是开启一个新的线程去做某项工作。
   - 再进一步，为了让新线程可以返回一个值，告诉主线程事情做完了，于是乎Future粉墨登场。
   - 然而Future提供的方式是主线程主动问询新线程，要是有个回调函数就爽了。
   - 所以，为了满足Future的某些遗憾，强大的CompletableFuture随着Java8一起来了。

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609213112508-1844357467.png" alt="image-20240609213113224" style="zoom:50%;" />

## 实例

1. 没有返回值的异步回调：runAsync

   ```java
   public static void main(String[] args) throws ExecutionException, InterruptedException {
       //发起一个请求 Void:没有返回值的 runAsync 异步回调
       CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> {
           try {
               TimeUnit.SECONDS.sleep(2);
           } catch (InterruptedException e) {
               throw new RuntimeException(e);
           }
           System.out.println(Thread.currentThread().getName() + " runAsync => Void");
           //ForkJoinPool.commonPool-worker-1 runAsync => Void
       });
   
       System.out.println("111");
   
       //获取阻塞执行结果
       completableFuture.get();
   }
   /*输出结果：
   111
   ForkJoinPool.commonPool-worker-1 runAsync => Void
   */
   ```

2. 有返回值的异步回调：supplyAsync

   ```java
   public static void main(String[] args) throws ExecutionException, InterruptedException {
       //有返回值的异步回调 supplyAsync
       CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {
           System.out.println(Thread.currentThread().getName() + " supplyAsync => Integer");
           int i = 1 / 0;
           return 1024;
       });
   
       System.out.println(completableFuture.whenComplete((t, u) -> {
           //T: 正常的返回结果  U: 错误信息
           System.out.println("T: " + t + " U: " + u);
       }).exceptionally((e) -> {
           System.out.println(e.getMessage());
           return 233; //可以获取到错误的返回结果
       }).get());
   }
   /*正常结果：
       ForkJoinPool.commonPool-worker-1 supplyAsync => Integer
       T: 1024 U: null
       1024
   异常结果：
       ForkJoinPool.commonPool-worker-1 supplyAsync => Integer
       T: null U: java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero
       java.lang.ArithmeticException: / by zero
       233
   */
   ```

# JMM

## 对volatile的理解

volitile 是 Java 虚拟机提供的`轻量级的同步机制`，

三大特性：

1. 保证可见性
2. 不保证原子性
3. 禁止指令重排

## 什么是JMM

JMM ：Java内存模型，本身是一种抽象的概念，并不真实存在，它描述的是一组规则或者规范~

- JMM即为JAVA 内存模型（java memory model）。
- 因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。
- Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。
- JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。

1. JMM 关于同步的规定：
   1. 线程解锁前，必须把共享变量的值刷新回主内存
   2. 线程加锁前，必须读取主内存的最新值到自己的工作内存
   3. 加锁解锁是同一把锁
2. JMM规定了内存主要划分为：主内存和工作内存两种。
   - 此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的，
   - 如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，
   - 从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609213254133-398110983.png" alt="image-20240609213254584" style="zoom: 67%;" />

JVM在设计时候考虑到，如果JAVA线程每次读取和写入变量都直接操作主内存，对性能影响比较大，所以每条线程拥有各自的`工作内存`：

- 工作内存中的变量是主内存中的一份拷贝，
- 线程对变量的读取和写入，直接在工作内存中操作，而不能直接去操作主内存中的变量。

但是这样就会出现一个问题，当一个线程修改了自己工作内存中变量，对其他线程是不可见的，会导致线程不安全的问题。因为JMM制定了一套标准来保证开发者在编写多线程程序的时候，能够控制什么时候内存会被同步给其他线程。  

## JMM的内存模型

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609213336254-2029692437.png" alt="image-20240609213337221" style="zoom:50%;" />

线程A感知不到线程B操作了值的变化！如何能够保证线程间可以同步感知这个问题呢？只需要使用Volatile关键字即可！volatile 保证线程间变量的可见性，简单地说就是当线程A对变量X进行了修改后，在线程A后面执行的其他线程能看到变量X的变动，更详细地说是要符合以下两个规则 ：

1. 线程对变量进行修改之后，要立刻回写到主内存。
2. 线程对变量读取的时候，要从主内存中读，而不是缓存。

各线程的工作内存间彼此独立，互不可见，在线程启动的时候，虚拟机为每个内存分配一块工作内存，不仅包含了线程内部定义的局部变量，也包含了线程所需要使用的共享变量(非线程内构造的对象)的副本，即，为了提高执行效率。

### 内存交互操作

内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的(对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外)



1. lock(锁定)︰作用于主内存的变量，把一个变量标识为线程独占状态
2. unlock(解锁)︰作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
3. read(读取)︰作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
4. load(载入)︰作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
5. use(使用)︰作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
6. assign(赋值)︰作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
7. store(存储)︰作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
8. write(写入)∶作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

### 规则

1. 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
2. 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存·不允许一个线程将没有assign的数据从工作内存同步回主内存
3. 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作
4. 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
5. 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前,必须重新load或assign操作初始化变量的值
6. 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
7. 对一个变量进行unlock操作之前，必须把此变量同步回主内存

JMM对这八种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。

1. happens-before字面翻译过来就是先行发生，A happens-before B就是A先行发生于B?

   不准确!在Java内存模型中，happens-before应该翻译成:前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。

2. 我们再来看看为什么需要这几条规则?

   - 因为我们现在电脑都是多CPU,并且都有缓存，导致多线程直接的可见性问题。详情可以看我之前的文章面试官:你知道并发Bug的源头是什么吗?
   - 所以为了解决多线程的可见性问题，就搞出了happens-before原则，让线程之间遵守这些原则。编译器还会优化我们的语句，所以等于是给了编译器优化的约束。不能让它优化的不知道东南西北了！

# volatile

volatile是不错的机制，但是也不能保证原子性。

## 保证可见性

- 不加 volatile 就会死循环，main线程中修改了num的值，但是new Thread线程看不到
- 加了volatile后，线程一修改num，循环就停止了

```java
//Volatile 用来保证数据的同步，也就是可见性
public class JMMDemo {

    // volatile ：不加volatile没有可见性
    private volatile static int num = 0;

    public static void main(String[] args) {   //main线程

        new Thread(() -> {
            while (num == 0) {

            }
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        num = 1;
        System.out.println(num);
    }
}
```

## 不保证原子性

原子性理解：

- 不可分割，完整性，
- 也就是某个线程正在做某个具体的业务的时候，中间不可以被加塞或者被分割，
- 需要整体完整，要么同时成功，要么同时失败。

```java
//不保证原子性
public class Demo02 {
    //依旧达不到两万
    private volatile static int num = 0;

    //方法加synchronized或者lock锁可以保证原子性
    public static void add() {
        num++;//不是原子性操作
    }

    public static void main(String[] args) {
        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    add();// 结果应该是 num 为 2万，测试看结果
                }
            }).start();
        }

        while (Thread.activeCount() > 2) {//main gc
            Thread.yield(); //线程礼让
        }
        System.out.println(Thread.currentThread().getName() + " num:" + num);
    }
}
```

1. 命令行查看底层字节码代码实现： javap -c JMMVolatileDemo02.class

   num++不是原子性操作：

   1. 获得这个值
   2. 值+1
   3. 写回这个值

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609213719281-719708960.png" alt="image-20240609213720021" style="zoom: 33%;" />

2. num++ 在多线程下是非线程安全的，如何不加 synchronized解决？查看原子包java.util.concurrent.atomic 
   下的类Class AtomicInteger，分析方法：【底层和操作系统直接挂钩】

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609213726617-671423449.png" alt="image-20240609213727645" style="zoom:50%;" />

测试：

```java
public class Demo02 {
    //原子类：AtomicInteger
    private volatile static AtomicInteger num = new AtomicInteger();

    public static void add() {
        //num++;
        num.getAndIncrement(); //+1方法，CAS
    }

    public static void main(String[] args) {
        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount() > 2) {//main gc
            Thread.yield(); //线程礼让
        }
        System.out.println(Thread.currentThread().getName() + " num:" + num);
        //main num:20000
    }
}
```

## 禁止指令重排

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609213810649-1519646647.png" alt="image-20240609213811312" style="zoom:50%;" />

指令重排：你写的程序，计算机并不是按照你写的那样去执行的。计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分以下3种：

- 编译器优化重排
- 指令并行重排
- 内存系统重排

重排理解测试1:

```java
    int x = 11; // 语句1
    int y = 12; // 语句2
    x = x + 5; // 语句3
    y = x * x; // 语句4
 
// 指令顺序预测: 1234 2134 1324  
// 不可能是：4123  处理器在进行重排序时必须要考虑指令之间的数据依赖性
```

重排理解测试2：

- 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。
- 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。

![image-20240609213901256](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609213900338-327102736.png)

案例：

```java
// 多线程环境中线程交替执行，由于编译器优化重排的存在
// 两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。
public class TestHappensBefore {
    int a = 0;
    boolean flag = false;
    
    public void m1(){
        a = 1; // 语句1
        flag = true; // 语句2
    } 
    
    public void m2(){
        if (flag){
            a = a + 5; // 语句3
            System.out.println("m2=>"+a);
        }
    }
}
```

`指令重排小结：`

1. **volatile** 实现了**禁止指令重排**优化，从而避免 多线程环境下程序出现乱序执行的现象。

2. **内存屏障**（Memory Barrier）又称内存栅栏，是一个CPU 指令，它的作用有两个：

   - 保证特定操作的执行顺序。
   - 保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。

   由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条 Memory Barrier 则会告诉编译器和CPU，不管什么指令都不能和这条 Memory Barrier 指令重排序，也就是说，通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。

   内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。

   加上volatile会在：Write后加上store内存屏障，read前加上load内存屏障。

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609213954652-928689462.png" alt="image-20240609213955325" style="zoom:50%;" />

3. Volatile经过，保证可见性，不保证原子性，禁止指令重排的话，线程安全性获得保证：

   工作内存与主内存同步延迟现象导致的可见性问题，可以使用 synchronized 或 volatile 关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。

   对于指令重排导致的可见性问题 和 有序性问题，可以利用 volatile 关键字解决，因为 volatile 的另外一个作用就是禁止重排序优化。

# 深入单例模式

## 饿汉式

```java
//饿汉式单例
public class Hungry {
    private byte[] data1 = new byte[1024];
    private byte[] data2 = new byte[1024];
    private byte[] data3 = new byte[1024];
    private byte[] data4 = new byte[1024];

    private Hungry() {

    }

    private final static Hungry HUNGRY = new Hungry();

    public static Hungry getInstance() {
        return HUNGRY;
    }
}
```

1. 饿汉式是最简单的单例模式的写法，保证了线程的安全
2. 在Hungry类中，定义了四个byte数组，当代码一运行，这四个数组就被初始化，并且放入内存了。如果长时间没有用到getInstance方法，不需要Hungry类的对象，是一种浪费
3. 我们希望的是 只有用到了 getInstance方法，才会去初始化单例类，才会加载单例类中的数据。所以就有了 第二种单例模式：懒汉式。  

## 懒汉式

```java
//懒汉式单例模式
public class Lazy {
    private Lazy() {
        System.out.println(Thread.currentThread().getName() + " OK");
    }

    private static Lazy lazy;

    public static Lazy getInstance() {
        if (lazy == null) {
            lazy = new Lazy();
        }
        return lazy;
    }

    //单线程下单例OK
    //多线程并发情况：
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                Lazy.getInstance();
            }).start();
        }
    }
}
/*
Thread-1 OK
Thread-3 OK
Thread-0 OK
Thread-2 OK
*/
```

DCL懒汉式：双重检测锁模式。多加一层检测可以避免问题  

```java
//懒汉式单例模式
public class Lazy {
    private Lazy() {
        System.out.println(Thread.currentThread().getName() + " OK");
    }
	//禁止指令重排
    private volatile static Lazy lazy;

    public static Lazy getInstance() {
        if (lazy == null) {
            synchronized (Lazy.class) {
                if (lazy == null) {
                    lazy = new Lazy(); //不是原子性操作
                    /**可能执行：123,132
                    * 1.分配内存空间
                    * 2.执行构造方法，初始化对象
                    * 3.把这个对象指向这个空间
                    **/
                }
            }
        }
        return lazy; //132时，lazy还没有完成构造
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                Lazy.getInstance();
            }).start();
        }
    }
}
//Thread-0 OK
```

DCL懒汉式的单例：

- 保证了线程的安全性，
- 又符合了懒加载，只有在用到的时候，才会去初始化，
- 调用效率也比较高，
- 但是这种写法在极端情况还是可能会有一定的问题。因为  :lazyMan = new LazyMan();  
  - 不是原子性操作，至少会经过三个步骤：

    1. 分配对象内存空间
    2. 执行构造方法初始化对象
    3. 设置instance指向刚分配的内存地址，此时instance ！=null；

由于指令重排：

- 导致A线程执行 lazyMan = new LazyMan();的时候，可能先执行了第三步（还没执行第二步），
- 此时线程B又进来了，发现lazyMan已经不为空了，直接返回了lazyMan，并且后面使用了返回的lazyMan，
- 由于线程A还没有执行第二步，导致此时lazyMan还不完整，可能会有一些意想不到的错误，所以就有了下面一种单例模式。

这种单例模式只是在上面DCL单例模式增加一个volatile关键字来避免指令重排

```java
public class LazyMan {
    private LazyMan() {

    } 
    private volatile static LazyMan lazyMan;
    
    public static LazyMan getInstance() {
        if (lazyMan == null) {
        	synchronized (LazyMan.class) {
        		if (lazyMan == null) {
        			lazyMan = new LazyMan();
        		}
   			 }
		} return lazyMan;
    }
}
```

## 静态内部类

还有这种方式是第一种饿汉式的改进版本，同样也是在类中定义static变量的对象，并且直接初始化，不过是移到了静态内部类中，十分巧妙。

- 既保证了线程的安全性，同时又满足了懒加载。  

```java
//静态内部类
public class Holder {
    private Holder(){
        
    }
    public static class InnerClass{
        private static final Holder HOLDER = new Holder();
    }
    
    public static Holder getInstance(){
        return InnerClass.HOLDER;
    }
}
```

## 万恶的反射

1. 反射：无视private修饰的构造方法，可以直接在外面newInstance，破坏单例模式。  

   ```java
   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
       Lazy instance = Lazy.getInstance();
       Constructor<Lazy> declaredConstructor = Lazy.class.getDeclaredConstructor(null);
       //无视私有
       declaredConstructor.setAccessible(true);
       Lazy instance2 = declaredConstructor.newInstance();
   
       System.out.println(instance);   //com.sunm.single.Lazy@404b9385
       System.out.println(instance2);  //com.sunm.single.Lazy@6d311334
   }
   ```

   解决方式：给构造器加锁。

   - 在私有的构造函数中做一个判断，如果lazyMan不为空，说明lazyMan已经被创建过了，
   - 如果正常调用getInstance方法，是不会出现这种事情的，所以直接抛出异常！

   ```java
   public class Lazy {
   	private Lazy() {
           //加锁
           synchronized (Lazy.class) {
               if (lazy != null) {
                   throw new RuntimeException("不要视图使用反射破坏单例模式！");
               }
           }
           System.out.println(Thread.currentThread().getName() + " OK");
       }
   
       private volatile static Lazy lazy;
   
       //DCL
       public static Lazy getInstance() {
           if (lazy == null) {
               synchronized (Lazy.class) {
                   if (lazy == null) {
                       lazy = new Lazy();
                   }
               }
           }
           return lazy;
       }
   }
   ```

2. 但是这种写法还是有问题：如果全是使用反射获取对象，我们的判断就不生效了：

   ```java
   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
           Constructor<Lazy> declaredConstructor = Lazy.class.getDeclaredConstructor(null);
           //无视私有
           declaredConstructor.setAccessible(true);
       
           Lazy instance1 = declaredConstructor.newInstance();
           Lazy instance2 = declaredConstructor.newInstance();
   
           System.out.println(instance1);   //com.sunm.single.Lazy@404b9385
           System.out.println(instance2);  //com.sunm.single.Lazy@6d311334
       }
   ```

   解决方法：红绿灯标志位

   - 定义了一个boolean变量flag，初始值是false，
   - 私有构造函数里面做了一个判断，如果flag=false，就把flag改为true，
   - 但是如果flag等于true，就说明有问题了，因为正常的调用是不会第二次跑到私有构造方法的，所以抛出异常。

   ```java
   //懒汉式单例模式
   public class Lazy {
       //使用标志位
       private static boolean flag = false;
   
       private Lazy() {
           synchronized (Lazy.class) {
               if (!flag) {
                   flag = true;
               } else {
                   throw new RuntimeException("不要视图使用反射破坏单例模式！");
               }
           }
           System.out.println(Thread.currentThread().getName() + " OK");
       }
   
       private volatile static Lazy lazy;
   
       //DCL
       public static Lazy getInstance() {
           if (lazy == null) {
               synchronized (Lazy.class) {
                   if (lazy == null) {
                       lazy = new Lazy();
                   }
               }
           }
           return lazy;
       }
   }
   ```

3. 看起来很美好，但是还是不能完全防止反射破坏单例模式，因为可以利用反射修改flag的值。

   ```java
   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException {
       	//获得标志位
           Field flag = Lazy.class.getDeclaredField("flag");
       	//无视私有
           flag.setAccessible(true);
   
           Constructor<Lazy> declaredConstructor = Lazy.class.getDeclaredConstructor(null);
   
           //无视私有
           declaredConstructor.setAccessible(true);
           Lazy instance1 = declaredConstructor.newInstance();
           flag.set(instance1, false);	//修改标志位的值
           Lazy instance2 = declaredConstructor.newInstance();
   
           System.out.println(instance1);   //com.sunm.single.Lazy@404b9385
           System.out.println(instance2);  //com.sunm.single.Lazy@6d311334
       }
   ```

4. 并没有一个很好的方案去避免反射破坏单例模式，所以轮到我们的枚举登场了。

## 枚举

枚举类型是：一种特殊的数据类型，之所以特殊是因为：

- 它既是一种类(class)类型
- 却又比类类型多了些特殊的约束，
- 但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。

枚举是目前最推荐的单例模式的写法，因为：

- 足够简单，不需要开发自己保证线程的安全，
- 同时又可以有效的防止反射破坏我们的单例模式，

使用枚举类型来获取对象：

1. 正常获取：

   ```java
   //枚举：本身是一个Class类
   public enum EnumSingle {
       INSTANCE;
   
       public EnumSingle getEnum() {
           return INSTANCE;
       }
   }
   
   class Test {
       public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
           EnumSingle instance1 = EnumSingle.INSTANCE;
           EnumSingle instance2 = EnumSingle.INSTANCE;
   		//相同
           System.out.println(instance1);	//INSTANCE
           System.out.println(instance2);	//INSTANCE
       }
   }
   ```

2. 通过反射获取：报错没有无参构造

   ```java
   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
       EnumSingle instance1 = EnumSingle.INSTANCE;
   
       //.NoSuchMethodException: com.sunm.single.EnumSingle.<init>() 
       //报错：没有无参构造
       Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(null);
       declaredConstructor.setAccessible(true);
   
       EnumSingle instance2 = declaredConstructor.newInstance();
   
       System.out.println(instance1);
       System.out.println(instance2);
   }
   ```

3. javap反编译查看：

   ```bash
   javap -p EnumSingleton.class
   ```

   ```java
   Compiled from "EnumSingleton.java"
   public final class 单例模式.EnumSingleton extends java.lang.Enum<单例模式.EnumSingleton> {
       public static final 单例模式.EnumSingleton INSTANCE;
       private static final 单例模式.EnumSingleton[] $VALUES;
       public static 单例模式.EnumSingleton[] values();
       public static 单例模式.EnumSingleton valueOf(java.lang.String);
       private 单例模式.EnumSingleton();
       public 单例模式.EnumSingleton getInstance();
       static {};
   }
   ```

4. jad 进行反编译

   ```bash
   jad -sjava EnumSingleton.class
   # 会生成一个java文件
   Parsing EnumSingleton.class... Generating EnumSingleton.java
   ```

   ```java
   //反编译源码中显示：含有有参构造
   public final class EnumSingleton extends Enum
   {
       public static EnumSingleton[] values()
       {
       	return (EnumSingleton[])$VALUES.clone();
       } 
       public static EnumSingleton valueOf(String name)
       {
       	return (EnumSingleton)Enum.valueOf(53554F8B6A215F0F/EnumSingleton,name);
       }
       
       //有参构造
       private EnumSingleton(String s, int i)
       {
           super(s, i);
       }
       
       public EnumSingleton getInstance()
       {
       	return INSTANCE;
       } 
       
       public static final EnumSingleton INSTANCE;
       private static final EnumSingleton $VALUES[];
       
       static
       {
           INSTANCE = new EnumSingleton("INSTANCE", 0);
           $VALUES = (new EnumSingleton[] {
           	INSTANCE
       	});
       }
   }
   ```

5. 修改反射获取构造器的参数

   ```java
   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
       EnumSingle instance1 = EnumSingle.INSTANCE;
   
       //.IllegalArgumentException: Cannot reflectively create enum objects
       //报错：枚举不能通过反射创建对象
       Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, int.class);
       declaredConstructor.setAccessible(true);
   
       EnumSingle instance2 = declaredConstructor.newInstance();
   
       System.out.println(instance1);
       System.out.println(instance2);
   }
   ```

# 深入理解CAS

## CAS : 比较并交换  

用代码理解下什么是CAS：

```java
public class CASDemo {
    //CAS:compareAndSet 比较并交换
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);
        /**
         * 参数：期望值，更新值   如果达到了期望值，就更新,修改成功；否则不更新,修改失败
         * public final boolean compareAndSet(int expectedValue, int newValue)
         * CAS是CPU的并发原语
         */
        System.out.println(atomicInteger.compareAndSet(2020, 2021));//true
        System.out.println(atomicInteger.get());    //2021

        atomicInteger.getAndIncrement();

        System.out.println(atomicInteger.compareAndSet(2020, 2021));//false
        System.out.println(atomicInteger.get());    //2021
    }
}
```

## 原子类自增底层原理

`atomicInteger.getAndIncrement()`这里的自增 + 1怎么实现的！

```java
//1.自增
	atomicInteger.getAndIncrement();

//2.进入getAndIncrement
    public final int getAndIncrement() {
        //this:当前对象; Value:内存偏移量，内存地址; 1:固定值
        return U.getAndAddInt(this, VALUE, 1);
    }

//3.查看U
    /**
    * Java无法操作内存，Java可以调用C++【native】，C++可以调用内存
    * Unsafe相当于是Java的后门，可以通过这个类操作内存
    */
    private static final Unsafe U = Unsafe.getUnsafe();

//4.查看VALUE  获取内存地址的偏移值
    private static final long VALUE
            = U.objectFieldOffset(AtomicInteger.class, "value");
    //volatile避免指令重排，可以被隔离的
    private volatile int value;

//5.进入getAndAddInt【自旋锁】  内存操作，效率高
	@IntrinsicCandidate
	//this,valueOffset,1
    public final int getAndAddInt(Object o, long offset, int delta) {
        int v;
        do {
            //获取this对象里偏移为offset的值
            v = getIntVolatile(o, offset);
        } 
        //如果this对象里偏移为offset的值v，是V就更新为v+1
        while (!weakCompareAndSetInt(o, offset, v, v + delta));
        return v;
    }
```

## UnSafe类

1. UnSafe

   - UnSafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问， 
   - UnSafe相当于一个后门，基于该类可以直接操作特定内存的数据，
   - Unsafe类存在于 sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。

   注意：Unsafe类中的所有方法都是Native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务

2. 变量valueOffset

   表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。

3. 变量 value用volatile修饰，保证了多线程之间的内存可见性

4. 汇编层面理解：Unsafe 类中的 compareAndSwapint，是一个本地方法，该方法的实现位于 unsafe.cpp 中；

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609215311373-118093884.png" alt="image-20240609215311974" style="zoom: 50%;" />


## CAS 

CAS 的全称为 Compare-And-Swap【比较并交换】，它是一条CPU并发原语。

- 功能是：判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。  


CAS并发原语体现在JAVA语言中就是 sun.misc.Unsafe 类中的各个方法。

- 调用UnSafe类中的CAS方法， JVM会帮我们实现出CAS汇编指令。
- 这是一种完全依赖于硬件的功能，通过它实现了原子操作。
- 再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。

1. CAS（CompareAndSwap）

   比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存中的值一致为止。【自旋锁】

2. CAS 应用

   CAS 有3个操作数，内存值V，旧的预期值A，要修改的更新值B。

   且仅当预期值A 和 内存值 V 相同时，将内存值 V 修改为B，否则什么都不做。

3. CAS 的缺点

   - 循环时间长开销很大。可以看到源码中存在 一个 do...while 操作，如果CAS失败就会一直进行尝试。
   - 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作。但是：对多个共享变量操作时，循环CAS就无法保证操作的原子性，这时候就可以用锁来保证原子性。
   - ABA 问题：狸猫换太子

# 原子引用

## ABA问题

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240619214815262-470217873.png" alt="image-20240619214815010" style="zoom:40%;" />

CAS算法实现一个重要前提：需要取出内存中某时刻的数据并在当下时刻比较并交换，那么在这个时间差内会导致数据的变化

- 比如说一个线程one从内存位置V中取出A，
- 这个时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将 V位置的数据变成A，
- 这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。

尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。

```java
public class CASDemo {
    //CAS:compareAndSet 比较并交换
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);
        
        //A
        System.out.println(atomicInteger.compareAndSet(2020, 2021));//true
        System.out.println(atomicInteger.get());    //2021
        //B
        System.out.println(atomicInteger.compareAndSet(2021, 2020));//true
        System.out.println(atomicInteger.get());    //2020
        //A
        System.out.println(atomicInteger.compareAndSet(2020, 777));//true
        System.out.println(atomicInteger.get());    //777
    }
}
```

## 原子引用 AtomicReference

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240619215346212-759338287.png" alt="image-20240619215345839" style="zoom:33%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609215605231-892476989.png" alt="image-20240609215605716" style="zoom:50%;" />

AtomicStampedReference：带版本号的 原子操作。版本号原子引用，类似乐观锁。

```java
//参数：初始的期望，初始戳
public AtomicStampedReference(V initialRef, int initialStamp) {
    pair = Pair.of(initialRef, initialStamp);
}

//CAS
public boolean compareAndSet(V   expectedReference,	//期望值
                             V   newReference,	//更新值
                             int expectedStamp,	//期望的戳
                             int newStamp) {	//新戳
    Pair<V> current = pair;
    return
        expectedReference == current.reference &&
        expectedStamp == current.stamp &&
        ((newReference == current.reference &&
          newStamp == current.stamp) ||
         casPair(current, Pair.of(newReference, newStamp)));
}
```

## 解决ABA问题

```java
public class CASDemo {
    //CAS:compareAndSet 比较并交换
    public static void main(String[] args) {
        //Integer: 使用对象缓存机制，默认-128~127，超过了这个值就会new新的对象分配新的内存空间
        AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(1, 1);

        new Thread(() -> {
            //获得版本号
            int stamp = atomicStampedReference.getStamp();
            System.out.println("a1=> " + stamp);

            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            System.out.println(atomicStampedReference.compareAndSet(1, 2,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));
            System.out.println("a2=> " + atomicStampedReference.getStamp());

            System.out.println(atomicStampedReference.compareAndSet(2, 1,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));
            System.out.println("a3=> " + atomicStampedReference.getStamp());
        }, "a").start();
        new Thread(() -> {
            int stamp = atomicStampedReference.getStamp();
            System.out.println("b1=> " + stamp);

            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            System.out.println(atomicStampedReference.compareAndSet(1, 6, stamp, stamp + 1));
            System.out.println("b2=> " + atomicStampedReference.getStamp());
        }, "b").start();
    }
}
/*
b1=> 1
a1=> 1
true
false
b2=> 2
a2=> 2
false
a3=> 2
*/
```

# Java锁

## 公平锁、非公平锁

### 是什么

- 公平锁：是指多个线程**按照申请锁的顺序来获取锁**，类似排队打饭，**先来后到**。
- 非公平锁：是指多个线程获取锁的顺序并**不是按照申请锁的顺序**，有可能后申请的线程比现申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象。

```java
//可重入锁默认为非公平锁

//无参
public ReentrantLock() {
	sync = new NonfairSync();
} 
//有参
public ReentrantLock(boolean fair) {
	sync = fair ? new FairSync() : new NonfairSync();
}
```

### 两者区别

并发包中的 ReentrantLock 的创建可以指定构造函数 的 boolean类型来得到公平锁或者非公平锁，默认是非公平锁！

1. 公平锁：就是很公平，在并发环境中，每个线程在获取到锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己
2. 非公平锁：非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就会采用类似公平锁那种方式。
3. Java ReentrantLock 而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
4. 对于Synchronized而言，也是一种非公平锁。

## 可重入锁

### 是什么

1. 可重入锁（也叫递归锁）指的是：
   - 同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在**进入内层方法会自动获取锁**。
   - 也就是说，线程可以进入任何一个它已经拥有的锁，所同步着的代码块。 好比家里进入大门之后，就可以进入里面的房间了；
2. 典型的可重入锁：ReentrantLock、Synchronized 
3. 可重入锁最大的作用就是：**避免死锁**

### Synchronized

```java
public class Demo01 {
    public static void main(String[] args) {
        Phone phone = new Phone();
        new Thread(() -> {
            phone.msg();
        }, "A").start();

        new Thread(() -> {
            phone.msg();
        }, "B").start();
    }
}

class Phone {
    public synchronized void msg() {
        System.out.println(Thread.currentThread().getName() + "执行了msg()");
        call();
    }

    public synchronized void call() {
        System.out.println(Thread.currentThread().getName() + "执行了call()");
    }
}
/**递归获得了内部的锁
* A执行了msg()
* A执行了call()
* B执行了msg()
* B执行了call()
*/
```

### ReentrantLock  

```java
class Phone {
    Lock lock = new ReentrantLock();

    public void msg() {
        lock.lock();    //两把钥匙，两把锁
        //lock.lock(); 锁必须配对；加锁不解锁，就会死锁

        try {
            System.out.println(Thread.currentThread().getName() + "执行了msg()");
            call();
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }

    public void call() {
        lock.lock();

        try {
            System.out.println(Thread.currentThread().getName() + "执行了call()");
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }
}
/**递归获得了内部的锁
* A执行了msg()
* A执行了call()
* B执行了msg()
* B执行了call()
*/
```

## 自旋锁

### 简介

1. 自旋锁（spinlock）是指：尝试获取锁的线程不会立即阻塞，而是采用循环的方式去不断尝试获取锁。
2. 好处是：减少线程上下文切换的消耗，
3. 缺点是：循环会消耗CPU。

```java
//5.进入getAndAddInt【自旋锁】  内存操作，效率高
	@IntrinsicCandidate
	//this,valueOffset,1
    public final int getAndAddInt(Object o, long offset, int delta) {
        int v;
        do {
            //获取this对象里偏移为offset的值
            v = getIntVolatile(o, offset);
        } 
        //如果this对象里偏移为offset的值v，是V就更新为v+1
        while (!weakCompareAndSetInt(o, offset, v, v + delta));
        return v;
    }
```

### 测试

1. 自定义一个自旋锁

   ```java
   //自旋锁
   public class SpinlockDemo {
       //引用类型默认为null
       AtomicReference<Thread> atomicReference = new AtomicReference<>();
   
       //加锁
       public void myLock() {
           Thread thread = Thread.currentThread();
           System.out.println(Thread.currentThread().getName() + "==>myLock");
           //自旋锁
           while (!atomicReference.compareAndSet(null, thread)) {
   
           }
       }
   
       //解锁
       public void unLock() {
           Thread thread = Thread.currentThread();
           System.out.println(Thread.currentThread().getName() + "==>unLock");
           //自旋锁
           while (!atomicReference.compareAndSet(thread, null)) {
   
           }
       }
   }
   ```

2. 使用该锁

   ```java
   public class TestSpinlock {
       public static void main(String[] args) throws InterruptedException {
           SpinlockDemo spinlockDemo = new SpinlockDemo();
   
           new Thread(() -> {
               //加锁
               spinlockDemo.myLock();
               try {
                   TimeUnit.SECONDS.sleep(3);
               } catch (Exception e) {
                   throw new RuntimeException(e);
               } finally {
                   //解锁
                   spinlockDemo.unLock();
               }
           }, "T1").start();
   
           TimeUnit.SECONDS.sleep(1);
   
           new Thread(() -> {
               //加锁
               spinlockDemo.myLock();
               try {
                   TimeUnit.SECONDS.sleep(1);
               } catch (Exception e) {
                   throw new RuntimeException(e);
               } finally {
                   //解锁
                   spinlockDemo.unLock();
               }
           }, "T2").start();
       }
   }
   /*
   T1==>myLock
   T2==>myLock
   T1==>unLock	//t1释放锁之后，t2才能释放
   T2==>unLock
   */
   ```

## 死锁

### 死锁是什么

死锁是指：

- 两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，
- 若无外力干涉那它们都将无法推进下去，
- 如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低；否则就会因为争夺有限的资源而陷入死锁。

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240609220028135-1696918129.png" alt="image-20240609220028244" style="zoom:50%;" />

产生死锁主要原因：

1. 系统资源不足
2. 进程运行推进的顺序不合适
3. 资源分配不当

### 测试

```java
public class DeadLockDemo {
    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";
        /**
         * 死锁：
         * T1 lock: lockA =>get lockB
         * T2 lock: lockB =>get lockA
         * ......
         */
        new Thread(new MyThread(lockA, lockB), "T1").start();
        new Thread(new MyThread(lockB, lockA), "T2").start();
        
    }
}

class MyThread implements Runnable {
    private String lockA;
    private String lockB;

    public MyThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA) {
            System.out.println(Thread.currentThread().getName() + " lock: " + lockA + " =>get " + lockB);

            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            synchronized (lockB) {
                System.out.println(Thread.currentThread().getName() + " lock: " + lockB + " =>get " + lockA);

            }
        }
    }
}
```

### 解决

拓展java自带工具操作：

1. 查看JDK目录的bin目录

2. 使用 `jps -l 命令`：定位进程号

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240619225446390-765282779.png" alt="image-20240619225446134" style="zoom:50%;" />

3. 使用` jstack 进程号`：找到死锁查看

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240619225640281-509521057.png" alt="image-20240619225640069" style="zoom:50%;" />

## 乐观锁

### 简介

- 乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试
- 悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！

乐观锁实现方式：

1. 取出记录时，获取当前 version
2. 更新时，带上这个version执行更新时， set version = newVersion where version = oldVersion
3. 如果version不对，就更新失败

```mysql
#乐观锁：1、先查询，获得版本号 version = 1
-- A
update user set name = "kuangshen", version = version + 1
where id = 2 and version = 1
-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！
update user set name = "kuangshen", version = version + 1
where id = 2 and version = 1
```

### MP实现

1. 给数据库增加version字段

2. 实体类添加对应的字段

   ```java
   @Version //乐观锁Version注解
   private Integer version;
   ```

3. 注册组件

   ```java
   // 扫描我们的 mapper 文件夹
   @MapperScan("com.kuang.mapper")
   @EnableTransactionManagement
   @Configuration // 配置类
   public class MyBatisPlusConfig {
       // 注册乐观锁插件
       @Bean
       public OptimisticLockerInterceptor optimisticLockerInterceptor() {
       	return new OptimisticLockerInterceptor();
       }
   }
   ```

4. 测试乐观锁

   ```java
   // 测试乐观锁成功！
   @Test
   public void testOptimisticLocker(){
       // 1、查询用户信息
       User user = userMapper.selectById(1L);
       // 2、修改用户信息
       user.setName("kuangshen");
       user.setEmail("24736743@qq.com");
       // 3、执行更新操作
       userMapper.updateById(user);
   }
   
   // 测试乐观锁失败！多线程下
   @Test
   public void testOptimisticLocker2(){
       // 线程 1
       User user = userMapper.selectById(1L);
       user.setName("kuangshen111");
       user.setEmail("24736743@qq.com");
       
       // 模拟另外一个线程执行了插队操作
       User user2 = userMapper.selectById(1L);
       user2.setName("kuangshen222");
       user2.setEmail("24736743@qq.com");
       userMapper.updateById(user2);
       
       // 自旋锁来多次尝试提交！
       userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！
   }
   ```

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240620164338257-270087087.png" alt="image-20240620164337709" style="zoom:57%;" />
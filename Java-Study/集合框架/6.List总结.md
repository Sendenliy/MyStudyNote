### ArrayList和LinkedList的区别

1. arrayList底层是用`数组`实现的顺序表，是`随机存取`类型，可自动扩增，并且在初始化时，数组的长度是0，只有在增加元素时，长度才会增加。默认是10，不能无限扩增，有上限，在查询操作的时候性能更好
2. LinkedList底层是用`链表`来实现的，是一个双向链表，注意这里不是双向循环链表,`顺序存取`类型。在源码中，似乎没有元素个数的限制。应该能无限增加下去，直到内存满了在进行删除，增加操作时性能更好。
3. 两个都是`线程不安全`的，在iterator时，`会发生fail-fast`：快速失效。

### ArrayList和Vector的区别

1. arrayList`线程不安全`，在用iterator，`会发生fail-fast`
2. Vector`线程安全`，因为在方法前加了Synchronized关键字。也`会发生fail-fast`

### fail-fast和fail-safe区别

简单的来说：在java.util下的集合都是发生fail-fast，而在java.util.concurrent下的发生的都是fail-safe  

1. fail-fast

   <img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240322144218336-1825013376.png" alt="image-20240322144227908" width="300" />

   快速失败，例如在arrayList中使用迭代器遍历时，有另外的线程对arrayList的存储数组进行了改变，比如add、delete、等使之发生了结构上的改变，所以Iterator就会快速报一个java.util.ConcurrentModificationException 异常（`并发修改异常`），这就是`快速失败  `

2. fail-safe

   ```java
   public static void main(String[] args) {
       //concurrent包下的类
       CopyOnWriteArrayList list1 = new CopyOnWriteArrayList();
       list1.add(1);
       list1.add(2);
       list1.add(3);
       //fail-safe
       Iterator iterator = list1.iterator();
       while (iterator.hasNext()) {
           System.out.print(iterator.next());  //123
           list1.add(4);
       }
       System.out.println();
       //验证副本的存在
       Iterator iterator1 = list1.iterator();
       while (iterator1.hasNext()) {
           System.out.print(iterator1.next()); //123444
       }
   }
   ```

   安全失败，在java.util.concurrent下的类，都是线程安全的类，他们在迭代的过程中，如果有线程进行结构的改变，不会报异常，而是正常遍历，这就是`安全失败`。  

3. 为什么在java.util.concurrent包下对集合有结构的改变，却不会报异常？

   在concurrent下的集合类增加元素的时候使用Arrays.copyOf()来拷贝副本，在副本上增加元素，如果有其他线程在此改变了集合的结构，那也`是在副本上的改变，而不是影响到原集合`，迭代器还是照常遍历，遍历完之后，改变原引用指向副本，所以总的一句话就是如果在此包下的类进行增加删除，就会出现一个副本。所以能防止fail-fast，这种机制并不会出错，所以我们叫这种现象为fail-safe

4. vector也是线程安全的，为什么是fail-fast呢？

   这里搞清楚一个问题，`并不是说线程安全的集合就不会报fail-fast`，而是报fail-safe，你得搞清楚前面所说答案的原理，出现fail-safe是因为他们在实现增删的底层机制不一样，就像上面说的，会有一个副本，而像arrayList、linekdList、verctor等，他们底层就`是对着真正的引用进行操作`，所以才会发生异常。

5. 既然是线程安全的，为什么在迭代的时候，还会有别的线程来改变其集合的结构呢(也就是对其删除和增加等操作)？

   首先，我们迭代的时候，根本就没用到集合中的删除、增加，查询的操作，就拿vector来说，我们都没有用那些加锁的方法，也就是方法锁放在那没人拿，在迭代的过程中，有人拿了那把锁，我们也没有办法，因为那把锁就放在那边

### 为什么不提倡使用Vector？

1. vector实现线程安全的方法是在每个操作方法上加锁，这些锁并不是必须要的，在实际开发中，一般都是通过锁一系列的操作来实现线程安全，也就是说将需要同步的资源放一起加锁来保证线程安全。
2. 如果多个Thread并发执行一个已经加锁的方法，但是在该方法中，又有vector的存在，vector本身实现中已经加锁了，那么相当于锁上又加锁，会造成额外的开销。
3. 就如上面问题所说的，vector还有fail-fast的问题，也就是说它也无法保证遍历安全，在遍历时又得额外加锁，又是额外的开销，还不如直接用arrayList，然后再加锁呢。

总结：Vector在你不需要进行线程安全的时候，也会给你加锁，也就导致了额外开销，所以在jdk1.5之后就被弃用了，现在如果要用到线程安全的集合，都是从java.util.concurrent包下去拿相应的类。

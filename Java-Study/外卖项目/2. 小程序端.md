# 微信登录和商品浏览

## HttpClient

### 介绍

HttpClient是Apache Jakarta Common下的子项目，可以用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持 HTTP协议最新的版本和建议。

阿里云的sdk-OSS包，包含了httpclient

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529154124348-1494488679.png" alt="image-20240529154132379" style="zoom:50%;" />

```xml
<dependency>
    <groupId>org.apache.httpcomponents</groupId>	
    <artifactId>httpclient</artifactId>
    <version>4.5.13</version>
</dependency>
```

核心API

- HttpClient：可以用来发送http请求
- HttpClients：用来创建一个http对象
- CloseableHttpClient：HttpClient的实现类
- HttpGet：http的get请求
- HttpPost：http的post请求

发送请求步骤:

- 创建HttpClient对象
- 创建Http请求对象
- 调用HttpClient的execute方法发送请求

### 示例

```java
/**
 * 测试通过httpclient发送GET方式的请求
 */
@Test
public void testGET() throws Exception {
    //1.创建HttpClient对象
    CloseableHttpClient httpClient = HttpClients.createDefault();

    //2.创建Http请求对象
    HttpGet httpGet = new HttpGet("http://localhost:8080/user/shop/status");

    //3.调用HttpClient的execute方法发送请求 并接受响应结果
    CloseableHttpResponse response = httpClient.execute(httpGet);

    //4.获取服务端返回的内容
    int statusCode = response.getStatusLine().getStatusCode();
    System.out.println("服务端返回的状态码为：" + statusCode); //服务端返回的状态码为：200

    HttpEntity entity = response.getEntity();
    String body = EntityUtils.toString(entity); //解析一下
    System.out.println("服务端返回的数据为：" + body);    //服务端返回的数据为：{"code":1,"msg":null,"data":1}

    //5.关闭资源
    response.close();
    httpClient.close();
}

/**
 * 测试通过httpclient发送POST方式的请求
 */
@Test
public void testPOST() throws Exception {
    //1.创建HttpClient对象
    CloseableHttpClient httpClient = HttpClients.createDefault();

    //2.创建Http请求对象
    HttpPost httpPost = new HttpPost("http://localhost:8080/admin/employee/login");
    //设置请求参数
    JSONObject jsonObject = new JSONObject();
    jsonObject.put("username", "admin");
    jsonObject.put("password", "123456");

    StringEntity stringEntity = new StringEntity(jsonObject.toString());
    stringEntity.setContentEncoding("UTF-8");   //指定请求编码方式
    stringEntity.setContentType("application/json");    //指定请求数据格式

    httpPost.setEntity(stringEntity);
    //3.调用HttpClient的execute方法发送请求
    CloseableHttpResponse response = httpClient.execute(httpPost);

    //4.解析返回结果
    int statusCode = response.getStatusLine().getStatusCode();
    System.out.println("响应码为：" + statusCode); //响应码为：200

    HttpEntity entity = response.getEntity();
    String body = EntityUtils.toString(entity); //解析一下
    System.out.println("响应数据为：" + body); 
    /*
    响应数据为：
    {"code":1,
    "msg":null,
    "data":{"id":1,"userName":"admin","name":"管理员","token":"eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzE2OTc3NTc4fQ.NjzpNyQJ3ISkcrn7gu7ewKsX1TzhdI0g73dyHv14I5U"}}

     */

    //5.关闭资源
    response.close();
    httpClient.close();
}
```

## 微信小程序

### 介绍

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529162111202-313613606.png" alt="image-20240529162119305" style="zoom:33%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529165323487-2046305159.png" alt="image-20240529165331532" style="zoom:28%;" />

### 准备工作

1. 下载开发者工具

2. 新建项目

3. 进入项目

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529164806463-161863823.png" alt="image-20240529164813744" style="zoom:23%;" />

4. 基本设置

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529165238491-2083387853.png" alt="image-20240529165246619" style="zoom:33%;" />

### 操作步骤

1. 了解小程序的目录结构

   小程序包含一个描述整体程序的app和多个描述各自页面的Page。

   - app

     <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529165748607-252203136.png" alt="image-20240529165756774" style="zoom:33%;" />

   - page

     <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529170003407-1704840779.png" alt="image-20240529170011564" style="zoom:33%;" />

2. 编写小程序代码

3. 编译小程序

4. 发布小程序

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529175302674-1873504490.png" alt="image-20240529175301704" style="zoom:30%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529175333051-1168291227.png" alt="image-20240529175332193" style="zoom:33%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529175405765-1682331075.png" alt="image-20240529175405013" style="zoom:23%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529175447629-572026648.png" alt="image-20240529175446915" style="zoom:23%;" />

### 实例

1. 设置小程序头部名称

   ```json
   //app.json
   {
     "pages": [
       "pages/index/index"
     ],
     "window": {
       "navigationBarTextStyle": "black",
         //设置小程序头部名称
       "navigationBarTitleText": "weixin",
       "navigationStyle": "custom"
     },
     "style": "v2"
   }
   ```

   

2. 获取用户信息

   ```html
   <!--index.wxml-->
   <navigation-bar title="Weixin" back="{{false}}" color="black" background="#FFF"></navigation-bar>
   <view>
       {{msg}}
   </view>
   <view>
       <button bindtap="getUserInfo" type="primary">获取用户信息</button>
       昵称：{{nickName}}
       <image style="width: 100px;height: 100px;" src="{{url}}"></image>
   </view>
   ```

   ```js
   // index.js
   Page({
     data:{
       msg:'hello world',
       nickName:'',
       url:'',
       code:''
     },
     //获取微信用户的头像和昵称
     getUserInfo(){
         wx.getUserProfile({
           desc: '这是一个描述',
           success: (res)=>{
             console.log(res.userInfo)
             this.setData({
               nickName:res.userInfo.nickName,
               url:res.userInfo.avatarUrl
             })
           }
         })
     }
   })
   ```

   

3. 微信登录

   ```html
   <view>
       <button bind:tap="wxlogin" type="warn">微信登录</button>
       授权码：{{code}}
   </view>
   ```

   ```js
   //微信登录，获取微信用户的授权码
   wxlogin(){
       wx.login({
           success: (res) => {
               console.log(res.code),
                   this.setData({
                   code:res.code
               })
           },
       })
   }
   ```

4. 发送异步消息

   ```html
   <view>
       <button bind:tap="senRequest" type="default">发送请求</button>
   </view>
   ```

   ```js
   //发送请求
   senRequest(){
       wx.request({
           url: 'http://localhost:8080/user/shop/status',
           method:'GET',
           success: (res)=>{
               console.log(res.data)
           }
       })
   }
   ```

## 微信登录

导入小程序代码

### 微信登录流程

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529180254671-868890449.png" alt="image-20240529180253590" style="zoom:60%;" />

说明

1. 调用 [wx.login()] 获取 **临时登录凭证code** ，并回传到开发者服务器。
2. 调用 [auth.code2Session] 接口，换取 **用户唯一标识 OpenID** 、 用户在微信开放平台账号下的**唯一标识UnionID**（若当前小程序已绑定到微信开放平台账号） 和 **会话密钥 session_key**。

之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。

 注意事项

1. 会话密钥 `session_key` 是对用户数据进行 [加密签名]的密钥。为了应用自身的数据安全，开发者服务器**不应该把会话密钥下发到小程序，也不应该对外提供这个密钥**。
2. 临时登录凭证 code 只能使用一次

### 代码开发

配置：

1. 配置微信登录所需配置项

   ```yaml
   sky:
       wechat:
         appid: 
         secret: 
   ```

2. 配置为微信用户生成JWT令牌时使用的配置项

   ```yaml
   sky:
     jwt:
       # 设置jwt签名加密时使用的秘钥
       admin-secret-key: itcast
       # 设置jwt过期时间
       admin-ttl: 7200000
       # 设置前端传递过来的令牌名称
       admin-token-name: token
       
       user-secret-key: ittest
       user-ttl: 7200000
       user-token-name: authentication
   ```

接口开发：

1. Controller

   ```java
   @RestController
   @RequestMapping("/user/user")
   @Api(tags = "C端相关接口")
   @Slf4j
   public class UserController {
       @Autowired
       private UserService userService;
       @Autowired
       private JwtProperties jwtProperties;
   
       @PostMapping("/login")
       @ApiOperation("微信登录")
       public Result<UserLoginVO> userLogin(@RequestBody UserLoginDTO userLoginDTO) {
           log.info("微信用户登录：{}", userLoginDTO.getCode());
   
           //1.微信登录
           User user = userService.wxLogin(userLoginDTO);
   
           //2.为微信用户生成JWT令牌
           Map<String, Object> claims = new HashMap<>();
           claims.put(JwtClaimsConstant.USER_ID, user.getId());
           String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(), claims);
   
           UserLoginVO userLoginVO = UserLoginVO.builder()
                   .id(user.getId())
                   .openid(user.getOpenid())
                   .token(token)
                   .build();
           return Result.success(userLoginVO);
       }
   }
   ```

2. Service

   ```java
   User wxLogin(UserLoginDTO userLoginDTO);
   ```

   ```java
   @Service
   @Slf4j
   public class UserServiceImpl implements UserService {
       //HTTPS调用：GET 接口地址
       public static final String WX_LOGIN = "https://api.weixin.qq.com/sns/jscode2session";
   
       @Autowired
       private WeChatProperties weChatProperties;
       @Autowired
       private UserMapper userMapper;
   
       @Override
       public User wxLogin(UserLoginDTO userLoginDTO) {
   
           String openid = getOpenid(userLoginDTO.getCode());
   
           //2.判断openid是否为空， 为空表示登录失败，抛出异常
           if (openid == null || openid.equals("")) {
               throw new LoginFailedException(MessageConstant.LOGIN_FAILED);
           }
   
           //3.判断是否为新用户
           User user = userMapper.getByOpenid(openid);
   
           //4.新用户，自动完成注册
           if (user == null) {
               user = User.builder()
                       .openid(openid)
                       .createTime(LocalDateTime.now())
                       .build();
               userMapper.insert(user);
           }
   
           //5.返回用户对象
           return user;
       }
   
       private String getOpenid(String code) {
           //1.调用微信接口服务，获得当前微信用户的openid
           Map<String, String> map = new HashMap<>();
           map.put("appid", weChatProperties.getAppid());
           map.put("secret", weChatProperties.getSecret());
           map.put("js_code", code);
           map.put("grant_type", "authorization_code");
   
           String json = HttpClientUtil.doGet(WX_LOGIN, map);
   
           JSONObject jsonObject = JSON.parseObject(json);
           String openid = jsonObject.getString("openid");
   
           return openid;
       }
   }
   ```

3. UserMapper

   ```java
   @Mapper
   public interface UserMapper {
       @Select("select * from user where openid=#{openid} ")
       User getByOpenid(String openid);
   
       void insert(User user);
   }
   ```

   ```xml
   <insert id="insert" useGeneratedKeys="true" keyProperty="id">
       insert into user (openid, name, phone, sex, id_number, avatar, create_time)
       values (#{openid}, #{name}, #{phone}, #{sex}, #{idNumber}, #{avatar}, #{createTime});
   </insert>
   ```

设置用户端的JWT拦截验证：

1. 复制一份拦截器并修改

   ```java
   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
       System.out.println("当前线程的id: " + Thread.currentThread().getId());
   
       //判断当前拦截到的是Controller的方法还是其他资源
       if (!(handler instanceof HandlerMethod)) {
           //当前拦截到的不是动态方法，直接放行
           return true;
       }
   
       //1、从请求头中获取令牌
       String token = request.getHeader(jwtProperties.getUserTokenName());
   
       //2、校验令牌
       try {
           log.info("jwt校验:{}", token);
           Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token);
           Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());
           log.info("当前用户id：", userId);
           BaseContext.setCurrentId(userId);
           //3、通过，放行
           return true;
       } catch (Exception ex) {
           //4、不通过，响应401状态码
           response.setStatus(401);
           return false;
       }
   }
   ```

2. 注册拦截器到配置

   ```java
   @Override
   protected void addInterceptors(InterceptorRegistry registry) {
       log.info("开始注册自定义拦截器...");
       registry.addInterceptor(jwtTokenAdminInterceptor)
               .addPathPatterns("/admin/**")
               .excludePathPatterns("/admin/employee/login");
       registry.addInterceptor(jwtTokenUserInterceptor)
               .addPathPatterns("/user/**")
               .excludePathPatterns("/user/user/login")
               .excludePathPatterns("/user/shop/status");
   }
   ```

## 导入商品浏览功能

### 需求分析

1. 查询分类
2. 根据分类ID查询菜品，以及相关的口味
3. 根据分类ID查询套餐
4. 根据套餐ID查询包含的菜品

### 代码导入

### 功能测试

# 缓存菜品和套餐

## 缓存菜品

### 问题分析

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240530193047888-1362329939.png" alt="image-20240530193045555" style="zoom: 33%;" />

问题：用户端展示的菜品数据都是通过查询数据库获得的，访问量过大就会增加数据库访问压力。

结果：系统响应慢、用户体验差

解决方法：通过Redis来缓存菜品数据，减少数据库查询操作；基于内存，性能高。

实现思路-缓存逻辑分析：

- 每个分类下的菜品保存一份缓存数据【key-value  | dish_id-string() 】
- 数据库中菜品数据有变更时，清理缓存数据。【数据一致性】

### 代码-缓存菜品

涉及到客户端接口DishController

```java
@GetMapping("/list")
@ApiOperation("根据分类id查询菜品")
public Result<List<DishVO>> list(Long categoryId) {

    //1.查询Redis中是否存在菜品数据
    String key = "dish_" + categoryId;  //构造Redis的key值，dish_菜品id
    List<DishVO> list = (List<DishVO>) redisTemplate.opsForValue().get(key);

    if (list != null && list.size() > 0) {
        //2.如果存在，直接返回
        log.info("数据已存在缓存Redis中，直接取出分类菜品：{}", categoryId);
        return Result.success(list);
    }

    //3.如果不存在，查询数据库
    log.info("缓存中不存在，查询数据库分类菜品：{}", categoryId);
    Dish dish = new Dish();
    dish.setCategoryId(categoryId);
    dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品

    list = dishService.listWithFlavor(dish);
    //并将数据放入Redis
    redisTemplate.opsForValue().set(key, list);

    return Result.success(list);
}
```

### 代码-清理缓存

涉及到管理端接口DishController的方法有：

1. 新增菜品
2. 修改菜品
3. 批量删除菜品
4. 起售、停售菜品

```java
//清除缓存数据	cleanCache(key);
String key = "dish_" + dishDTO.getCategoryId();
redisTemplate.delete(key);
//清除所有dish_缓存数据	cleanCache("dish_*");
Set keys = redisTemplate.keys("dish_*");
redisTemplate.delete(keys);

//抽取方法
private void cleanCache(String pattern){
    //清除缓存数据
    Set keys = redisTemplate.keys(pattern);
    redisTemplate.delete(keys);
}
```

## SpringCache

### 简介

Spring Cache是一个框架，实现了基于`注解`的缓存功能，只需要简单地加一个注解，就能实现缓存功能。

Spring Cache提供了一层抽象，底层可以切换不同的缓存实现，例如:

- EHCache
- Caffeine
- Redis

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</ artifactId>
</dependency>
<!--使用Redis的缓存实现，只需要pom中导入有相应的java客户端，前面已经导入过-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240530204522689-472031410.png" alt="image-20240530204521779" style="zoom:50%;" />

### 注解示例

【前提】给主启动类开启缓存注解功能`@EnableCaching`

```java
@Slf4j
@SpringBootApplication
@EnableCaching
public class CacheDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(CacheDemoApplication.class,args);
        log.info("项目启动成功...");
    }
}
```

给方法加上注解

1. `@CachePut(cacheNames = "aaa", key = "bbb")`：把方法返回值放入缓存。

   - 如果使用SpringCache缓存数据，缓存中`key的值=cacheNames属性值::key属性值`【例如此处：key=aaa:bbb】

   - 动态生成缓存中的key值：注解的`key属性可以使用SpEL表达式`，例如此处key属性可以设置为：
     - key = "#user.id"：user为接收的参数对象
     - key = "#p0.id"：p0为接收的第一个参数对象
     - key = "#a0.id"：a0为接收的第一个参数对象
     - key = "#root.args[0].id"：值为接收的第一个参数对象的id属性值
     - key = "#result.id"：result为return的对象

   ```java
   @PostMapping
   @CachePut(cacheNames = "userCache", key = "#user.id") 
   public User save(@RequestBody User user) {
       userMapper.insert(user);
       return user;
   }
   ```

   此处的insert方法，返回了id属性给user，所以上面的key可以使用参数里的id。【返回的user和参数里的user指向的是同一个对象】

   ```java
   @Options(useGeneratedKeys = true, keyProperty = "id")
   void insert(User user);
   ```

   ​	测试

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240530213812657-1022291895.png" alt="image-20240530213811938" style="zoom: 33%;" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240530214043358-760941063.png" alt="image-20240530214042737" style="zoom: 33%;" />

   

2. `@Cacheable(cacheNames = "userCache",key = "#id")`：缓存中是否有数据，有数据就返回缓存数据；没数据就通过反射调用方法并将返回值放入缓存中。

   ```java
   @Cacheable(cacheNames = "userCache", key = "#id")
   @GetMapping
   public User getById(Long id) {
       User user = userMapper.getById(id);
       return user;
   }
   ```

3. `@CacheEvict(cacheNames = "userCache", key = "#id")`：将缓存中的userCache::id数据删除

   ```java
   @CacheEvict(cacheNames = "userCache", key = "#id")
   @DeleteMapping
   public void deleteById(Long id) {
       userMapper.deleteById(id);
   }
   ```

4. `@CacheEvict(cacheNames = "userCache",allEntries = true)`：将缓存中所有的userCache::键值对数据删除

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240601131743504-1289630590.png" alt="image-20240601131742789" style="zoom:33%;" />

   ```java
   @CacheEvict(cacheNames = "userCache",allEntries = true)
   @DeleteMapping("/delAll")
   public void deleteAll() {
       userMapper.deleteAll();
   }
   ```

## 缓存套餐

### 代码实现思路

1. 导入springCache和redis相关的maven坐标

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-data-redis</artifactId>
   </dependency>
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-cache</artifactId>
   </dependency>
   ```

2. 开启注解功能，在启动类上加入注解

   ```java
   @EnableCaching
   ```

3. 在用户端接口的List方法上加入注解

   ```java
   //key:setmealCache::100
   @Cacheable(cacheNames = "setmealCache", key = "#categoryId")
   @GetMapping("/list")
   @ApiOperation("根据分类id查询套餐")
   public Result<List<Setmeal>> list(Long categoryId) {
       Setmeal setmeal = new Setmeal();
       setmeal.setCategoryId(categoryId);
       setmeal.setStatus(StatusConstant.ENABLE);
   
       List<Setmeal> list = setmealService.list(setmeal);
       return Result.success(list);
   }
   ```

4. 在管理端接口SetmealController的方法上加入注解

   ```java
   //新增时
   @CacheEvict(cacheNames = "setmealCache" ,key = "#setmealDTO.categoryId")
   //删除/修改时
   @CacheEvict(cacheNames = "setmealCache", allEntries = true)
   ```

## 添加购物车

### 需求分析

接口路径：POST/user/shoppingCart/add

请求参数

Headers：

| 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
| :----------- | :--------------- | :------- | :--- | :--- |
| Content-Type | application/json | 是       |      |      |

Body:

| 名称       | 类型    | 是否必须 | 默认值 | 备注   | 其他信息          |
| :--------- | :------ | :------- | :----- | :----- | :---------------- |
| dishFlavor | string  | 非必须   |        | 口味   |                   |
| dishId     | integer | 非必须   |        | 菜品id | **format:** int64 |
| setmealId  | integer | 非必须   |        | 套餐id | **format:** int64 |

返回数据

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息          |
| :--- | :------ | :------- | :----- | :--- | :---------------- |
| code | integer | 必须     |        |      | **format:** int32 |
| data | string  | 非必须   |        |      |                   |
| msg  |         |          |        |      |                   |

### 代码实现

1. Controller

   ```java
   @RestController
   @RequestMapping("/user/shoppingCart")
   @Slf4j
   @Api(tags = "C端购物车相关接口")
   public class ShoppingCartController {
   
       @Autowired
       private ShoppingCartService shoppingCartService;
   
       @PostMapping("/add")
       @ApiOperation("添加购物车")
       public Result add(@RequestBody ShoppingCartDTO shoppingCartDTO) {
           log.info("添加购物车：{}", shoppingCartDTO);
   
           shoppingCartService.addShoppingCart(shoppingCartDTO);
   
           return Result.success();
       }
   }
   ```

2. Service

   ```java
   public interface ShoppingCartService {
       void addShoppingCart(ShoppingCartDTO shoppingCartDTO);
   }
   ```

   ```java
   @Service
   @Slf4j
   public class ShoppingCartServiceImpl implements ShoppingCartService {
       @Autowired
       private ShoppingCartMapper shoppingCartMapper;
       @Autowired
       private DishMapper dishMapper;
       @Autowired
       private SetmealMapper setmealMapper;
   
       @Override
       public void addShoppingCart(ShoppingCartDTO shoppingCartDTO) {
           //1.判断加入购物车的商品是否已经存在
           ShoppingCart shoppingCart = new ShoppingCart();
           BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
           Long userId = BaseContext.getCurrentId();
           shoppingCart.setUserId(userId);
   
           List<ShoppingCart> list = shoppingCartMapper.list(shoppingCart);
   
           //2.如果存在，更新Count
           if (list != null && list.size() > 0) {
               ShoppingCart cart = list.get(0);
               cart.setNumber(cart.getNumber() + 1);
               shoppingCartMapper.updateNumberById(cart);
           } else {
               //3.如果不存在，插入数据
   
               //判断添加的是菜品还是套餐
               Long dishId = shoppingCartDTO.getDishId();
               if (dishId != null) {
                   //添加菜品
                   Dish dish = dishMapper.getById(dishId);
                   shoppingCart.setName(dish.getName());
                   shoppingCart.setImage(dish.getImage());
                   shoppingCart.setAmount(dish.getPrice());
               } else {
                   //添加的是套餐
                   Setmeal setmeal = setmealMapper.querySetmealById(shoppingCartDTO.getSetmealId());
                   shoppingCart.setName(setmeal.getName());
                   shoppingCart.setImage(setmeal.getImage());
                   shoppingCart.setAmount(setmeal.getPrice());
               }
               shoppingCart.setNumber(1);
               shoppingCart.setCreateTime(LocalDateTime.now());
               shoppingCartMapper.insert(shoppingCart);
           }
       }
   }
   ```

3. mapper

   ```java
   @Mapper
   public interface ShoppingCartMapper {
   
       List<ShoppingCart> list(ShoppingCart shoppingCart);
   
       @Update("update shopping_cart set number = #{number}  where id=#{id} ")
       void updateNumberById(ShoppingCart shoppingCart);
   
       @Insert("insert into shopping_cart (name, image, user_id, dish_id, setmeal_id, dish_flavor, number, amount, create_time) " +
               "values (#{name} ,#{image},#{userId} ,#{dishId} ,#{setmealId} ,#{dishFlavor} ,#{number},#{amount} ,#{createTime} )")
       void insert(ShoppingCart shoppingCart);
   }
   ```

   ```xml
   <select id="list" resultType="com.sky.entity.ShoppingCart">
       select *
       from shopping_cart
       <where>
           <if test="userId!=null">
               and user_id=#{userId}
           </if>
           <if test="setmealId!=null">
               and setmeal_id=#{setmealId}
           </if>
           <if test="dishId!=null">
               and dish_id=#{dishId}
           </if>
           <if test="dishFlavor!=null">
               and dishFlavor=#{dishFlavor}
           </if>
       </where>
   </select>
   ```

### 测试

1. 添加套餐
2. 添加菜品
3. 添加不同口味的菜品
4. 添加同一种菜品

## 查看购物车

### 需求分析

**Path：**GET： /user/shoppingCart/list

返回数据

| 名称          | 类型      | 是否必须 | 默认值 | 备注 | 其他信息          |
| ------------- | --------- | -------- | ------ | ---- | ----------------- |
| code          | integer   | 必须     |        |      | format: int32     |
| data          | object [] | 非必须   |        |      | item 类型: object |
| ├─ amount     | number    | 非必须   |        |      |                   |
| ├─ createTime | string    | 非必须   |        |      | format: date-time |
| ├─ dishFlavor | string    | 非必须   |        |      |                   |
| ├─ dishId     | integer   | 非必须   |        |      | format: int64     |
| ├─ id         | integer   | 非必须   |        |      | format: int64     |
| ├─ image      | string    | 非必须   |        |      |                   |
| ├─ name       | string    | 非必须   |        |      |                   |
| ├─ number     | integer   | 非必须   |        |      | format: int32     |
| ├─ setmealId  | integer   | 非必须   |        |      | format: int64     |
| ├─ userId     | integer   | 非必须   |        |      | format: int64     |
| msg           | string    | 非必须   |        |      |                   |

### 代码实现

1. Controller

   ```java
   @GetMapping("/list")
   @ApiOperation("查看购物车")
   public Result<List<ShoppingCart>> list(){
       List<ShoppingCart> lists=shoppingCartService.showShoppingCart();
       return Result.success(lists);
   }
   ```

2. Service

   ```java
   List<ShoppingCart> showShoppingCart();
   ```

   ```java
   @Override
   public List<ShoppingCart> showShoppingCart() {
       Long currentId = BaseContext.getCurrentId();
       ShoppingCart shoppingCart = ShoppingCart.builder()
               .id(currentId)
               .build();
       List<ShoppingCart> list = shoppingCartMapper.list(shoppingCart);
       return list;
   }
   ```

## 清空购物车

### 需求分析

**Path：** DELETE：/user/shoppingCart/clean

返回数据

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息      |
| ---- | ------- | -------- | ------ | ---- | ------------- |
| code | integer | 必须     |        |      | format: int32 |
| data | string  | 非必须   |        |      |               |
| msg  | string  | 非必须   |        |      |               |

### 代码实现

1. Controller

   ```java
   @DeleteMapping("/clean")
       @ApiOperation("清空购物车")
       public Result clean() {
           shoppingCartService.cleanShoppingCart();
           return Result.success();
       }
   }
   ```

2. Service

   ```java
   @Override
   public void cleanShoppingCart() {
       Long currentId = BaseContext.getCurrentId();
   
       shoppingCartMapper.deleteByUserId(currentId);
   }
   ```

3. Mapper

   ```java
   @Delete("delete from shopping_cart where user_id=#{currentId} ")
   void deleteByUserId(Long currentId);
   ```

## 删除一个商品

Controller

```java
@PostMapping("/sub")
@ApiOperation("删除购物车中的一个商品")
public Result sub(@RequestBody ShoppingCartDTO shoppingCartDTO) {
    shoppingCartService.sub(shoppingCartDTO);
    return Result.success();
}
```

Service

```java
@Override
public void sub(ShoppingCartDTO shoppingCartDTO) {
    ShoppingCart shoppingCart = new ShoppingCart();
    BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
    shoppingCart.setUserId(BaseContext.getCurrentId());

    List<ShoppingCart> list = shoppingCartMapper.list(shoppingCart);
    if (list != null && list.size() > 0) {
        shoppingCart = list.get(0);
        Integer number = shoppingCart.getNumber();
        if (number == 1) {
            shoppingCartMapper.deleteById(shoppingCart.getId());
        } else {
            shoppingCart.setNumber(number - 1);
            shoppingCartMapper.updateNumberById(shoppingCart);
        }
    }
}
```

Mapper

```java
@Delete("delete from shopping_cart where id=#{id} ")
void deleteById(Long id);
```

# 用户下单和订单支付

## 导入地址簿功能代码

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240601173124209-1195025480.png" alt="image-20240601173123448" style="zoom: 33%;" />

## 用户下单

### 需求分析

**Path：**POST /user/order/submit 

请求参数

Headers

| 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
| ------------ | ---------------- | -------- | ---- | ---- |
| Content-Type | application/json | 是       |      |      |

Body

| 名称                  | 类型    | 是否必须 | 默认值 | 备注                                     | 其他信息      |
| --------------------- | ------- | -------- | ------ | ---------------------------------------- | ------------- |
| addressBookId         | integer | 必须     |        | 地址簿id                                 | format: int64 |
| amount                | number  | 必须     |        | 总金额                                   |               |
| deliveryStatus        | integer | 必须     |        | 配送状态：  1立即送出  0选择具体时间     | format: int32 |
| estimatedDeliveryTime | string  | 必须     |        | 预计送达时间                             |               |
| packAmount            | integer | 必须     |        | 打包费                                   | format: int32 |
| payMethod             | integer | 必须     |        | 付款方式                                 | format: int32 |
| remark                | string  | 必须     |        | 备注                                     |               |
| tablewareNumber       | integer | 必须     |        | 餐具数量                                 | format: int32 |
| tablewareStatus       | integer | 必须     |        | 餐具数量状态  1按餐量提供  0选择具体数量 | format: int32 |

返回数据

| 名称           | 类型    | 是否必须 | 默认值 | 备注     | 其他信息          |
| -------------- | ------- | -------- | ------ | -------- | ----------------- |
| code           | integer | 必须     |        |          | format: int32     |
| data           | object  | 必须     |        |          |                   |
| ├─ id          | integer | 必须     |        | 订单id   | format: int64     |
| ├─ orderAmount | number  | 必须     |        | 订单金额 |                   |
| ├─ orderNumber | string  | 必须     |        | 订单号   |                   |
| ├─ orderTime   | string  | 必须     |        | 下单时间 | format: date-time |
| msg            | string  | 非必须   |        |          |                   |

### 代码开发

1. Controller

   ```java
   @RestController("userOrderController")
   @RequestMapping("/user/order")
   @Slf4j
   @Api(tags = "用户端订单相关接口")
   public class OrderController {
   
       @Autowired
       private OrderService orderService;
   
       @PostMapping("/submit")
       @ApiOperation("用户下单")
       public Result<OrderSubmitVO> submitOrder(@RequestBody OrdersSubmitDTO ordersSubmitDTO) {
           log.info("用户下单的参数为:{}", ordersSubmitDTO);
           OrderSubmitVO orderSubmitVO = orderService.submitOrder(ordersSubmitDTO);
           return Result.success(orderSubmitVO);
       }
   
   }
   ```

2. Service

   ```java
   @Service
   public class OrderServiceImpl implements OrderService {
       @Autowired
       private OrderMapper orderMapper;
       @Autowired
       private OrderDetailMapper orderDetailMapper;
       @Autowired
       private AddressBookMapper addressBookMapper;
       @Autowired
       private ShoppingCartMapper shoppingCartMapper;
   
       @Override
       @Transactional
       public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) {
           //1.处理业务异常
           //地址簿为空
           AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
           if (addressBook == null) {
               throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
           }
   
           //购物车数据为空
           Long currentId = BaseContext.getCurrentId();
           ShoppingCart shoppingCart = ShoppingCart.builder()
                   .id(currentId)
                   .build();
           List<ShoppingCart> shoppingCartList = shoppingCartMapper.list(shoppingCart);
           if (shoppingCartList == null || shoppingCartList.size() == 0) {
               throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
           }
   
           //2.向订单表插入一条数据
           Orders orders = new Orders();
           BeanUtils.copyProperties(ordersSubmitDTO, orders);
           orders.setOrderTime(LocalDateTime.now());
           orders.setPayStatus(Orders.UN_PAID);
           orders.setStatus(Orders.PENDING_PAYMENT);
           orders.setNumber(String.valueOf(System.currentTimeMillis()));
           orders.setPhone(addressBook.getPhone());
           orders.setConsignee(addressBook.getConsignee());
           orders.setUserId(currentId);
   
           orderMapper.insert(orders);
   
           //3.向订单明细表插入N条数据
           List<OrderDetail> orderDetailList = new ArrayList<>();
           for (ShoppingCart cart : shoppingCartList) {
               OrderDetail orderDetail = new OrderDetail();
               BeanUtils.copyProperties(cart, orderDetail);
               orderDetail.setOrderId(orders.getId());
               orderDetailList.add(orderDetail);
           }
           orderDetailMapper.insertBatch(orderDetailList);
   
           //4.下单后，清空购物车
           shoppingCartMapper.deleteByUserId(currentId);
   
           //5.封装VO返回结果
           OrderSubmitVO submitVO = OrderSubmitVO.builder()
                   .id(orders.getId())
                   .orderTime(orders.getOrderTime())
                   .orderNumber(orders.getNumber())
                   .orderAmount(orders.getAmount())
                   .build();
           return submitVO;
       }
   }
   ```

3. Mapper

   OrderMapper

   ```java
   void insert(Orders orders);
   ```

   ```xml
   <insert id="insert" useGeneratedKeys="true" keyProperty="id">
       insert into orders (number, user_id, address_book_id, order_time, checkout_time, amount, remark, phone, address,
                           user_name, consignee, cancel_reason, rejection_reason, cancel_time, estimated_delivery_time,
                           delivery_time, pack_amount, tableware_number)
       values (#{number}, #{userId}, #{addressBookId}, #{orderTime}, #{checkoutTime}, #{amount}, #{remark}, #{phone},
               #{address},
               #{userName}, #{consignee}, #{cancelReason}, #{rejectionReason}, #{cancelTime}, #{estimatedDeliveryTime},
               #{deliveryTime}, #{packAmount}, #{tablewareNumber});
   </insert>
   ```

   OrderDetailMapper

   ```java
   void insertBatch(List<OrderDetail> orderDetailList);
   ```

   ```xml
   <insert id="insertBatch">
       insert into order_detail (name, image, order_id, dish_id, setmeal_id, dish_flavor,number, amount)
       values
       <foreach collection="orderDetailList" item="orderDetail" separator=",">
           (#{orderDetail.name},#{orderDetail.image},#{orderDetail.orderId},#{orderDetail.dishId},#{orderDetail.setmealId},#{orderDetail.dishFlavor},#{orderDetail.number},#{orderDetail.amount})
       </foreach>
   </insert>
   ```

## 订单支付

### 内网穿透-cpolar

内网穿透

- 内网穿透简单来说就是将你电脑访问和别人电脑访问通过某种工具隧道打通，让内网的数据能在别人的电脑上可以获取。
- 换个说法就是将原本只能在本机上访问的项目网站等，通过内网穿透使得你可以在其他人的网上进行访问。

cpolar是一种安全的内网穿透云服务，它将内网下的本地服务器通过安全隧道暴露至公网。使得公网用户可以正常访问内网服务，是一款内网穿透软件。只需一行命令，就可以将内网站点发布至公网，方便给客户演示。高效调试微信公众号、小程序、对接支付宝网关等云端服务，提高您的编程效率。

- 官网：https://dashboard.cpolar.com/get-started

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240602110749984-2040427947.png" alt="image-20240602110749100" style="zoom:33%;" />

- Windows的连接验证方法：

  ```bash
  cpolar.exe authtoken TOKEN
  #结果
  Authtoken saved to configuration file: C:\Users\32354/.cpolar/cpolar.yml
  ```

- 启动http隧道

  <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240602112341291-426922063.png" alt="image-20240602112340428" style="zoom:33%;" />

  ```bash
  cpolar.exe http 8080
  ```

### 微信支付

- 公众平台：https://pay.weixin.qq.com/static/product/product_index.shtml

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240602103537305-1173723280.png" alt="image-20240602103536350" style="zoom:23%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240602103707947-1411422316.png" alt="image-20240602103707533" style="zoom:23%;" />

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240602120227432-1198759859.png" alt="image-20240602120226815" style="zoom:53%;" />

- 进入小程序下单
- 下单
- 返回订单号等
- 申请微信支付【OrderController-payment】
- 调用微信下单接口【weChatPayUtil.pay()】

### 代码开发

1. 配置支付属性

   ```java
   private String appid; //小程序的appid
   private String secret; //小程序的秘钥
   private String mchid; //商户号
   private String mchSerialNo; //商户API证书的证书序列号
   private String privateKeyFilePath; //商户私钥文件
   private String apiV3Key; //证书解密的密钥
   private String weChatPayCertFilePath; //平台证书
   private String notifyUrl; //支付成功的回调地址
   private String refundNotifyUrl; //退款成功的回调地址
   ```

   ```yaml
   sky:
       wechat:
         appid: ${sky.wechat.appid}
         secret: ${sky.wechat.secret}
         notify-url: ${sky.wechat.notify-url}
         refund-notify-url: ${sky.wechat.refund-notify-url}
   ```

2. Controller

3. Service

4. Mapper

# 订单管理

## 客户端

### 查询历史订单

思路：

1. 接收前端传入的请求参数
2. 利用参数分页
3. 查询所有符合要求的订单信息，放入Page
4. 查询订单的详细信息，放入orderVO
5. 把返回信息放入PageResult

代码：

1. Controller

   ```java
   @GetMapping("/historyOrders")
   @ApiOperation("历史订单查询")
   public Result<PageResult> getOrders(OrdersPageQueryDTO ordersPageQueryDTO) {
       log.info("历史订单查询：{}", ordersPageQueryDTO);
   
       PageResult pageResult = orderService.getOrders(ordersPageQueryDTO);
   
       return Result.success(pageResult);
   }
   ```

2. Service

   ```java
   @Override
   public PageResult getOrders(OrdersPageQueryDTO ordersPageQueryDTO) {
       PageHelper.startPage(ordersPageQueryDTO.getPage(), ordersPageQueryDTO.getPageSize());
   
       Page<Orders> page = orderMapper.getOrders(ordersPageQueryDTO);
       ArrayList<OrderVO> orderVOS = new ArrayList<>();
       if (page != null && page.getTotal() > 0) {
           for (com.sky.entity.Orders orders : page) {
               Long id = orders.getId();
               List<OrderDetail> orderDetails = orderDetailMapper.getByOrderId(id);
               OrderVO orderVO = new OrderVO();
               BeanUtils.copyProperties(orders, orderVO);
               orderVO.setOrderDetailList(orderDetails);
               orderVOS.add(orderVO);
           }
       }
       return new PageResult(page.getTotal(), orderVOS);
   }
   ```

3. Mapper

   ```java
   Page<Orders> getOrders(OrdersPageQueryDTO ordersPageQueryDTO);
   ```

   ```xml
   <select id="getOrders" resultType="orders">
       select *
       from orders
       <where>
           <if test="status!=null">
               and status=#{status}
           </if>
           <if test="phone!=null">
               and phone=#{phone}
           </if>
           <if test="number!=null">
               and number=#{number}
           </if>
           <if test="userId!=null">
               and user_id=#{userId}
           </if>
           <if test="beginTime != null">
               and order_time = #{beginTime}
           </if>
           <if test="endTime != null">
               and order_time = #{endTime}
           </if>
       </where>
       order by order_time desc
   </select>
   ```

### 查询订单详情

思路：同上，就是不分页

代码：

1. Controller

   ```java
   @GetMapping("/orderDetail/{id}")
   public Result<OrderVO> getOrderDetail(@PathVariable Long id) {
       log.info("查询订单详情：{}", id);
   
       OrderVO orderVO = orderService.getOrderDetail(id);
   
       return Result.success(orderVO);
   }
   ```

2. Service

   ```java
   @Override
   public OrderVO getOrderDetail(Long id) {
   
       Orders orders = orderMapper.getById(id);
       OrderVO orderVO = new OrderVO();
       BeanUtils.copyProperties(orders, orderVO);
   
       List<OrderDetail> details = orderDetailMapper.getByOrderId(id);
       orderVO.setOrderDetailList(details);
   
       return orderVO;
   }
   ```

3. Mapper

   ```java
   @Select("select * from orders where id=#{id}")
   Orders getById(Long id);
   ```

### 取消订单

思路：

1. 待支付和待接单状态下，用户可直接取消订单
2. 商家已接单状态下，用户取消订单需电话沟通商家
3. 派送中状态下，用户取消订单需电话沟通商家
4. 如果在待接单状态下取消订单，需要给用户退款
5. 取消订单后需要将订单状态修改为“已取消”

代码：

1. Controller

   ```java
   @PutMapping("/cancel/{id}")
   @ApiOperation("取消订单")
   public Result cancelOrder(@PathVariable Long id) {
       log.info("取消订单：{}", id);
       orderService.cancelOrder(id);
       return Result.success();
   }
   ```

2. Service

   ```java
   @Override
       public void cancelOrder(Long id) {
           Orders orders = orderMapper.getById(id);
           //判断订单是否存在
           if (orders == null) {
               throw new OrderBusinessException(MessageConstant.ORDER_NOT_FOUND);
           }
           //判断订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消
           if (orders.getStatus() > 2) {
               //只有待支付和待接单状态下，用户可直接取消订单
               throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
           }
           Orders updateOrders = Orders.builder()
                   .id(orders.getId())
                   .build();
           //待接单状态取消 需要退款
           if (orders.getStatus().equals(Orders.TO_BE_CONFIRMED)) {
               //调用微信支付退款接口
   //            weChatPayUtil.refund(
   //                    orders.getNumber(), //商户订单号
   //                    orders.getNumber(), //商户退款单号
   //                    new BigDecimal(0.01),//退款金额，单位 元
   //                    new BigDecimal(0.01));//原订单金额
   
               updateOrders.setPayStatus(Orders.REFUND);
           }
           updateOrders.setStatus(Orders.CANCELLED);
           updateOrders.setCancelReason("用户取消");
           updateOrders.setCancelTime(LocalDateTime.now());
           orderMapper.update(updateOrders);
       }
   ```

### 再来一单

思路：

1. 再来一单，就是把之前的订单信息再次加入购物车
2. 获取order-Detail信息，转换到购物车对象；
3. 设置购物车对象特有的属性
4. 把购物车对象批量插入数据库

代码：

1. Controller

   ```java
   @PostMapping("/repetition/{id}")
   @ApiOperation("再来一单")
   public Result orderAgain(@PathVariable Long id) {
       log.info("再来一单：{}", id);
       orderService.orderAgain(id);
       return Result.success();
   }
   ```

2. Service

   ```java
   @Override
   public void orderAgain(Long id) {
       //查询订单相关菜品
       List<OrderDetail> details = orderDetailMapper.getByOrderId(id);
   
       // 将订单详情对象转换为购物车对象
       List<ShoppingCart> shoppingCartList = details.stream().map(x -> {
           ShoppingCart shoppingCart = new ShoppingCart();
           BeanUtils.copyProperties(x, shoppingCart, "id");
           shoppingCart.setUserId(BaseContext.getCurrentId());
           shoppingCart.setCreateTime(LocalDateTime.now());
   
           return shoppingCart;
       }).collect(Collectors.toList());
   
       // 将购物车对象批量添加到数据库
       shoppingCartMapper.insertBatch(shoppingCartList);
   }
   ```

3. Mapper

   ```xml
   <insert id="insertBatch">
       insert into shopping_cart (name, image, user_id, dish_id, setmeal_id, dish_flavor, number, amount, create_time)
       values
       <foreach collection="shoppingCartList" item="sc" separator=",">
           (#{sc.name} ,#{sc.image},#{sc.userId} ,#{sc.dishId} ,#{sc.setmealId} ,#{sc.dishFlavor}
           ,#{sc.number},#{sc.amount} ,#{sc.createTime} )
       </foreach>
   </insert>
   ```

## 管理端

### 订单搜索

要求：

1. 输入订单号/手机号进行搜索，支持模糊搜索
2. 根据订单状态进行筛选
3. 下单时间进行时间筛选
4. 搜索内容为空，提示未找到相关订单
5. 搜索结果页，展示包含搜索关键词的内容
6. 分页展示搜索到的订单数据

代码：

1. Controller

   ```java
   @GetMapping("/conditionSearch")
   @ApiOperation("订单搜索")
   public Result<PageResult> OrderSearch(OrdersPageQueryDTO ordersPageQueryDTO) {
       log.info("订单搜索：{}", ordersPageQueryDTO);
   
       PageResult historyOrders = orderService.orderSearch(ordersPageQueryDTO);
       return Result.success(historyOrders);
   }
   ```

2. Service

   ```java
   PageResult orderSearch(OrdersPageQueryDTO ordersPageQueryDTO);
   ```

   ```java
   @Override
   public PageResult orderSearch(OrdersPageQueryDTO ordersPageQueryDTO) {
       PageHelper.startPage(ordersPageQueryDTO.getPage(), ordersPageQueryDTO.getPageSize());
       Page<Orders> page = orderMapper.getOrders(ordersPageQueryDTO);
   
       List<OrderVO> orderVOList = getOrderVOList(page);
       return new PageResult(page.getTotal(), orderVOList);
   }
   
   private List<OrderVO> getOrderVOList(Page<Orders> page) {
       List<OrderVO> orderVOList = new ArrayList<>();
   
       List<Orders> result = page.getResult();
       if (!CollectionUtils.isEmpty(result)) {
           for (Orders orders : result) {
               OrderVO orderVO = new OrderVO();
               BeanUtils.copyProperties(orders, orderVO);
               String orderDishesStr = getOrderDishesStr(orders);
   
               orderVO.setOrderDishes(orderDishesStr);
               orderVOList.add(orderVO);
           }
       }
       return orderVOList;
   }
   
   private String getOrderDishesStr(Orders orders) {
       //查询菜品详情
       List<OrderDetail> details = orderDetailMapper.getByOrderId(orders.getId());
       // 将每一条订单菜品信息拼接为字符串（格式：宫保鸡丁*3；）
       List<String> orderDishList = details.stream().map(x -> {
           String orderDish = x.getName() + "*" + x.getNumber() + ";";
           return orderDish;
       }).collect(Collectors.toList());
   
       // 将该订单对应的所有菜品信息拼接在一起
       return String.join("", orderDishList);
   }
   ```

优化：查询订单号和手机号应该模糊查询

测试：

1. 生成8081端口的隧道
2. 访问该网址

### 各个状态的订单数量统计

代码：

1. Controller

   ```java
   @GetMapping("/statistics")
   @ApiOperation("各个状态的订单数量统计")
   public Result<OrderStatisticsVO> staticsOrder() {
       log.info("各个状态的订单数量统计");
       OrderStatisticsVO orderStatisticsVO = orderService.staticsOrder();
       return Result.success(orderStatisticsVO);
   }
   ```

2. Service

   ```java
   @Override
   public OrderStatisticsVO staticsOrder() {
       Integer confirmed = orderMapper.queryOrdersByStatus(Orders.CONFIRMED);
       Integer deliveryInProgress = orderMapper.queryOrdersByStatus(Orders.DELIVERY_IN_PROGRESS);
       Integer toBeConfirmed = orderMapper.queryOrdersByStatus(Orders.TO_BE_CONFIRMED);
   
       OrderStatisticsVO orderStatisticsVO = new OrderStatisticsVO();
       orderStatisticsVO.setConfirmed(confirmed);
       orderStatisticsVO.setDeliveryInProgress(deliveryInProgress);
       orderStatisticsVO.setToBeConfirmed(toBeConfirmed);
       return orderStatisticsVO;
   }
   ```

3. Mapper

   直接查询出来数量

   ```java
   @Select("select count(id) from orders where status=#{status}")
   Integer queryOrdersByStatus(Integer status);
   ```

### 查询订单详情

延用客户端的查看订单详情

```java
@GetMapping("/details/{id}")
@ApiOperation("查询订单详情 ")
public Result<OrderVO> queryOrder(@PathVariable Long id) {
    log.info("查询订单详情 ：{}", id);

    OrderVO orderVO = orderService.getOrderDetail(id);

    return Result.success(orderVO);
}
```

### 接单

1. Controller

   ```java
   @PutMapping("/confirm")
   @ApiOperation("接单")
   public Result confirmOrder(@RequestBody OrdersConfirmDTO ordersConfirmDTO) {
       log.info("接单：{}", ordersConfirmDTO);
       orderService.confirm(ordersConfirmDTO);
       return Result.success();
   }
   ```

2. Service

   ```java
   @Override
   public void confirm(OrdersConfirmDTO ordersConfirmDTO) {
       Orders orders = Orders.builder()
               .id(ordersConfirmDTO.getId())
               .status(Orders.CONFIRMED)
               .build();
       orderMapper.update(orders);
   }
   ```

### 拒单

思路：

1. 商家拒单其实就是将订单状态修改为“已取消”
2. 只有订单处于“待接单”状态时可以执行拒单操作
3. 商家拒单时需要指定拒单原因
4. 商家拒单时，如果用户已经完成了支付，需要为用户退款

代码：

1. Controller

   ```java
   @PutMapping("/rejection")
   @ApiOperation("拒单")
   public Result rejectionOrder(@RequestBody OrdersRejectionDTO ordersRejectionDTO) {
       log.info("拒单：{}", ordersRejectionDTO);
       orderService.rejection(ordersRejectionDTO);
       return Result.success();
   }
   ```

2. Service

   ```java
   @Override
       public void rejection(OrdersRejectionDTO ordersRejectionDTO) {
           Orders orders = orderMapper.getById(ordersRejectionDTO.getId());
   
           // 订单只有存在且状态为2（待接单）才可以拒单
           if (orders == null || !orders.getStatus().equals(Orders.TO_BE_CONFIRMED)) {
               throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
           }
   
   //        Integer payStatus = orders.getPayStatus();
   //        if (payStatus == Orders.PAID) {
   //            //用户已支付，需要退款
   //            String refund = weChatPayUtil.refund(
   //                    ordersDB.getNumber(),
   //                    ordersDB.getNumber(),
   //                    new BigDecimal(0.01),
   //                    new BigDecimal(0.01));
   //            log.info("申请退款：{}", refund);
   //        }
   
           Orders updateOrders = new Orders();
           updateOrders.setId(ordersRejectionDTO.getId());
           updateOrders.setStatus(Orders.CANCELLED);
           updateOrders.setRejectionReason(ordersRejectionDTO.getRejectionReason());
           updateOrders.setCancelTime(LocalDateTime.now());
   
           orderMapper.update(updateOrders);
       }
   ```

### 取消订单

思路：

1. 取消订单其实就是将订单状态修改为“已取消”
2. 商家取消订单时需要指定取消原因
3. 商家取消订单时，如果用户已经完成了支付，需要为用户退款

```java
@Override
public void cancel(OrdersCancelDTO ordersCancelDTO) {
    Orders orders = orderMapper.getById(ordersCancelDTO.getId());

    //        Integer payStatus = orders.getPayStatus();
    //        if (payStatus == Orders.PAID) {
    //            //用户已支付，需要退款
    //            String refund = weChatPayUtil.refund(
    //                    ordersDB.getNumber(),
    //                    ordersDB.getNumber(),
    //                    new BigDecimal(0.01),
    //                    new BigDecimal(0.01));
    //            log.info("申请退款：{}", refund);
    //        }

    Orders updateOrders = new Orders();
    updateOrders.setId(ordersCancelDTO.getId());
    updateOrders.setStatus(Orders.CANCELLED);
    updateOrders.setRejectionReason(ordersCancelDTO.getCancelReason());
    updateOrders.setCancelTime(LocalDateTime.now());

    orderMapper.update(updateOrders);
}
```

### 派送订单

```java
@Override
public void delivery(Long id) {
    // 根据id查询订单
    Orders ordersDB = orderMapper.getById(id);

    // 校验订单是否存在，并且状态为3
    if (ordersDB == null || !ordersDB.getStatus().equals(Orders.CONFIRMED)) {
        throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
    }

    Orders orders = new Orders();
    orders.setId(ordersDB.getId());
    // 更新订单状态,状态转为派送中
    orders.setStatus(Orders.DELIVERY_IN_PROGRESS);

    orderMapper.update(orders);
}
```

### 完成订单

```java
@Override
public void complete(Long id) {
    // 根据id查询订单
    Orders ordersDB = orderMapper.getById(id);

    // 校验订单是否存在，并且状态为4
    if (ordersDB == null || !ordersDB.getStatus().equals(Orders.DELIVERY_IN_PROGRESS)) {
        throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
    }

    Orders orders = new Orders();
    orders.setId(ordersDB.getId());
    // 更新订单状态,状态转为完成
    orders.setStatus(Orders.COMPLETED);
    orders.setDeliveryTime(LocalDateTime.now());

    orderMapper.update(orders);
}
```

## 校验收货地址

### 环境准备

优化用户下单功能，加入校验逻辑，如果用户的收货地址距离商家门店超出配送范围（配送范围为5公里内），则下单失败。

1. 基于百度地图开放平台实现（https://lbsyun.baidu.com/）

2. 进入控制台--->创建应用获取AK(服务端应用)--->调用接口

   进入控制台，创建应用，获取AK：

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603194237638-557680683.png" alt="image-20221222170049729" style="zoom: 33%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603194237481-456979352.png" alt="image-20221222170256927" style="zoom:33%;" />

3. 相关接口

   https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding

   https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1

4. 商家门店地址可以配置在配置文件中，例如：

~~~yaml
sky:
  shop:
    address: 北京市海淀区上地十街10号
~~~

### 代码开发

1. application.yml

   ```yaml
   sky:
       shop:
         address: ${sky.shop.address}
       baidu:
         ak: ${sky.baidu.ak}
   ```

2. Service

   改造OrderServiceImpl，注入上面的配置项：

   ~~~java
       @Value("${sky.shop.address}")
       private String shopAddress;
   
       @Value("${sky.baidu.ak}")
       private String ak;
   ~~~

   在OrderServiceImpl中提供校验方法：

   ~~~java
   /**
        * 检查客户的收货地址是否超出配送范围
        * @param address
        */
   private void checkOutOfRange(String address) {
       Map map = new HashMap();
       map.put("address",shopAddress);
       map.put("output","json");
       map.put("ak",ak);
   
       //获取店铺的经纬度坐标
       String shopCoordinate = HttpClientUtil.doGet("https://api.map.baidu.com/geocoding/v3", map);
   
       JSONObject jsonObject = JSON.parseObject(shopCoordinate);
       if(!jsonObject.getString("status").equals("0")){
           throw new OrderBusinessException("店铺地址解析失败");
       }
   
       //数据解析
       JSONObject location = jsonObject.getJSONObject("result").getJSONObject("location");
       String lat = location.getString("lat");
       String lng = location.getString("lng");
       //店铺经纬度坐标
       String shopLngLat = lat + "," + lng;
   
       map.put("address",address);
       //获取用户收货地址的经纬度坐标
       String userCoordinate = HttpClientUtil.doGet("https://api.map.baidu.com/geocoding/v3", map);
   
       jsonObject = JSON.parseObject(userCoordinate);
       if(!jsonObject.getString("status").equals("0")){
           throw new OrderBusinessException("收货地址解析失败");
       }
   
       //数据解析
       location = jsonObject.getJSONObject("result").getJSONObject("location");
       lat = location.getString("lat");
       lng = location.getString("lng");
       //用户收货地址经纬度坐标
       String userLngLat = lat + "," + lng;
   
       map.put("origin",shopLngLat);
       map.put("destination",userLngLat);
       map.put("steps_info","0");
   
       //路线规划
       String json = HttpClientUtil.doGet("https://api.map.baidu.com/directionlite/v1/driving", map);
   
       jsonObject = JSON.parseObject(json);
       if(!jsonObject.getString("status").equals("0")){
           throw new OrderBusinessException("配送路线规划失败");
       }
   
       //数据解析
       JSONObject result = jsonObject.getJSONObject("result");
       JSONArray jsonArray = (JSONArray) result.get("routes");
       Integer distance = (Integer) ((JSONObject) jsonArray.get(0)).get("distance");
   
       if(distance > 5000){
           //配送距离超过5000米
           throw new OrderBusinessException("超出配送范围");
       }
   }
   ~~~

   在OrderServiceImpl的submitOrder方法中调用上面的校验方法：

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603195656233-490693054.png" alt="image-20221222171444981" style="zoom:50%;" />

# 订单状态定时处理、来单提醒和客户催单

## SpringTask

### 简介

Spring Task是Spring框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑。

- 定位：定时任务框架
- 作用：定时自动执行某段Java代码
- 应用场景: 只要是需要定时处理的场景都可以使用spring Task
  - 信用卡每月还款提醒
  - 银行贷款每月还款提醒
  - 火车票售票系统处理未支付订单
  - 入职纪念日为用户发送通知

### cron表达式

cron表达式其实就是一个字符串，通过cron表达式可以定义任务触发的时间

- 构成规则：分为6或7个域，由空格分隔开，每个域代表一个含义。

  - 日和周互斥，构造时只有六个域

- 每个域的含义分别为:秒、分钟、小时、日、月、周、年(可选)

  2022年10月12日上午9点整对应的cron表达式为：0 0 9 12 10 ? 2022

  <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240602195408847-94802215.png" alt="image-20240602195408225" style="zoom:50%;" />

- 还有特殊字符
- 可以在线生成表达式：https://cron.qqe2.com/

### 使用步骤

1. 导入Maven坐标，包含在spring-context中(已存在)

2. 启动类添加注解

   ```java
   @EnableScheduling	//开启任务调度
   ```

3. 自定义定时任务类

   ```java
   @Component	//需要注入到容器中
   @Slf4j
   public class MyTask {
       /**
        * 定时任务：从第0秒开始每隔五秒钟触发一次
        */
       @Scheduled(cron = "0/5 * * * * ?")
       public void executeTask() {//无返回值
           log.info("定时任务开始执行：{}", new Date());
       }
   }
   ```

## 订单状态定时处理

### 需求分析

问题：

1. 下单后未支付，一直处于待支付状态
2. 用户收货后管理端未点击完成按钮，订单一直处于派送中状态

解决：

1. 定时任务每分钟检查一次是否存在超时订单【下单后超过15分钟仍未支付】，如果存在就取消订单
2. 每天凌晨一点检查一次是否存在派送中的订单，如果存在就修改订单状态为已完成

### 代码实现

```java
@Component
@Slf4j
public class OrderTask {
    @Autowired
    private OrderMapper orderMapper;

    /**
     * 处理超时订单
     */
    @Scheduled(cron = "0 * * * * ? ")   //每分钟一次
    public void processTimeoutOrder() {
        log.info("定时处理超时订单：{}", LocalDateTime.now());

        List<Orders> list = orderMapper.getByStatusAndOrderTimeLT(Orders.PENDING_PAYMENT, LocalDateTime.now().plusMinutes(-15));

        if (list != null && list.size() > 0) {
            for (Orders order : list) {
                order.setStatus(Orders.CANCELLED);
                order.setCancelReason("订单超时，自动取消");
                order.setCancelTime(LocalDateTime.now());
                orderMapper.update(order);
            }
        }
    }

    /**
     * 处理一直处于派送中的订单
     */
    @Scheduled(cron = "0 0 1 * * ? ")   //每天凌晨一点一次
    public void processDeliveryOrder() {
        log.info("定时处理一直处于派送中的订单：{}", LocalDateTime.now());

        List<Orders> list = orderMapper.getByStatusAndOrderTimeLT(Orders.DELIVERY_IN_PROGRESS, LocalDateTime.now().plusHours(-1));
        if (list != null && list.size() > 0) {
            for (Orders order : list) {
                order.setStatus(Orders.COMPLETED);
                orderMapper.update(order);
            }
        }
    }
}
```

## WebSocket

### 简介

WebSocket是基于TCP的一种新的网络协议。它实现了浏览器与服务器`全双工通信`——浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。

HTTP协议和WebSocket协议对比:

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603082540023-125479024.png" alt="image-20240603082539779" style="zoom:50%;" />

- 请求URL

  ```java
  //协议标识符是ws（如果加密，则为wss），服务器网址就是 URL
  ws://example.com:80/some/path
  ```

- HTTP是短连接，响应完之后就不连接的。WebSocket是长连接，创建持久性的连接。

- HTTP通信是单向的，基于请求响应模式。WebSocket支持双向通信

- HTTP和WebSocket底层都是TCP连接

应用场景:

- 视频弹幕
- 网页聊天
- 体育实况更新
- 股票基金报价实时更新

### 使用步骤

1. 使用html页面作为WebSocket的客户端

   ```html
   <!DOCTYPE HTML>
   <html>
   <head>
       <meta charset="UTF-8">
       <title>WebSocket Demo</title>
   </head>
   <body>
       <input id="text" type="text" />
       <button onclick="send()">发送消息</button>
       <button onclick="closeWebSocket()">关闭连接</button>
       <div id="message">
       </div>
   </body>
   <script type="text/javascript">
       var websocket = null;
       var clientId = Math.random().toString(36).substr(2);
   
       //判断当前浏览器是否支持WebSocket
       if('WebSocket' in window){
           //连接WebSocket节点
           websocket = new WebSocket("ws://localhost:8080/ws/"+clientId);
       }
       else{
           alert('Not support websocket')
       }
   
       //连接发生错误的回调方法
       websocket.onerror = function(){
           setMessageInnerHTML("error");
       };
   
       //连接成功建立的回调方法
       websocket.onopen = function(){
           setMessageInnerHTML("连接成功");
       }
   
       //接收到消息的回调方法
       websocket.onmessage = function(event){
           setMessageInnerHTML(event.data);
       }
   
       //连接关闭的回调方法
       websocket.onclose = function(){
           setMessageInnerHTML("close");
       }
   
       //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
       window.onbeforeunload = function(){
           websocket.close();
       }
   
       //将消息显示在网页上
       function setMessageInnerHTML(innerHTML){
           document.getElementById('message').innerHTML += innerHTML + '<br/>';
       }
   
       //发送消息
       function send(){
           var message = document.getElementById('text').value;
           websocket.send(message);
       }
   	
   	//关闭连接
       function closeWebSocket() {
           websocket.close();
       }
   </script>
   </html>
   ```

   

2. 导入Maven坐标

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-websocket</artifactId>
   </dependency>
   ```

3. 导入WebSocket的服务端组件WebSocketServer，用于和客户端通信

   ```java
   /**
    * WebSocket服务
    */
   @Component	//交给spring容器中
   @ServerEndpoint("/ws/{sid}")	// 标识了一个 WebSocket 服务器端点，可以处理客户端连接到 /ws/{sid} 路径的请求
   public class WebSocketServer {
   
       //存放会话对象 WebSocket的Session
       private static Map<String, Session> sessionMap = new HashMap();
   
       /**
        * 连接建立成功调用的方法
        */
       @OnOpen	//注解是WebSocket里的
       public void onOpen(Session session, @PathParam("sid") String sid) {
           System.out.println("客户端：" + sid + "建立连接");
           sessionMap.put(sid, session);
       }
   
       /**
        * 收到客户端消息后调用的方法
        *
        * @param message 客户端发送过来的消息
        */
       @OnMessage
       public void onMessage(String message, @PathParam("sid") String sid) {
           System.out.println("收到来自客户端：" + sid + "的信息:" + message);
       }
   
       /**
        * 连接关闭调用的方法
        *
        */
       @OnClose
       public void onClose(@PathParam("sid") String sid) {
           System.out.println("连接断开:" + sid);
           sessionMap.remove(sid);
       }
   
       /**
        * 群发
        *
        */
       public void sendToAllClient(String message) {
           Collection<Session> sessions = sessionMap.values();
           for (Session session : sessions) {
               try {
                   //服务器向客户端发送消息
                   session.getBasicRemote().sendText(message);
               } catch (Exception e) {
                   e.printStackTrace();
               }
           }
       }
   }
   ```

4. 导入配置类WebSocketConfiguration，注册WebSocket的服务端组件

   ```java
   /**
    * WebSocket配置类，用于注册WebSocket的Bean
    */
   @Configuration
   public class WebSocketConfiguration {
       @Bean
       public ServerEndpointExporter serverEndpointExporter() {
           return new ServerEndpointExporter();
       }
   }
   ```

5. 【测试用】导入定时任务类WenSocketTask，定时向客户端推送数据。

   ```java
   @Component
   public class WebSocketTask {
       @Autowired
       private WebSocketServer webSocketServer;
   
       /**
        * 通过WebSocket每隔5秒向客户端发送消息
        */
       @Scheduled(cron = "0/5 * * * * ?")
       public void sendMessageToClient() {
           webSocketServer.sendToAllClient("这是来自服务端的消息：" + DateTimeFormatter.ofPattern("HH:mm:ss").format(LocalDateTime.now()));
       }
   }
   ```

## 来单提醒

### 需求分析

1. 通过WebSocket实现管理端页面和服务端保持长连接状态
2. 当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息
3. 客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的 信息提示和语音播报
4. 约定服务端发送给客户端的数据格式为JSON，字段包括：type消息类型-1是来单提醒/2是客户催单、orderId订单Id、content消息内容

### 代码实现

【注意】如果修改过Nginx的端口号，此时要去nginx的安装目录/html/sky/js/app. **** .js文件中，ctrl+F查找 ws: localhost/ws/  ，然后修改成 ws: localhost:8080/ws/，然后重启生效。此时我的设置是：后端TomCat-8080、Nginx监听8081

```properties
#nginx.conf
worker_processes  1;

events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    
    keepalive_timeout  65;
	
	map $http_upgrade $connection_upgrade{
		default upgrade;
		'' close;
	}

	upstream webservers{
	  server 127.0.0.1:8080 weight=90 ;
	  #server 127.0.0.1:8088 weight=10 ;
	}

    server {
        listen       8081;
        server_name  localhost;

        location / {
            root   html/sky;
            index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # 反向代理,处理管理端发送的请求
        location /api/ {
			proxy_pass   http://localhost:8080/admin/;
            #proxy_pass   http://webservers/admin/;
        }
		
		# 反向代理,处理用户端发送的请求
        location /user/ {
            proxy_pass   http://webservers/user/;
        }
		
		# WebSocket
		location /ws/ {
            proxy_pass   http://webservers/ws/;
			proxy_http_version 1.1;
			proxy_read_timeout 3600s;
			proxy_set_header Upgrade $http_upgrade;
			proxy_set_header Connection "$connection_upgrade";
        }
    }

}
```

1. 建立服务端和商家管理页面的长连接

   直接运行上述示例中WebSocket设置的项目，进入前端页面【捕获WebSocket请求，后端输出确认连接】

   - 先请求到了Nginx
   - 然后反向代理请求到了后端

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603102204656-356532205.png" alt="image-20240603102204766" style="zoom: 33%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603102225982-455877295.png" alt="image-20240603102226501" style="zoom:50%;" />

2. 编写来单提醒代码

   ```java
   /**
    * 支付成功，修改订单状态
    * OrderServiceImpl.java
    *
    */
   @Override
   public void paySuccess(String outTradeNo) {
   
       // 根据订单号查询订单
       Orders ordersDB = orderMapper.getByNumber(outTradeNo);
   
       // 根据订单id更新订单的状态、支付方式、支付状态、结账时间
       Orders orders = Orders.builder()
               .id(ordersDB.getId())
               .status(Orders.TO_BE_CONFIRMED)
               .payStatus(Orders.PAID)
               .checkoutTime(LocalDateTime.now())
               .build();
   
       orderMapper.update(orders);
   
       //支付成功后，发送来单提醒  通过WebSocket向客户端浏览器推送消息
       Map map = new HashMap();
       map.put("type", 1);  //1-来单提醒
       map.put("orderId", ordersDB.getId());    //订单Id
       map.put("content", "来单啦！订单号为:" + outTradeNo);  //消息内容
   
       String json = JSONObject.toJSONString(map);
       webSocketServer.sendToAllClient(json);
   }
   ```

3. 【测试】此时用户在小程序下单。

   注意在全局配置中的回调地址，是利用了cpolar的内网穿透来访问的。/会过期，记得更换

4. 商家管理页面语音播报，并弹出提示信息

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603105108897-134825236.png" alt="image-20240603105109200" style="zoom:50%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603105322121-1098509964.png" alt="image-20240603105322427" style="zoom:33%;" />

## 客户催单

### 需求分析

1. 通过WebSocket实现管理端页面和服务端保持长连接状态
2. 当客户催单后，调用WebSocket的相关API实现服务端向客户端推送消息
3. 客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的 信息提示和语音播报
4. 约定服务端发送给客户端的数据格式为JSON，字段包括：type消息类型-1是来单提醒/2是客户催单、orderId订单Id、content消息内容

### 代码实现

1. Controller

   ```java
   @GetMapping("/reminder/{id}")
   @ApiOperation("客户催单")
   public Result reminder(@PathVariable Long id) {
       log.info("客户催单：{}", id);
       orderService.reminder(id);
       return Result.success();
   }
   ```

2. Service

   ```java
   @Override
   public void reminder(Long id) {
       // 根据id查询订单
       Orders ordersDB = orderMapper.getById(id);
   
       // 校验订单是否存在
       if (ordersDB == null) {
           throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
       }
       Map map = new HashMap();
       map.put("type", 2);
       map.put("orderId", id);
       map.put("content", "客户催单啦！订单号为：" + ordersDB.getId());
   
       webSocketServer.sendToAllClient(JSONObject.toJSONString(map));
   }
   ```

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603112123687-1709619189.png" alt="image-20240603112123547" style="zoom:50%;" />

# 数据统计

## Apache ECharts

### 简介

Apache ECharts是一款基于Javascript 的数据可视化图表库。提供直观，生动，可交互，可个性化定制的数据可视化图表。

- 官网地址: https://echarts.apache.org/zh/index.html

总结:

- 使用Echarts，重点在于研究当前图表所需的数据格式。
- 通常是需要后端提供符合格式要求的动态数据，然后响应给前端来展示图表。

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603114512034-1194154056.png" alt="image-20240603114454766" style="zoom: 25%;" />

### 使用步骤

1. 获取 Apache ECharts

   Apache ECharts 支持多种下载方式。以从 jsDelivr CDN 上获取为例：在 https://www.jsdelivr.com/package/npm/echarts 选择 dist/echarts.js，点击并保存为 echarts.js 文件。

   ```html
   <!--CDN-->
   <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js" integrity="sha256-QvgynZibb2U53SsVu98NggJXYqwRL7tg3FeyfXvPOUY=" crossorigin="anonymous"></script>
   <!--或者直接下载添加到项目中-->
   ```

2. 引入 Apache ECharts

   在刚才保存 `echarts.js` 的目录新建一个 `index.html` 文件，内容如下：

   ```html
   <!DOCTYPE html>
   <html>
     <head>
       <meta charset="utf-8" />
       <!-- 引入刚刚下载的 ECharts 文件 -->
       <script src="echarts.js"></script>
     </head>
   </html>
   ```

   打开这个 `index.html`，你会看到一片空白。但是不要担心，打开控制台确认没有报错信息，就可以进行下一步。

3. 绘制一个简单的图表

   在绘图前我们需要为 ECharts 准备一个定义了高宽的 DOM 容器。在刚才的例子 `</head>` 之后，添加：

   ```html
   <body>
     <!-- 为 ECharts 准备一个定义了宽高的 DOM -->
     <div id="main" style="width: 600px;height:400px;"></div>
   </body>
   ```

   然后就可以通过 [echarts.init](https://echarts.apache.org//api.html#echarts.init) 方法初始化一个 echarts 实例并通过 [setOption](https://echarts.apache.org//api.html#echartsInstance.setOption) 方法生成一个简单的柱状图，下面是完整代码。

   ```html
   <!DOCTYPE html>
   <html>
     <head>
       <meta charset="utf-8" />
       <title>ECharts</title>
       <!-- 引入刚刚下载的 ECharts 文件 -->
       <script src="echarts.js"></script>
     </head>
     <body>
       <!-- 为 ECharts 准备一个定义了宽高的 DOM -->
       <div id="main" style="width: 600px;height:400px;"></div>
       <script type="text/javascript">
         //1. 基于准备好的dom，初始化echarts实例
         var myChart = echarts.init(document.getElementById('main'));
   
         //2. 指定图表的配置项和数据
         var option = {
           title: {
             text: 'ECharts 入门示例'
           },
           tooltip: {},
           legend: {
             data: ['销量']	//图例
           },
           xAxis: {//横坐标
             data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
           },
           yAxis: {},
           series: [//纵坐标
             {
               name: '销量',
               type: 'bar',	//柱状图
               data: [5, 20, 36, 10, 10, 20]	//与上面的X坐标一一对应
             }
           ]
         };
   
         // 使用刚指定的配置项和数据显示图表。
         myChart.setOption(option);
       </script>
     </body>
   </html>
   ```

   这样你的第一个图表就诞生了！

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603125721972-1487332283.png" alt="image-20240603125719164" style="zoom: 25%;" />

## 营业额统计

### 需求分析

1. 营业额是已完成订单的金额合计
2. 折线图来展示营业额数据，x轴是日期，y轴是营业额
3. 根据时间选择区间，展示每天的营业额数据

### 代码实现

1. Controller

   ```java
   @RestController
   @RequestMapping("/admin/report")
   @Api(tags = "数据统计相关接口")
   @Slf4j
   public class ReportController {
       @Autowired
       private ReportService reportService;
   
       @GetMapping("/turnoverStatistics")
       @ApiOperation("营业额统计")
       public Result<TurnoverReportVO> turnoverStatistics(@DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate begin,
                                                          @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate end) {
           log.info("营业额统计的日期区间：{}-{}", begin, end);
           return Result.success(reportService.getTurnoverStatistics(begin, end));
       }
   }
   ```

2. Service

   ```java
   @Service
   public class ReportServiceImpl implements ReportService {
       @Autowired
       private OrderMapper orderMapper;
   
      public TurnoverReportVO getTurnoverStatistics(LocalDate begin, LocalDate end) {
           //存放X轴坐标
           List<LocalDate> dateList = new ArrayList<>();
           //存放Y轴坐标
           List<Double> turnoverList = new ArrayList<>();
   
           dateList.add(begin);
           while (!begin.equals(end)) {
               begin = begin.plusDays(1);  //天数+1
               dateList.add(begin);
           }
           for (LocalDate date : dateList) {
               //日期范围内，已完成订单的总金额
               LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);   //0分0秒
               LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX); //23:59:59:999
               Map map = new HashMap();
               map.put("beginTime", beginTime);
               map.put("endTime", endTime);
               map.put("status", Orders.COMPLETED);
               Double turnover = orderMapper.sumByMap(map);
               turnover = turnover == null ? 0.0 : turnover;
               turnoverList.add(turnover);
           }
   
           return TurnoverReportVO.builder()
                   .dateList(StringUtils.join(dateList, ','))
                   .turnoverList(StringUtils.join(turnoverList, ','))
                   .build();
       }
   }
   ```

3. Mapper

   ```java
   Double sumByMap(Map map);
   ```

   - 避免转义	

   ```xml
   <select id="sumByMap" resultType="java.lang.Double">
       select sum(amount)
       from orders
       <!--&gt; 大于  &lt; 小于-->
       <where>
            <if test="beginTime!=null">
                and order_time &gt; #{beginTime}
           </if>
           <if test="endTime!=null">
               and order_time &lt; #{endTime}
           </if>
           <if test="status!=null">
               and status = #{status}
           </if>
       </where>
   </select>
   ```

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603140030295-859390199.png" alt="image-20240603140025025" style="zoom: 33%;" />

## 用户统计

### 需求分析

1. 两条折线：用户总量和新增用户数量
2. 折线图来展示用户数据，x轴是日期，y轴是用户数。

### 代码实现

1. Controller

   ```java
   @GetMapping("/userStatistics")
   @ApiOperation("用户统计")
   public Result<UserReportVO> userStatistics(@DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate begin,
                                              @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate end) {
       log.info("用户统计的日期区间：{}-{}", begin, end);
       return Result.success(reportService.getUserStatistics(begin, end));
   }
   ```

2. Service

   ```java
   @Override
   public UserReportVO getUserStatistics(LocalDate begin, LocalDate end) {
       //存放X轴坐标
       List<LocalDate> dateList = new ArrayList<>();
   
       dateList.add(begin);
       while (!begin.equals(end)) {
           begin = begin.plusDays(1);  //天数+1
           dateList.add(begin);
       }
   
       //存放新用户Y轴坐标
       List<Integer> newUserList = new ArrayList<>();
       //存放总用户Y轴坐标
       List<Integer> totalUserList = new ArrayList<>();
   
       for (LocalDate date : dateList) {
           //日期范围内，已完成订单的总金额
           LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);   //0分0秒
           LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX); //23:59:59:999
           Map map = new HashMap();
           map.put("endTime", endTime);
   
           Integer totalUser = userMapper.countByMap(map);
           totalUserList.add(totalUser);
   
           map.put("beginTime", beginTime);
           Integer newUser = userMapper.countByMap(map);
           newUserList.add(newUser);
       }
   
       return UserReportVO.builder()
               .dateList(StringUtils.join(dateList, ','))
               .newUserList(StringUtils.join(newUserList, ','))
               .totalUserList(StringUtils.join(totalUserList, ','))
               .build();
   }
   ```

3. Mapper

   ```java
   <select id="countByMap" resultType="java.lang.Integer">
       select count(id)
       from user
       <where>
           <if test="beginTime!=null">
               and create_time &gt; #{beginTime}
           </if>
           <if test="endTime!=null">
               and create_time &lt; #{endTime}
           </if>
       </where>
   </select>
   ```

## 订单统计

### 需求分析

1. 两条折线：订单总量和有效[已完成]订单数量
2. 折线图来展示用户数据，x轴是日期，y轴是订单数。

### 代码实现

1. Controller

   ```java
   @GetMapping("/ordersStatistics")
   @ApiOperation("订单统计")
   public Result<OrderReportVO> ordersStatistics(@DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate begin,
                                                 @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate end) {
       log.info("订单统计的日期区间：{}-{}", begin, end);
       return Result.success(reportService.getOrdersStatistics(begin, end));
   }
   ```

2. Service

   ```java
   @Override
   public OrderReportVO getOrdersStatistics(LocalDate begin, LocalDate end) {
       //存放X轴坐标
       List<LocalDate> dateList = new ArrayList<>();
   
       dateList.add(begin);
       while (!begin.equals(end)) {
           begin = begin.plusDays(1);  //天数+1
           dateList.add(begin);
       }
   
       //存放订单Y轴坐标
       List<Integer> orderCountList = new ArrayList<>();
       //存放有效订单Y轴坐标
       List<Integer> validOrderCountList = new ArrayList<>();
   
       for (LocalDate date : dateList) {
           //日期范围内，已完成订单的总金额
           LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);   //0分0秒
           LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX); //23:59:59:999
          Map map = new HashMap();
           map.put("beginTime", beginTime);
           map.put("endTime", endTime);
           Integer ordercount = orderMapper.countByMap(map);
           orderCountList.add(ordercount);
   
           map.put("status", Orders.COMPLETED);
           Integer validorder = orderMapper.countByMap(map);
           validOrderCountList.add(validorder);
       }
       //利用流来计算总和
           Integer totals = orderCountList.stream().reduce(Integer::sum).get();
           Integer valids = validOrderCountList.stream().reduce(Integer::sum).get();
           Double completionRate=0.0;
           if(totals!=0){
               completionRate=(double)valids/totals;
           }
   
           return OrderReportVO.builder()
                   .dateList(StringUtils.join(dateList))
                   .orderCountList(StringUtils.join(orderCountList))
                   .validOrderCountList(StringUtils.join(validOrderCountList))
                   .orderCompletionRate(completionRate)
                   .totalOrderCount(totals)
                   .validOrderCount(valids)
                   .build();
   }
   ```

3. Mapper

   ```xml
   <select id="countByMap" resultType="java.lang.Integer">
       select count(id) from orders
       <where>
           <if test="beginTime!=null">
               and order_time &gt; #{beginTime}
           </if>
           <if test="endTime!=null">
               and order_time &lt; #{endTime}
           </if>
           <if test="status!=null">
               and status = #{status}
           </if>
       </where>
   </select>
   ```

## 销量排名统计

### 需求分析

1. 根据时间区间，展示销量排名前十的商品
2. 基于柱状图，降序排列

### 代码实现

1. Service

   ```java
   @Override
   public SalesTop10ReportVO gettop10Statistics(LocalDate begin, LocalDate end) {
       LocalDateTime beginTime = LocalDateTime.of(begin, LocalTime.MIN);   //0分0秒
       LocalDateTime endTime = LocalDateTime.of(end, LocalTime.MAX); //23:59:59:999
       List<GoodsSalesDTO> saletop10 = orderMapper.gettSalesTop10(beginTime, endTime);
   
       List<String> names = saletop10.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList());
       String namelist = StringUtils.join(names, ',');
       List<Integer> numbers = saletop10.stream().map(GoodsSalesDTO::getNumber).collect(Collectors.toList());
       String numberlist = StringUtils.join(numbers, ',');
   
   
       return SalesTop10ReportVO.builder()
               .nameList(namelist)
               .numberList(numberlist)
               .build();
   }
   ```

2. Mapper

   ```xml
   <select id="gettSalesTop10" resultType="com.sky.dto.GoodsSalesDTO">
       select od.name ,sum(od.number) number
       from orders o,order_detail od
       where od.order_id=o.id and status=5
       <if test="begin!=null">
           and order_time &gt; #{begin}
       </if>
       <if test="end!=null">
           and order_time &lt; #{end}
       </if>
       group by od.name
       order by number desc
       limit 0,10
   </select>
   ```

# Excel报表

## 工作台

### 需求分析

![image-20240603180621450](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240603180621529-3853799.png)

### 导入代码

## Apache POI

### 简介

Apache POl是一个处理Miscrosoft Office各种文件格式的开源项目。

- 简单来说就是，我们可以使用POI在Java程序中对Miscrosoft Office各种文件进行读写操作。
- Excel文件读入到java中和java写出到Excel
- 一般情况下，POI都是用于操作 Excel文件。

Apache POI的应用场景:

- 银行网银系统导出交易明细
- 各种业务系统导出Excel报表
- 批量导入业务数据

### 使用步骤

1. 导入Maven坐标

   ```xml
   <!-- poi -->
   <dependency>
       <groupId>org.apache.poi</groupId>
       <artifactId>poi</artifactId>
   </dependency>
   <dependency>
       <groupId>org.apache.poi</groupId>
       <artifactId>poi-ooxml</artifactId>
   </dependency>
   ```

2. 读写文件

   ```java
   /**
    * 使用POI操作Excel文件
    */
   public class POITest {
   
       /**
        * 通过POI创建Excel文件并且写入文件内容
        */
       public static void write() throws Exception {
           //在内存中创建一个Excel文件
           XSSFWorkbook excel = new XSSFWorkbook();
           //在Excel文件中创建一个Sheet页
           XSSFSheet sheet = excel.createSheet("info");
           //在Sheet中创建行对象,rownum编号从0开始
           XSSFRow row = sheet.createRow(1);
           //创建单元格并且写入文件内容
           row.createCell(1).setCellValue("姓名");
           row.createCell(2).setCellValue("城市");
   
           //创建一个新行
           row = sheet.createRow(2);
           row.createCell(1).setCellValue("张三");
           row.createCell(2).setCellValue("北京");
   
           row = sheet.createRow(3);
           row.createCell(1).setCellValue("李四");
           row.createCell(2).setCellValue("南京");
   
           //通过输出流将内存中的Excel文件写入到磁盘
           FileOutputStream out = new FileOutputStream(new File("D:\\info.xlsx"));
           excel.write(out);
   
           //关闭资源
           out.close();
           excel.close();
       }
   
   
       /**
        * 通过POI读取Excel文件中的内容
        *
        * @throws Exception
        */
       public static void read() throws Exception {
           InputStream in = new FileInputStream(new File("C:\\Users\\32354\\Desktop\\大3下\\SHU\\练习\\项目\\资料\\day12\\itcast.xlsx"));
   
           //读取磁盘上已经存在的Excel文件
           XSSFWorkbook excel = new XSSFWorkbook(in);
           //读取Excel文件中的第一个Sheet页
           XSSFSheet sheet = excel.getSheetAt(0);
   
           //获取Sheet中最后一行的行号
           int lastRowNum = sheet.getLastRowNum();
   
           for (int i = 1; i <= lastRowNum; i++) {
               //获得某一行
               XSSFRow row = sheet.getRow(i);
               //获得单元格对象
               String cellValue1 = row.getCell(1).getStringCellValue();
               String cellValue2 = row.getCell(2).getStringCellValue();
               System.out.println(cellValue1 + " " + cellValue2);
           }
   
           //关闭资源
           in.close();
           excel.close();
       }
   
       public static void main(String[] args) throws Exception {
           //write();
           read();
       }
   }
   ```

## 导出数据Excel报表

### 需求分析

1. 提前设计好Excel模版文件
2. 查询近30天的运营数据
3. 把查询到的数据写入模版文件
4. 通过输出流把Excel文件下载到客户端浏览器

### 代码开发

1. 在resource资源目录下新建template目录，导入模版文件.xlsx

2. Controller

   ```java
   @GetMapping("/export")
   @ApiOperation("导出运营数据报表")
   public void export(HttpServletResponse response) {
       reportService.exportBusinessDate(response);
   }
   ```

3. Service

   ```java
   @Override
   public void exportBusinessDate(HttpServletResponse response) {
       //1.获取近30天营业数据
       LocalDate begin = LocalDate.now().minusDays(30);
       LocalDate end = LocalDate.now().minusDays(1);
       LocalDateTime beginTime = LocalDateTime.of(begin, LocalTime.MIN);
       LocalDateTime endTime = LocalDateTime.of(end, LocalTime.MAX);
       BusinessDataVO businessData = workspaceService.getBusinessData(beginTime, endTime);
   
       //2.把数据写入到Excel文件中
       InputStream in = this.getClass().getClassLoader().getResourceAsStream("template/运营数据报表模版.xlsx");
   
       try {
           
           XSSFWorkbook excel = new XSSFWorkbook(in);  //基于模版文件创建一个新的Excel文件
           
           XSSFSheet sheet1 = excel.getSheet("Sheet1");    //获取表格文件的sheet页
           sheet1.getRow(1).getCell(1).setCellValue("时间：" + beginTime + "至" + endTime);    //填充数据-时间
           //概览数据-近30天
           sheet1.getRow(3).getCell(2).setCellValue(businessData.getTurnover());   //填充数据-营业额
           sheet1.getRow(3).getCell(2).setCellValue(businessData.getOrderCompletionRate());   //填充数据-订单完成率
           sheet1.getRow(3).getCell(2).setCellValue(businessData.getNewUsers());   //填充数据-新增用户数
           sheet1.getRow(3).getCell(2).setCellValue(businessData.getNewUsers());   //填充数据-新增用户数
           
           sheet1.getRow(4).getCell(2).setCellValue(businessData.getValidOrderCount());   //填充数据-有效订单数
           sheet1.getRow(4).getCell(4).setCellValue(businessData.getUnitPrice());   //填充数据-平均客单价
   
           //明细数据-每一天
           for (int i = 0; i < 30; i++) {
               LocalDate date = begin.plusDays(i);
               BusinessDataVO businessData1 = workspaceService.getBusinessData(LocalDateTime.of(date, LocalTime.MIN), LocalDateTime.of(date, LocalTime.MAX));
   
               XSSFRow row = sheet1.getRow(7 + i);
               row.getCell(1).setCellValue(date.toString());
               row.getCell(2).setCellValue(businessData1.getTurnover());
               row.getCell(3).setCellValue(businessData1.getValidOrderCount());
               row.getCell(4).setCellValue(businessData1.getOrderCompletionRate());
               row.getCell(5).setCellValue(businessData1.getUnitPrice());
               row.getCell(6).setCellValue(businessData1.getNewUsers());
           }
           
   
           //3.将Excel文件下载到客户端浏览器
           ServletOutputStream out = response.getOutputStream();
           excel.write(out);
           
           //4.关闭资源
           out.close();
           excel.close();
       } catch (IOException e) {
           e.printStackTrace();
       }
   }
   ```

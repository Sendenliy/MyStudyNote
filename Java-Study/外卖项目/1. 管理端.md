# git环境搭建

## 本地提交

1. gitignore是忽略不提交的文件

   ```java
   **/target/
   .idea
   *.iml
   *.class
   *Test.java
   **/test/
   ```

2. 在顶部菜单栏VCS[版本控制系统]选择创建git仓库

3. 选择项目根目录`提交`

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525125318104-1573616979.png" alt="image-20240525125323957" style="zoom:53%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525125342489-127218862.png" alt="image-20240525125349947" style="zoom:43%;" />

## 远程推送

1. 在gitee上新建私有仓库

2. 用gitee的http链接地址`推送`

   https://gitee.com/Sunflower0312/sky-takeout.git

3. 定义远程仓库

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525125524849-146757791.png" alt="image-20240525125532161" style="zoom:50%;" />

4. 推送时的凭证账号为手机号，密码为用户密码

5. 刷新页面，gitee此时已经有了本地代码

# 前后端连调

## 项目启动

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525144728514-862452169.png" alt="image-20240525144735337" style="zoom:47%;" />

1. 先在根项目下启动compaile编译（lombok版本需要调整）

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525145852376-1107346065.png" alt="image-20240525145859811" style="zoom:57%;" />

2. 启动主程序

## Controller断点跟踪

1. 在Controller的登录中打上断点
2. debug

## Nginx

- 请求地址：http://localhost:8081/api/employee/login
- Controller后端地址：http://localhost:8080/admin/employee/login

Nginx反向代理，将前端发送的动态请求由Nginx转发到了后端服务器

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525153358159-1014176138.png" alt="image-20240525153405165" style="zoom:47%;" />

### 反向代理

```properties
 #Nginx.conf
 server {
     listen       8081;
     server_name  localhost;

    location / {
        root   html/sky;
        index  index.html index.htm;
    }

    # redirect server error pages to the static page /50x.html
    error_page   500 502 503 504  /50x.html;
        location = /50x.html {
        root   html;
    }

    # 反向代理,处理管理端发送的请求
    location /api/ {
        proxy_pass   http://localhost:8080/admin/;
    }

    # 反向代理,处理用户端发送的请求
    location /user/ {
        proxy_pass   http://webservers/user/;
    }

    # WebSocket
    location /ws/ {
        proxy_pass   http://webservers/ws/;
        proxy_http_version 1.1;
        proxy_read_timeout 3600s;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "$connection_upgrade";
    }
}
```

### 负载均衡

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525154817539-1298748271.png" alt="image-20240525154824792" style="zoom:33%;" />

```properties
upstream webservers{
    server 192.168.100.128:8081 weight=90 ;
    server 192.168.100.129:8081 weight=10 ;
}
#请求匹配到 /api/ 时，由webservers负载均衡到上述两台服务器中
server{
	listen       8081;
    server_name  localhost;
    location /api/ {
       proxy_pass   http://webservers/admin/;
    }
}
```

## MD5加密存储

完善登录功能，todo标签页

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525160233460-1968599688.png" alt="image-20240525160240842" style="zoom:40%;" />

1. 修改数据库中明文密码，改为MD5加密后的密文

2. 修改Java代码，前端提交的密码进行MD5加密后再跟数据库中密码比对

   ```java
   //进行md5加密，然后再进行比对	DigestUtils--spring提供
   password=DigestUtils.md5DigestAsHex(password.getBytes());
   ```

# 接口文档

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525161038815-867642509.png" alt="image-20240525161046318" style="zoom:47%;" />

## 接口管理和编写

### YAPI

YAPI是一个现代化的`接口管理平台`，它的全称是 "Yet Another Practice Interface"。YAPI旨在提供更高效、更友好的接口管理服务，是一个开源的、可视化的接口管理工具。

YAPI可以帮助团队更好地管理、分享和使用API文档，支持团队协作，旨在为开发、产品、测试人员提供更优雅的接口管理服务。它支持开发者轻松创建、发布、维护API，并提供了优秀的交互体验，允许开发人员利用平台提供的接口数据写入工具以及简单的点击操作来实现接口的管理。。

- 官网：https://yapi.pro/
- 官方文档：https://hellosean1025.github.io/yapi/documents/index.html
- 非官方文档：http://ued.qunar.com/yapi/documents/index.html

特性:

- 基于Json5 和Mockjs定义接口返回数据的结构和文档，效率提升多倍·扁平化权限设计，即保证了大型企业级项目的管理，又保证了易用性。类似postman的接口调试
- 自动化测试，支持对Response断言
- MockServer除支持普通的随机 mock外，还增加了Mock 期望功能，根据设置的请求过滤规则，返回期望数据
- 支持postman, har, swagger数据导入。YApi和Swagger类似，可以通过swagger文档导入接口进行维护。
- 免费开源，内网部署

### Swagger

Swagger是一个大型的`API开发者的工具框架`，并且Swagger可以跨整个API生命周期进行开发，从设计和文档到测试和部署。使用swagger你只需要按照规范去定义接口及接口相关的信息，就可以`生成接口文档`，以及`在线接口调试页面`。

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525171245355-779545278.png" alt="image-20240525171252658" style="zoom:53%;" />

Swagger框架三核心:

1. 提供了一个编写API文档的规范，称为OAS，在规范中明确API的格式和一些编写要素
2. 提供相关的工具，对API文档的编写提供辅助。主要是这么几个项目Swagger Editor、SwaggerUl、Swagger Codegen、Swagger Inspector;
3. 提供对各种流行语言和框架的集成
   1. 例如集成SpringMVC的 springfox框架
   2. spring的SpringDoc
   3. Knife4j是为javaMVC框架集成swagger生成API文档的增强解决方案

```xml
<!-- Spring Boot 项目starter,快速使用knife4j增强文档  -->
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-boot-starter</artifactId>
    <version>3.0.3</version>
</dependency>
```

### 区别

1. Yapi是设计阶段使用的工具，管理和维护接口
2. Swagger是在开发阶段使用的框架，帮助后端开发人员做后端的接口测试

## 工具的使用

### YAPI使用

1. `YAPI通过管理项目的方式管理接口`，首先创建两个项目

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525162637949-705276941.png" alt="image-20240525162645364" style="zoom:30%;" />

2. 导入接口文件

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525164042390-742825783.png" alt="image-20240525164049568" style="zoom:30%;" />

3. 导入成功

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525164450035-1711668279.png" alt="image-20240525164456798" style="zoom:30%;" />

### Swagger使用

1. 导入knife4j的Maven坐标

   ```xml
   <dependency>
       <groupId>com.github.xiaoymin</groupId>
       <artifactId>knife4j-spring-boot-starter</artifactId>
       <knife4j>3.0.2</knife4j>
   </dependency>
   ```

2. 配置knife4j

   ```java
   //WebMvcConfiguration.java
   /**
    * 通过knife4j生成接口文档
    */
   @Bean
   public Docket docket() {
       ApiInfo apiInfo = new ApiInfoBuilder()
               .title("苍穹外卖项目接口文档")
               .version("2.0")
               .description("苍穹外卖项目接口文档")
               .build();
       Docket docket = new Docket(DocumentationType.SWAGGER_2)
               .apiInfo(apiInfo)
               .select()
           //指定扫描的包
               .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
               .paths(PathSelectors.any())
               .build();
       return docket;
   }
   ```

3. 设置静态资源映射

   1. 否则接口文档页面会被当做Controller找不到映射
   2. 从而无法访问

   ```java
   //WebMvcConfiguration.java
   /**
    * 设置静态资源映射	addResourceHandlers是重写的方法
   WebMvcConfiguration extends WebMvcConfigurationSupport
    */
   @Override
   protected void addResourceHandlers(ResourceHandlerRegistry registry) {
       registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
       registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
   }
   ```

TomCat在8080端口，访问http://localhost:8080/doc.html

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525170327674-2111756290.png" alt="image-20240525170334580" style="zoom:33%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525170710449-1902423994.png" alt="image-20240525170717718" style="zoom:33%;" />

# 员工管理模块

## 新增员工

### 需求分析

请求参数

| 名称     | 类型    | 是否必须 | 默认值 | 备注   | 其他信息          |
| :------- | :------ | :------- | :----- | :----- | :---------------- |
| id       | integer | 非必须   |        | 员工id | **format:** int64 |
| idNumber | string  | 必须     |        | 身份证 |                   |
| name     | string  | 必须     |        | 姓名   |                   |
| phone    | string  | 必须     |        | 手机号 |                   |
| sex      | string  | 必须     |        | 性别   |                   |
| username | string  | 必须     |        | 用户名 |                   |

返回数据

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息          |
| :--- | :------ | :------- | :----- | :--- | :---------------- |
| code | integer | 必须     |        |      | **format:** int32 |
| data | object  | 非必须   |        |      |                   |
| msg  | string  | 非必须   |        |      |                   |

### 代码实现

1. 根据新增员工接口设计对应的DTO

   ```java
   @Data
   public class EmployeeDTO implements Serializable {
   
       private Long id;
   
       private String username;
   
       private String name;
   
       private String phone;
   
       private String sex;
   
       private String idNumber;
   
   }
   ```

2. 编写Controller层

   ```java
   @PostMapping
   @ApiOperation("新增员工")
   public Result save(@RequestBody EmployeeDTO employeeDTO) {
       //{}占位符 会把后面的值放在括号内
       log.info("新增员工：{}", employeeDTO);
       employeeService.save(employeeDTO);
       return Result.success();
   }
   ```

3. 编写Service层

   1. 传输时需要EmployeeDTO对象，存入数据库时应该转换为Employee对象
   2. 默认值尽量避免硬编码，调用Constant类
   3. 对象属性拷贝，spring提供方法 BeanUtils.copyProperties()
   4. TODO会高亮提醒

   ```java
   //新增员工业务方法
   void save(EmployeeDTO employeeDTO);
   
    @Override
   public void save(EmployeeDTO employeeDTO) {
       Employee employee = new Employee();
   
       //对象属性拷贝  employeeDTO属性拷贝给employee 要求属性名一样
       BeanUtils.copyProperties(employeeDTO, employee);
   
       //设置账号的状态：默认正常
       employee.setStatus(StatusConstant.ENABLE);
       //设置密码
       employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));
       //设置当前记录的创建时间和修改时间
       employee.setCreateTime(LocalDateTime.now());
       employee.setUpdateTime(LocalDateTime.now());
       //设置当前记录的创建人id和修改人id
       // TODO 后期需要改为当前登录用户的id
       employee.setCreateUser(10L);
       employee.setUpdateUser(10L);
   
       employeeMapper.insert(employee);
   }
   ```

4. 编写mapper

   ```yaml
   mybatis:
     configuration:
       #开启驼峰命名
       map-underscore-to-camel-case: true
   ```

   ```java
   //插入员工数据
   @Insert("insert into employee (name, username, password, phone, sex, id_number, status, create_time, update_time, create_user, update_user)" +
           "values(#{name},#{username},#{password},#{phone},#{sex},#{idNumber},#{status},#{createTime},#{updateTime},#{createUser},#{updateUser});")
   void insert(Employee employee);
   ```

### 功能测试

测试方式：通过接口文档测试、通过前后联调测试(不常用，前后端开发不同步)

问题：

- 输入测试数据，报错码为401
- 没有JWT令牌，被JWT拦截，校验未通过
- 手机号11位13开头，idNumber要求18位

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525180228333-1699953627.png" alt="image-20240525180235406" style="zoom:33%;" />

解决方法：

- 获取员工登录的JWT令牌

- 添加到全局参数

  <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525180904378-1691832485.png" alt="image-20240525180911335" style="zoom:33%;" />

### 优化1-自定义异常

问题：新增用户名相同时，会抛出异常

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525184353433-1262688554.png" alt="image-20240525184400461" style="zoom:33%;" />

解决方法：

在全局异常处理器GlobalExceptionHandler中捕获异常

```java
@ExceptionHandler
public Result exceptionHandler(MySQLIntegrityConstraintViolationException ex){
    //Duplicate entry 'lisi' for key 'idx_username'
    String message = ex.getMessage();
    if(message.contains("Duplicate entry")){
        String[] split = message.split(" ");
        String username = split[2];
        String msg=username+ MessageConstant.ALREADY_EXITS;
        return Result.error(msg);
    }else {
        return Result.error(MessageConstant.UNKNOWN_ERROR);
    }
}
```

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525185204169-888572642.png" alt="image-20240525185211229" style="zoom:43%;" />

### 优化2-ThreadLocal

1. ThreadLocal并不是一个Thread，而是Thread的局部变量
2. ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。
3. ThreadLocal常用的方法：
   - set(T value)：设置当前线程对应的线程局部变量的值
   - get()：返回当前线程对应的线程局部变量的值
   - remove：移除当前线程的线程局部变量

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525185541745-299457288.png" alt="image-20240525185548807" style="zoom:50%;" />

问题：新增员工时，创建人和修改人的id是硬编码。应该利用JWT获取当前的用户id

解决方法：

1. 查看拦截器、Controller和Service中的线程ID

2. 发现客户端每发起的请求是同一个线程，可以使用ThreadLocal

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240525190517054-1670552293.png" alt="image-20240525190523856" style="zoom:35%;" />

3. 自定义了一个工具类

   ```java
   public class BaseContext {
   
       public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();
   
       public static void setCurrentId(Long id) {
           threadLocal.set(id);
       }
   
       public static Long getCurrentId() {
           return threadLocal.get();
       }
   
       public static void removeCurrentId() {
           threadLocal.remove();
       }
   
   }
   ```

4. 调用该工具类

   ```java
   //1.在拦截器解析token后，把员工ID存入
   BaseContext.setCurrentId(empId);
   //2.在ServiceImpl中取出员工ID
   employee.setCreateUser(BaseContext.getCurrentId());
   employee.setUpdateUser(BaseContext.getCurrentId());
   ```

## 员工分页查询

### 需求分析

请求参数Query：

| 参数名称 | 是否必须 | 示例 | 备注       |
| :------- | :------- | :--- | :--------- |
| name     | 否       | 张三 | 员工姓名   |
| page     | 是       | 1    | 页码       |
| pageSize | 是       | 10   | 每页记录数 |

返回数据

| 名称 | 类型   | 是否必须 | 默认值 | 备注 | 其他信息 |
| :--- | :----- | :------- | :----- | :--- | :------- |
| code | number | 必须     |        |      |          |
| msg  | null   | 非必须   |        |      |          |
| data | object | 必须     |        |      |          |

### 代码实现

1. 设计DTO

   ```java
   @Data
   public class EmployeePageQueryDTO implements Serializable {
       //员工姓名
       private String name;
       //页码
       private int page;
       //每页显示记录数
       private int pageSize;
   }
   ```

2. 封装分页查询结果

   - 分页查询后端返回的对象类型则为：Result<PageResult>

   ```java
   @Data
   @AllArgsConstructor
   @NoArgsConstructor
   public class PageResult implements Serializable {
       private long total; //总记录数
       private List records; //当前页数据集合
   }
   ```

3. 编写Controller

   ```java
   @GetMapping("/page")
   @ApiOperation("员工分页查询")
   public Result<PageResult> page(EmployeePageQueryDTO employeePageQueryDTO) {
       log.info("员工分页查询的对象：{}", employeePageQueryDTO);
   
       PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);
   
       return Result.success(pageResult);
   }
   ```

4. 这里使用MyBatis插件pagehelper实现分页，引入Maven坐标

   ```xml
   <dependency>
       <groupId>com.github.pagehelper</groupId>
       <artifactId>pagehelper-spring-boot-starter</artifactId>
   </dependency>
   ```

5. 编写Service层

   ```java
   PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
   
   @Override
   public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {
       //开始分页查询
       PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize());
   
       Page<Employee> page= employeeMapper.pageQuery(employeePageQueryDTO);
   
       return new PageResult(page.getTotal(),page.getResult());
   }
   ```

6. 编写mapper

   ```java
   Page<Employee> pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
   ```

   ```yaml
   mybatis:
     #mapper配置文件
     mapper-locations: classpath:mapper/*.xml
   ```

   ```xml
   <select id="pageQuery" resultType="com.sky.entity.Employee">
       select * from employee
       <where>
           <if test="name!=null and name!=''">
               and name like concat('%'+'#{name}'+'%')
           </if>
       </where>
       order by create_time desc
   </select>
   ```

### 功能测试

1. 测试数据，返回结果401

2. token有效时间会过期，在登录接口处可以生成新的令牌

3. 修改为新的令牌，重新测试

   - PageHelper会生成动态SQL，根据测试提供的数据，加上limit

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526133141104-1222708225.png" alt="image-20240526133148481" style="zoom:43%;" />

   - 使用了模糊查询，操作时间的格式不太正确，应该为yyyy-MM-dd HH:mm:ss

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526135058903-2106914123.png" alt="image-20240526135106523" style="zoom:40%;" />

### 优化-日期格式

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526135829420-196491116.png" alt="image-20240526135837125" style="zoom:50%;" />

解决方法：

1. 在属性上加注解，对日期进行格式化

   ```java
   @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
   private LocalDateTime createTime;
   ```

2. 在WebMvcConfiguration中扩展SpringMVC的消息转换器，统一对日期类型进行格式化处理【建议】

   ```java
   @Override
   protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
       log.info("扩展消息转换器....");
       //1.创建一个消息转换器对象
       MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
       //2.需要为消息转换器设置一个对象转换器  把java对象 序列化为 JSON数据
       converter.setObjectMapper(new JacksonObjectMapper());
       //3.将自己的消息转换器加到容器中去 提高自定义消息转换器的优先级
       converters.add(0, converter);
   }
   ```

   此处用了一个工具类JacksonObjectMapper

   ```java
   /**
    * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
    * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
    * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
    */
   public class JacksonObjectMapper extends ObjectMapper {
   
       public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
       //public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
       public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";
       public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";
   
       public JacksonObjectMapper() {
           super();
           //收到未知属性时不报异常
           this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);
   
           //反序列化时，属性不存在的兼容处理
           this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
   
           SimpleModule simpleModule = new SimpleModule()
                   .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                   .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                   .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                   .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                   .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                   .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
   
           //注册功能模块 例如，可以添加自定义序列化器和反序列化器
           this.registerModule(simpleModule);
       }
   }
   ```

测试：

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526141036991-1910934265.png" alt="image-20240526141044072" style="zoom:40%;" />

## 启用禁用员工账号

### 需求分析

接口路径：POST/admin/employee/status/{status}

请求参数

路径参数：

| 参数名称 | 示例 | 备注                  |
| :------- | :--- | :-------------------- |
| status   | 1    | 状态，1为启用 0为禁用 |

Headers：

| 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
| :----------- | :--------------- | :------- | :--- | :--- |
| Content-Type | application/json | 是       |      |      |

Query：

| 参数名称 | 是否必须 | 示例 | 备注   |
| :------- | :------- | :--- | :----- |
| id       | 是       |      | 员工id |

返回数据

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息          |
| :--- | :------ | :------- | :----- | :--- | :---------------- |
| code | integer | 必须     |        |      | **format:** int32 |
| data | string  | 非必须   |        |      |                   |
| msg  | string  | 非必须   |        |      |                   |

### 代码实现

1. Controller

   ```java
   @PostMapping("/status/{status}")
   @ApiOperation("启用禁用员工账号")
   public Result startOrStop(@PathVariable("status") Integer status, Long id) {
       log.info("启用禁用员工账号：{},{}", status, id);
       employeeService.startOrStop(status, id);
       return Result.success();
   }
   ```

2. Service

   ```java
   void startOrStop(Integer status, Long id);
   
   //为了方便复用，这里使用Employee封装修改传入的数据
   /*
   创建对象的两种方式：
   	1.new
   	2.builder()
   */
   @Override
   public void startOrStop(Integer status, Long id) {
       Employee employee = Employee.builder()
           .status(status)
           .id(id)
           .build();
       //Employee employee=new Employee();
       // employee.setId(id);
       //employee.setStatus(status);
   
       employeeMapper.update(employee);
   }
   ```

3. mapper

   ```java
   void update(Employee employee);
   ```

   ```xml
   <update id="update">
       update employee
       <set>
           <if test="name!=null">name=#{name},</if>
           <if test="username!=null">username=#{username},</if>
           <if test="password!=null"> password=#{password},</if>
           <if test="phone!=null"> phone=#{phone},</if>
           <if test="sex!=null">x=#{sex},</if>
           <if test="idNumber!=null"> id_Number=#{idNumber},</if>
           <if test="updateTime!=null">update_Time=#{updateTime},</if>
           <if test="updateUser!=null">update_User=#{updateUser}, </if>
           <if test="status!=null"> status=#{status},</if>
       </set>
       where id=#{id}
   </update>
   ```

### 功能测试

1. 接口文档测试

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526150229628-1941135387.png" alt="image-20240526150236897" style="zoom:33%;" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526150413313-707641037.png" alt="image-20240526150420445" style="zoom:43%;" />

2. 前后端连调

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526150307882-1870234295.png" alt="image-20240526150315466" style="zoom: 33%;" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526150432172-924908733.png" alt="image-20240526150439819" style="zoom:43%;" />

## 编辑员工

### 需求分析

1. 根据ID查询员工信息

   接口路径：GET/admin/employee/{id}

   请求参数

   路径参数：

   | 参数名称 | 示例 | 备注   |
   | :------- | :--- | :----- |
   | id       | 100  | 员工id |

   返回数据

   | 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息          |
   | :--- | :------ | :------- | :----- | :--- | :---------------- |
   | code | integer | 必须     |        |      | **format:** int32 |
   | data | object  | 必须     |        |      |                   |
   | msg  | string  | 非必须   |        |      |                   |

2. 编辑员工信息

   接口路径：PUT/admin/employee

   请求参数

   Headers：

   | 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
   | :----------- | :--------------- | :------- | :--- | :--- |
   | Content-Type | application/json | 是       |      |      |

   Body:

   | 名称     | 类型    | 是否必须 | 默认值 | 备注 | 其他信息          |
   | :------- | :------ | :------- | :----- | :--- | :---------------- |
   | id       | integer | 必须     |        |      | **format:** int64 |
   | idNumber | string  | 必须     |        |      |                   |
   | name     | string  | 必须     |        |      |                   |
   | phone    | string  | 必须     |        |      |                   |
   | sex      | string  | 必须     |        |      |                   |
   | username | string  | 必须     |        |      |                   |

   返回数据

   | 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息          |
   | :--- | :------ | :------- | :----- | :--- | :---------------- |
   | code | integer | 必须     |        |      | **format:** int32 |
   | data | string  | 非必须   |        |      |                   |
   | msg  | string  | 非必须   |        |      |                   |

### 代码实现

根据ID查询，数据回显

1. Controller

   ```java
   @GetMapping("/{id}")
   @ApiOperation("根据ID查询员工信息")
   public Result<Employee> getById(@PathVariable Long id) {
       log.info("启用根据ID-{}查询员工信息", id);
       Employee employee = employeeService.getById(id);
       return Result.success(employee);
   }
   ```

2. Service

   ```java
   Employee getById(Long id);
   
   @Override
   public Employee getById(Long id) {
       Employee employee = employeeMapper.getById(id);
       employee.setPassword("****");
       return employee;
   }
   ```

3. mapper

   ```java
   @Select("select * from employee where id=#{id}")
   Employee getById(Long id);
   ```

修改员工信息

1. Controller

   ```java
   @PutMapping
   @ApiOperation("编辑员工信息")
   public Result update(@RequestBody EmployeeDTO employeeDTO) {
       log.info("编辑员工信息：{}", employeeDTO);
       employeeService.update(employeeDTO);
       return Result.success();
   }
   ```

2. Service

   ```java
   void update(EmployeeDTO employeeDTO);
   
   @Override
   public void update(EmployeeDTO employeeDTO) {
       //把前端传入的数据对象属性 拷贝给 Employee
       Employee employee = new Employee();
       BeanUtils.copyProperties(employeeDTO, employee);
   	//设置没有赋值的属性
       employee.setUpdateTime(LocalDateTime.now());
       employee.setUpdateUser(BaseContext.getCurrentId());//利用的是ThreadLocal局部变量，拦截器时把ID保存在了里面
   
       employeeMapper.update(employee);//重用了上例mapper中的update方法
   }
   ```

   

### 功能测试

根据ID查询功能测试：

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526154202820-1124146428.png" alt="image-20240526154210253" style="zoom:30%;" />

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526151940316-2109013258.png" alt="image-20240526151947734" style="zoom:40%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526151955491-12222956.png" alt="image-20240526152003076" style="zoom:23%;" />

修改员工信息功能测试：

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526154510035-1188089475.png" alt="image-20240526154517207" style="zoom:33%;" />

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526154430462-671422383.png" alt="image-20240526154437914" style="zoom:40%;" />

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526154549174-2085657030.png" alt="image-20240526154556709" style="zoom:33%;" />

# 分类管理模块

### 需求分析

1. 分类名称必须唯一
2. 分类可以按照菜品分类或者按照套餐分类
3. 新添加的分类状态默认为禁用

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526155055371-1048243462.png" alt="image-20240526155102602" style="zoom:35%;" />

### 代码导入

依次导入

1. mapper.java
2. mapper.xml
3. service.java
4. serviceImpl.java
5. Controller

> 注意：
>
> 1. 导入后建议在根项目下用maven编译Compile一下，BuildSuccess即可。
> 2. 每次完成一个模块就提交并推送至仓库

### 功能测试

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526160323370-385271418.png" alt="image-20240526160330544" style="zoom:30%;" />

# 菜品管理模块

## 公共字段自动填充

### 问题分析

问题：每次新增员工或菜品都要手动添加下述字段。代码冗余，不便于后期维护

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240526160956627-824631956.png" alt="image-20240526161003950" style="zoom:43%;" />

解决方法：使用切面AOP(用`枚举`来表示操作类型)

1. 自定义`注解`AutoFill，用于标识需要进行公共字段自动填充的方法
2. 自定义`切面`类AutoFillAspect，统一拦截加入了AutoFill注解的方法，通过`反射`为公关字段赋值
3. 在Mapper的方法上加入AutoFill注解

### 代码开发

1. 自定义`注解`AutoFill

   ```java
   /**
    * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理
    */
   @Target(ElementType.METHOD)
   @Retention(RetentionPolicy.RUNTIME)
   public @interface AutoFill {
       //指定当前数据库的操作类型
       OperationType value();
   }
   ```

   此处用到的枚举类型，已经被封装

   ```java
   /**
    * 数据库操作类型
    */
   public enum OperationType {
       //更新操作
       UPDATE,
       //插入操作
       INSERT
   }
   ```

2. 自定义`切面`类AutoFillAspect

   ```java
   /**
    * 自定义切面，实现公共字段自动填充的处理逻辑
    */
   @Aspect //标识切面
   @Component  //交给容器
   @Slf4j  //记录日志
   public class AutoFillAspect {
       //切面=切入点+通知
   
       //1.定义切入点	扫描：所有返回值类型下的com.sky.mapper包的所有类的所有方法的任意参数&&要求有AutoFill注解
       @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
       public void autoFillPointCut() {
       }
   
       //2.定义通知(前置)
       @Before("autoFillPointCut()")
       public void autoFill(JoinPoint joinPoint) {
           log.info("开始进行公共字段的自动填充...");
   
           //1.获取当前被拦截方法的数据库操作类型  MethodSignature是Signature的子类，具有更详细的信息
           MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象
           AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获得方法上的注解对象
           OperationType operationType = autoFill.value();//获取数据库操作类型
   
           //2.获得当前被拦截方法的参数--实体对象
           Object[] args = joinPoint.getArgs();
           if (args == null || args.length == 0) {
               return;
           }
           //默认第一个参数是实体对象，不是就修改一下参数位置
           Object entry = args[0];
   
           //3.获取准备赋值的数据--时间和当前用户ID
           LocalDateTime now = LocalDateTime.now();
           Long currentId = BaseContext.getCurrentId();
   
           //4.根据不同的操作类型，为对应的属性通过反射来赋值
           if (operationType == OperationType.INSERT) {
               try {
                   //AutoFillConstant封装了一些实体类中的方法名称作为常量	SET_CREATE_TIME = "setCreateTime";
                   Method setCreateTime = entry.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
                   Method setCreateUser = entry.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
                   Method setUpdateTime = entry.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                   Method setUpdateUser = entry.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);
   
                   //通过反射为对象属性赋值  通过实体对象的方法来给属性赋值
                   setCreateTime.invoke(entry, now);
                   setCreateUser.invoke(entry, currentId);
                   setUpdateTime.invoke(entry, now);
                   setUpdateUser.invoke(entry, currentId);
               } catch (Exception e) {
                   e.printStackTrace();
               }
   
           } else if (operationType == OperationType.UPDATE) {
               try {
                   Method setUpdateTime = entry.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                   Method setUpdateUser = entry.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);
   
                   //通过反射为对象属性赋值
                   setUpdateTime.invoke(entry, now);
                   setUpdateUser.invoke(entry, currentId);
               } catch (Exception e) {
                   e.printStackTrace();
               }
           }
       }
   }
   ```

3. 在Mapper的update和insert方法上加入AutoFill注解

   ```java
   @AutoFill(OperationType.UPDATE)
   @AutoFill(OperationType.INSERT)
   ```

4. 在ServiceImpl之前的设置公共字段信息删除

## 新增菜品

### 需求分析

1. 菜品名称必须唯一
2. 菜品必须属于某个分类下，不能单独存在
3. 新增菜品时可以根据情况选择菜品的口味
4. 每个菜品必须对应一张图片

涉及到的接口：

1. 根据类型查询分类【已完成】

   接口路径：GET/admin/category/list

   请求参数

   Query：

   | 参数名称 | 是否必须 | 示例 | 备注                               |
   | :------- | :------- | :--- | :--------------------------------- |
   | type     | 否       | 2    | 分类类型：1为菜品分类，2为套餐分类 |

   返回数据

   | 名称 | 类型      | 是否必须 | 默认值 | 备注 | 其他信息              |
   | :--- | :-------- | :------- | :----- | :--- | :-------------------- |
   | code | integer   | 必须     |        |      | **format:** int32     |
   | data | object [] | 非必须   |        |      | **item 类型:** object |
   | msg  | string    | 非必须   |        |      |                       |

2. 文件上传

   接口路径：POST/admin/common/upload

   请求参数

   Headers：

   | 参数名称     | 参数值                  | 是否必须 | 示例 | 备注 |
   | :----------- | :---------------------- | :------- | :--- | :--- |
   | Content-Type | **multipart/form-data** | 是       |      |      |

   Body:

   | 参数名称 | 参数类型 | 是否必须 | 示例 | 备注 |
   | :------- | :------- | :------- | :--- | :--- |
   | file     | 文件     | 是       |      | 文件 |

   返回数据

   | 名称 | 类型    | 是否必须 | 默认值 | 备注         | 其他信息          |
   | :--- | :------ | :------- | :----- | :----------- | :---------------- |
   | code | integer | 必须     |        |              | **format:** int32 |
   | data | string  | 必须     |        | 文件上传路径 |                   |
   | msg  | string  | 非必须   |        |              |                   |

3. 新增菜品

   接口路径：POST/admin/dish

   请求参数

   Headers：

   | 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
   | :----------- | :--------------- | :------- | :--- | :--- |
   | Content-Type | application/json | 是       |      |      |

   Body:

   | 名称        | 类型      | 是否必须 | 默认值 | 备注                       | 其他信息              |
   | :---------- | :-------- | :------- | :----- | :------------------------- | :-------------------- |
   | categoryId  | integer   | 必须     |        | 分类id                     | **format:** int64     |
   | description | string    | 非必须   |        | 菜品描述                   |                       |
   | flavors     | object [] | 非必须   |        | 口味                       | **item 类型:** object |
   | id          | integer   | 非必须   |        | 菜品id                     | **format:** int64     |
   | image       | string    | 必须     |        | 菜品图片路径               |                       |
   | name        | string    | 必须     |        | 菜品名称                   |                       |
   | price       | number    | 必须     |        | 菜品价格                   |                       |
   | status      | integer   | 非必须   |        | 菜品状态：1为起售，0为停售 | **format:** int32     |

   返回数据

   | 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息          |
   | :--- | :------ | :------- | :----- | :--- | :---------------- |
   | code | integer | 必须     |        |      | **format:** int32 |
   | data | string  | 非必须   |        |      |                   |
   | msg  | string  | 非必须   |        |      |                   |

### 文件上传代码

1. 引入阿里云OSS依赖

   ```xml
   <dependency>
       <groupId>com.aliyun.oss</groupId>
       <artifactId>aliyun-sdk-oss</artifactId>
       <version>${aliyun.sdk.oss}</version>
   </dependency>
   
   <dependency>
       <groupId>javax.xml.bind</groupId>
       <artifactId>jaxb-api</artifactId>
       <version>${jaxb-api}</version>
   </dependency>
   ```

2. 配置阿里云OSS

   ```yaml
   #application-dev.yaml
   sky:
     alioss:
       endpoint: aliyuncs
       XXXaccXXXess-key-id: 
       XXXacceXXXss-key-secrXXXet: 
       bucket-name: 
   ```

   ```yaml
   #application.yaml
   sky:
     alioss:
       endpoint: ${sky.alioss.endpoint}
       access-key-id: ${sky.alioss.access-key-id}
       access-key-secret: ${sky.alioss.access-key-secret}
       bucket-name: ${sky.alioss.bucket-name}
   ```

   此处是使用了自定义的配置属性类

   ```java
   @Component
   @ConfigurationProperties(prefix = "sky.alioss")
   @Data
   public class AliOssProperties {
       private String endpoint;
       private String accessKeyId;
       private String accessKeySecret;
       private String bucketName;
   }
   ```

3. 自定义的文件上传工具类，返回文件URL

   ```java
   @Data
   @AllArgsConstructor
   @Slf4j
   public class AliOssUtil {
   
       private String endpoint;
       private String accessKeyId;
       private String accessKeySecret;
       private String bucketName;
   
       //文件上传
       public String upload(byte[] bytes, String objectName) {
   
           // 创建OSSClient实例。
           OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
   
           try {
               // 创建PutObject请求。
               ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));
           } catch (OSSException oe) {
               System.out.println("Caught an OSSException, which means your request made it to OSS, "
                       + "but was rejected with an error response for some reason.");
               System.out.println("Error Message:" + oe.getErrorMessage());
               System.out.println("Error Code:" + oe.getErrorCode());
               System.out.println("Request ID:" + oe.getRequestId());
               System.out.println("Host ID:" + oe.getHostId());
           } catch (ClientException ce) {
               System.out.println("Caught an ClientException, which means the client encountered "
                       + "a serious internal problem while trying to communicate with OSS, "
                       + "such as not being able to access the network.");
               System.out.println("Error Message:" + ce.getMessage());
           } finally {
               if (ossClient != null) {
                   ossClient.shutdown();
               }
           }
   
           //文件访问路径规则 https://BucketName.Endpoint/ObjectName
           StringBuilder stringBuilder = new StringBuilder("https://");
           stringBuilder
                   .append(bucketName)
                   .append(".")
                   .append(endpoint)
                   .append("/")
                   .append(objectName);
   
           log.info("文件上传到:{}", stringBuilder.toString());
   
           return stringBuilder.toString();
       }
   }
   ```

4. 创建工具类

   ```java
   /**
    * 配置类，用于创建AliOssUtil对象
    */
   @Configuration
   @Slf4j
   public class OssConfiguration {
       @Bean	//把该对象交给IOC容器
       @ConditionalOnMissingBean	//保证只有一个配置类
       public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties){
           log.info("开始创建阿里云文件上传工具类对象：{}",aliOssProperties);
           return new AliOssUtil(aliOssProperties.getEndpoint(), aliOssProperties.getAccessKeyId(), 
                   aliOssProperties.getAccessKeySecret(), aliOssProperties.getBucketName());
       }
   }
   ```

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527110950606-1702080949.png" alt="image-20240527110958981" style="zoom:40%;" />

5. Controller

   ```java
   /**
    * 通用接口
    */
   @RestController
   @RequestMapping("/admin/common")
   @Slf4j
   @Api(tags = "通用接口")
   public class CommonController {
       @Autowired
       private AliOssUtil aliOssUtil;
   
       @PostMapping("/upload")
       @ApiOperation("文件上传")
       public Result<String> upload(MultipartFile file) {
           log.info("文件上传：{}", file.getOriginalFilename());
   
           try {
               String originalFilename = file.getOriginalFilename();
               //spaderman.jpg
               String extension = originalFilename.substring(originalFilename.lastIndexOf("."));
               //.jpg
               String objectName = UUID.randomUUID().toString() + extension;
               //784598cc-8ab6-4ebb-8132-82b7da229964.jpg
   
               String filePath = aliOssUtil.upload(file.getBytes(), objectName);
               //https://sunmengdi-oss-test01.oss-cn-beijing.aliyuncs.com/784598cc-8ab6-4ebb-8132-82b7da229964.jpg
   
               return Result.success(filePath);
           } catch (IOException e) {
               log.error("文件上传失败：{}", e.getMessage());
           }
           return Result.error(MessageConstant.UPLOAD_FAILED);
       }
   }
   ```

### 新增菜品代码

1. 创建一个接收数据的DTO对象

   ```java
   @Data
   public class DishDTO implements Serializable {
       private Long id;
       //菜品名称
       private String name;
       //菜品分类id
       private Long categoryId;
       //菜品价格
       private BigDecimal price;
       //图片
       private String image;
       //描述信息
       private String description;
       //0 停售 1 起售
       private Integer status;
       //口味
       private List<DishFlavor> flavors = new ArrayList<>();
   }
   //口味中用的是DishFlavor实体类型的List列表
   @Data
   @Builder
   @NoArgsConstructor
   @AllArgsConstructor
   public class DishFlavor implements Serializable {
       private static final long serialVersionUID = 1L;
       private Long id;
       //菜品id
       private Long dishId;
       //口味名称
       private String name;
       //口味数据list
       private String value;
   }
   ```

2. Controller

   ```java
   @RestController
   @RequestMapping("/admin/dish")
   @Api(tags = "菜品相关接口")
   @Slf4j
   public class DishController {
   
       @Autowired
       private DishService dishService;
   
       @PostMapping
       @ApiOperation("新增菜品")
       public Result save(@RequestBody DishDTO dishDTO) {//前端数据以JSON格式传出，需要@RequestBody获取
           log.info("新增菜品：{}", dishDTO);
           dishService.saveWithFlavor(dishDTO);
           return Result.success();
       }
   }
   ```

3. Service

   ```java
   public interface DishService {
       //新增菜品和对应的口味
       public void saveWithFlavor(DishDTO dishDTO);
   }
   ```

   由于要同时操作两张表，此处需要引入事务支持

   - 在方法上加@Transactional 
   - 在启动类上加@EnableTransactionManagement //开启注解方式的事务管理

   ```java
   @Service
   public class DishServiceImpl implements DishService {
   
       @Autowired
       private DishMapper dishMapper;
       @Autowired
       private DishFlavorMapper dishFlavorMapper;
   
       @Override
       @Transactional  //事务
       public void saveWithFlavor(DishDTO dishDTO) {
           //1.向菜品表插入1条数据
           Dish dish = new Dish();
           BeanUtils.copyProperties(dishDTO, dish);
           dishMapper.insert(dish);
   
           //获取insert语句生成的主键值
           Long dishId = dish.getId();	
   
           //2.向口味表插入N条数据
           List<DishFlavor> flavors = dishDTO.getFlavors();
           if (flavors != null && flavors.size() > 0) {
               flavors.forEach(dishFlavor -> {
                   dishFlavor.setDishId(dishId);//给口味对象的每一个DishID属性赋值
               });
               dishFlavorMapper.insertBatch(flavors);
           }
       }
   }
   ```

4. Dish-mapper

   ```java
   @AutoFill(OperationType.INSERT) //自动注入公共字段的属性值
   void insert(Dish dish);
   ```

   ```xml
   <insert id="insert" useGeneratedKeys="true" keyProperty="id">
       insert into dish (name, category_id, price, image, description, status, create_time, update_time, create_user,
                         update_user)
       values (#{name}, #{categoryId}, #{price}, #{image}, #{description}, #{status}, #{createTime}, #{updateTime},
               #{createUser}, #{updateUser});
   </insert>
   ```

5. Dish-Flavor-mapper

   ```java
   @Mapper
   public interface DishFlavorMapper {
       void insertBatch(List<DishFlavor> flavors);
   }
   ```

   批量注入多条数据，利用`foreach`

   ```xml
   <insert id="insertBatch">
       insert into dish_flavor(dish_id, name, value) VALUES
       <foreach collection="flavors" item="flavor" separator=",">
           (#{flavor.dishId},#{flavor.name},#{flavor.value})
       </foreach>
   </insert>
   ```

### 功能测试

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527142108519-670940079.png" alt="image-20240527142116915" style="zoom:40%;" />

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527142216343-445128572.png" alt="image-20240527142224778" style="zoom:40%;" />

### 阿里云OSS

- 阿里云是阿里巴巴集团旗下全球领先的云计算公司，也是国内最大的云服务提供商。
- 云服务：邮件服务、语音服务、短信服务、视频直播、视频点播、文字识别、实名认证、对象存储、机器翻译、内容安全、云数据库…等

阿里云对象存储OSS (object Storage Service)，是一款海量、安全、低成本、高可靠的云存储服务。使用OSS，您可以通过网络随时存储和调用包括文本、图片、音频和视频等在内的各种文件。阿里云OSS将数据文件以对象的形式上传到存储空间中。

- 第三方服务的通用思路：准备工作- ->参照官方SDK编写入门程序- ->集成使用
- SDK：SoftwareDevelopmentKit软件开发工具包，包括辅助软件开发的依赖(jar)、代码示例等

准备工作：

1. 注册阿里云，实名认证

2. 充值【少量数据可以不用】

3. 开通对象存储服务OSS

4. 创建bucket（OSS的存储空间，用于存储对象的容器，所有的对象都必须隶属于某个存储空间）

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527092149804-525017090.png" alt="image-20240527092157895" style="zoom:30%;" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527092604579-1756405898.png" alt="image-20240527092613320" style="zoom:33%;" />

5. 获取AccessKey密钥（包括AccessID和AccessSecret）

   - AccessKey ID 和 AccessKey Secret 是您访问阿里云 API 的密钥，具有该账户完全的权限，请您妥善保管。
   - 为降低 AccessKey 泄露的风险，自 2023 年 7 月 5 日起，新建的主账号 AccessKey 只在创建时提供 Secret，后续不可再进行查询，请保存好Secret。

根据SDK编写入门程序：

SDK官方文档：https://help.aliyun.com/zh/oss/developer-reference/overview-21?spm=5176.8466032.help.dexternal.268c1450NAXsV0

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527093325722-824151255.png" alt="image-20240527093333961" style="zoom:30%;" />

1. 使用Maven方式安装SDK

   ```xml
   <dependency>
       <groupId>com.aliyun.oss</groupId>
       <artifactId>aliyun-sdk-oss</artifactId>
       <version>3.15.1</version>
   </dependency>
   ```

2. 如果使用的是Java 9及以上的版本，则需要添加JAXB相关依赖。添加JAXB相关依赖示例代码如下：

   ```xml
   <dependency>
       <groupId>javax.xml.bind</groupId>
       <artifactId>jaxb-api</artifactId>
       <version>2.3.1</version>
   </dependency>
   <dependency>
       <groupId>javax.activation</groupId>
       <artifactId>activation</artifactId>
       <version>1.1.1</version>
   </dependency>
   <!-- no more than 2.3.3-->
   <dependency>
       <groupId>org.glassfish.jaxb</groupId>
       <artifactId>jaxb-runtime</artifactId>
       <version>2.3.3</version>
   </dependency>
   ```

3. 上传文件流示例代码

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527095034147-269119564.png" alt="image-20240527095042304" style="zoom:40%;" />

   ```java
   import com.aliyun.oss.ClientException;
   import com.aliyun.oss.OSS;
   import com.aliyun.oss.common.auth.*;
   import com.aliyun.oss.OSSClientBuilder;
   import com.aliyun.oss.OSSException;
   import com.aliyun.oss.model.PutObjectRequest;
   import com.aliyun.oss.model.PutObjectResult;
   import java.io.FileInputStream;
   import java.io.InputStream;
   
   public class Demo {
   
       public static void main(String[] args) throws Exception {
           //====================基本配置===================
           //1.指定地域节点 Endpoint
           String endpoint = "aliyuncs.com";
           //2. 从环境变量中获取访问凭证  运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET【新版】
           //EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();
           String acceXXXssKeyId="XXX";
           String accessKeySeXXXcret="XXX";
           //3. 填写Bucket名称
           String bucketName = "";
           //4. 指定在OSS中的位置  填写Object完整路径，完整路径中不能包含Bucket名称
           String objectName = "1.jpg";
           //5. 指定在本地中的位置  填写本地文件的完整路径，例如D:\\localpath\\examplefile.txt。
           // 如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。
           String filePath = "C:\\Users\\32354\\Pictures\\spaderman.jpg";
   
           //====================开始上传====================
           //1. 创建OSSClient实例
           //OSS ossClient = new OSSClientBuilder().build(endpoint, credentialsProvider);【新版】
           OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId , accessKeySecret);
   
           try {
               //2. 读取本地路径中上传文件流
               InputStream inputStream = new FileInputStream(filePath);
               //3. 创建PutObjectRequest对象
               PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, objectName, inputStream);
               //4. 创建PutObject请求。
               PutObjectResult result = ossClient.putObject(putObjectRequest);
           } catch (OSSException oe) {
               //输出错误日志
               System.out.println("Caught an OSSException, which means your request made it to OSS, "
                       + "but was rejected with an error response for some reason.");
               System.out.println("Error Message:" + oe.getErrorMessage());
               System.out.println("Error Code:" + oe.getErrorCode());
               System.out.println("Request ID:" + oe.getRequestId());
               System.out.println("Host ID:" + oe.getHostId());
           } catch (ClientException ce) {
               System.out.println("Caught an ClientException, which means the client encountered "
                       + "a serious internal problem while trying to communicate with OSS, "
                       + "such as not being able to access the network.");
               System.out.println("Error Message:" + ce.getMessage());
           } finally {
               if (ossClient != null) {
                   ossClient.shutdown();
               }
           }
       }
   } 
   ```

4. 上传完毕

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527095745759-1421426884.png" alt="image-20240527095754402" style="zoom:35%;" />

5. 查看阿里云的OSS

   为每一个图片文件赋一个URL

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527095900763-1772865199.png" alt="image-20240527095909154" style="zoom:30%;" />

集成OSS-UploadController

基本步骤：接收上传的图片、将图片存储起来(OSS)、返回图片访问的URL

1. 引入阿里云OSS上传文件工具类【示例代码修改而来】

   ```java
   @Component
   public class AliOSSUtils {
       //1.指定地域节点 Endpoint
       private String endpoint = "aliyuncs.com";
       //2. 获取访问凭证
       private String accXXXessKeyId = "XXX";
       private String acceXXssKeySeXXXcret = "xXX";
       //3. 填写Bucket名称
       private String bucketName = "";
   
       /*
       实现上传图片到OSS
        */
       public String upload(MultipartFile file) throws IOException {
           //1. 获取上传文件的输入流
           InputStream inputStream = file.getInputStream();
   
           //2. 避免文件覆盖
           String originalFilename = file.getOriginalFilename();//原始文件名
           String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf('.'));//UUID+文件后缀名
   
           //3. 上传文件到OSS
           OSS ossCilent = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
   
           //4. 文件访问路径
           String url = endpoint.split("//")[0] + "//" + bucketName + "." + endpoint.split("//")[1] + "/"+fileName;
   
           //5. 关闭ossClient
           ossCilent.shutdown();
           //6. 把上传到OSS的路径返回
           return url;
       }
   } 
   ```

2. 上传图片接口开发

   ```java
   @Autowared
   private AliOSSUtils aliOSSUtils;
   @PostMapping("/upload")
   public Result upload(MultipartFile image) throw IOEception{
       log.info("文件上传，文件名为：{}",image.getOriginalFilename());
       //调用OSS工具类实现图片上传
       String url = aliOSSUtils.upload(image);
       log.info("文件上传完成，文件访问的URL为：{}",url);
       
       return Result.success(url);
   }
   ```

   

## 菜品分页查询

### 需求分析

接口路径：GET/admin/dish/page

请求参数

Query：

| 参数名称   | 是否必须 | 示例     | 备注       |
| :--------- | :------- | :------- | :--------- |
| categoryId | 否       | 101      | 分类id     |
| name       | 否       | 宫保鸡丁 | 菜品名称   |
| page       | 是       | 1        | 页码       |
| pageSize   | 是       | 10       | 每页记录数 |
| status     | 否       | 1        | 分类状态   |

返回数据

| 名称 | 类型   | 是否必须 | 默认值 | 备注 | 其他信息 |
| :--- | :----- | :------- | :----- | :--- | :------- |
| code | number | 必须     |        |      |          |
| msg  | null   | 非必须   |        |      |          |
| data | object | 必须     |        |      |          |

### 代码开发

1. 设计DTO，前端给后端的数据

   ```java
   @Data
   public class DishPageQueryDTO implements Serializable {
       private int page;
       private int pageSize;
       private String name;
       //分类id
       private Integer categoryId;
       //状态 0表示禁用 1表示启用
       private Integer status;
   }
   ```

2. 设计VO，后端给前端的数据

   ```java
   @Data
   @Builder
   @NoArgsConstructor
   @AllArgsConstructor
   public class DishVO implements Serializable {
   
       private Long id;
       //菜品名称
       private String name;
       //菜品分类id
       private Long categoryId;
       //菜品价格
       private BigDecimal price;
       //图片
       private String image;
       //描述信息
       private String description;
       //0 停售 1 起售
       private Integer status;
       //更新时间
       private LocalDateTime updateTime;
       //分类名称
       private String categoryName;	//需要特别注意
       //菜品关联的口味
       private List<DishFlavor> flavors = new ArrayList<>();
   }
   ```

3. Controller

   ```java
   @GetMapping("/page")
   @ApiOperation("菜品分页查询")
   public Result<PageResult> page(DishPageQueryDTO dishPageQueryDTO) {//不需要@RequestBody，因为是以参数?xx=xx传出的
       log.info("菜品分页查询：{}", dishPageQueryDTO);
       PageResult pageResult = dishService.pageQuery(dishPageQueryDTO);
       return Result.success(pageResult);
   }
   ```

4. Service

   ```java
   PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);
   
   @Override
   public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) {
       PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
       Page<DishVO> page = dishMapper.pageQuery(dishPageQueryDTO);
   
       return new PageResult(page.getTotal(), page.getResult());
   }
   ```

5. Mapper

   ```java
   Page<DishVO> pageQuery(DishPageQueryDTO dishPageQueryDTO);
   ```

   ```xml
   <select id="pageQuery" resultType="com.sky.vo.DishVO">
       select d.*, c.name as categoryName
       from dish d
       left join category c on d.category_id = c.id
       <where>
           <if test="name!=null">
               and d.name like concat('%',#{name},'%')
           </if>
           <if test="categoryId!=null">
               and d.category_id like concat('%',#{categoryId},'%')
           </if>
           <if test="status!=null">
               and d.status like concat('%',#{status},'%')
           </if>
       </where>
       order by d.create_time desc
   </select>
   ```

### 功能测试

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527172819370-453180141.png" alt="image-20240527172828101" style="zoom:35%;" />

## 删除菜品

### 需求分析

1. 可以一次删除一个菜品，也可以批量删除菜品【dish】
2. 起售状态的菜品不能删除
3. 被套餐关联的菜品不能删除【setmeal_dish】
4. 删除菜品后，关联的口味也需要删除【dish_flavor】

批量删除接口：

接口路径：DELETE/admin/dish

请求参数

Query：

| 参数名称 | 是否必须 | 示例  | 备注                   |
| :------- | :------- | :---- | :--------------------- |
| ids      | 是       | 1,2,3 | 菜品id，之间用逗号分隔 |

返回数据

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息          |
| :--- | :------ | :------- | :----- | :--- | :---------------- |
| code | integer | 必须     |        |      | **format:** int32 |
| data | string  | 非必须   |        |      |                   |
| msg  | string  | 非必须   |        |      |                   |

### 代码开发

1. Controller

   ```java
   @DeleteMapping
   @ApiOperation("菜品的批量删除")
   public Result delete(@RequestParam List<Long> ids) {
       log.info("菜品的批量删除：{}", ids);
   
       dishService.deleteBatch(ids);
       return Result.success();
   }
   ```

2. Service

   ```java
   void deleteBatch(List<Long> ids);
   ```

   ```java
   @Override
   @Transactional
   public void deleteBatch(List<Long> ids) {
       //判断菜品是否起售中
       ids.forEach(id -> {
           Dish dish = dishMapper.getById(id);
           if (dish.getStatus() == StatusConstant.ENABLE) {
               //起售中
               throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
           }
       });
   
       //判断菜品是否关联套餐
       List<Long> setmealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);
       if (setmealIds != null && setmealIds.size() > 0) {
           //当前餐品被套餐关联了
           throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
       }
   
       //删除菜品数据
       for (Long id : ids) {
           dishMapper.deleteById(id);
           //删除菜品关联的口味
           dishFlavorMapper.deleteByDishId(id);
       }
   }
   ```

3. mapper

   DishMapper

   ```java
   @Select("select * from dish where id=#{id} ")
   Dish getById(Long id);
   
   //根据主键删除菜品数据
   @Delete("delete from dish where id=#{id} ")
   void deleteById(Long id);
   ```

   SetmealDishMapper

   ```java
   @Mapper
   public interface SetmealDishMapper {
       //根据菜品id查询对应的套餐id
       List<Long> getSetmealIdsByDishIds(List<Long> dishIds);
   }
   ```

   ```xml
   <select id="getSetmealIdsByDishIds" resultType="java.lang.Long">
       select setmeal_id from setmeal_dish where dish_id in
       <foreach collection="dishIds" item="dishId" separator="," open="(" close=")">
           #{dishId}
       </foreach>
   </select>
   ```

### 功能测试

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527184616826-2079449518.png" alt="image-20240527184625412" style="zoom:33%;" />

### 优化

```java
//循环执行两条SQL语句，效率大大降低
for (Long id : ids) {
    dishMapper.deleteById(id);
    dishFlavorMapper.deleteByDishId(id);
}
```

优化后：批量删除

```java
//DishServiceImpl.java
dishMapper.deleteByIds(ids);
dishFlavorMapper.deleteByDishIds(ids);
```

```java
void deleteByIds(List<Long> ids);
```

```xml
<delete id="deleteByIds">
    delete
    from dish
    where id in
    <foreach collection="ids" item="id" open="(" close=")" separator=",">
        #{id}
    </foreach>
</delete>
```

```java
void deleteByDishIds(List<Long> dishIds);
```

```xml
<delete id="deleteByDishIds">
    delete
    from dish_flavor
    where dish_id in
    <foreach collection="dishIds" open="(" close=")" separator="," item="dishId">
        #{dishId}
    </foreach>
</delete>
```

## 修改菜品

### 需求分析

1. 根据id查询菜品信息回显
2. 根据类型查询分类
3. 图片重写上传
4. 更新信息

### 代码开发

根据id查询菜品信息回显

1. Controller

   ```java
   @GetMapping("/{id}")
   @ApiOperation("根据id查询菜品")
   public Result<DishVO> getById(@PathVariable Long id) {
       log.info("根据ID查询菜品：{}", id);
       DishVO dishVO = dishService.getByIdWithFlavor(id);
       return Result.success(dishVO);
   }
   ```

2. Service

   ```java
   DishVO getByIdWithFlavor(Long id);
   ```

   ```java
   @Override
   public DishVO getByIdWithFlavor(Long id) {
       //根据ID查询菜品数据
       Dish dish = dishMapper.getById(id);
       //根据菜品ID查询口味数据
       List<DishFlavor> dishFlavors = dishFlavorMapper.getByDishId(id);
   
       //根据查询到的数据封装到VO
       DishVO dishVO = new DishVO();
       BeanUtils.copyProperties(dish, dishVO);
       dishVO.setFlavors(dishFlavors);
   
       return dishVO;
   }
   ```

3. mapper

   ```java
   @Select("select * from dish_flavor where dish_id= #{dishId} ")
   List<DishFlavor> getByDishId(Long dishId);
   ```

更新菜品信息

1. Controller

   ```java
   @PutMapping
   @ApiOperation("修改菜品")
   public Result update(@RequestBody DishDTO dishDTO) {
       log.info("修改菜品：{}", dishDTO);
       dishService.updateWithFlavor(dishDTO);
       return Result.success();
   }
   ```

2. Service

   ```java
   void updateWithFlavor(DishDTO dishDTO);
   ```

   ```java
   @Override
   public void updateWithFlavor(DishDTO dishDTO) {
       //修改菜品表的基本信息
       Dish dish = new Dish();
       BeanUtils.copyProperties(dishDTO, dish);
       dishMapper.update(dish);
   
       //删除原有口味
       dishFlavorMapper.deleteByDishId(dishDTO.getId());
   
       //插入新口味
       List<DishFlavor> flavors = dishDTO.getFlavors();
       if (flavors != null && flavors.size() > 0) {
           flavors.forEach(dishFlavor -> {
               dishFlavor.setDishId(dishDTO.getId());
           });
       }
       dishFlavorMapper.insertBatch(flavors);
   }
   ```

3. DishMapper

   ```java
   @AutoFill(OperationType.UPDATE)
   void update(Dish dish);
   ```

   ```xml
   <update id="update">
       update dish
       <set>
           <if test="name != null">
               name = #{name},
           </if>
           <if test="categoryId != null">
               category_id = #{categoryId},
           </if>
           <if test="price != null">
               price = #{price},
           </if>
           <if test="image != null">
               image = #{image},
           </if>
           <if test="description != null">
               description = #{description},
           </if>
           <if test="status != null">
               status = #{status},
           </if>
           <if test="updateTime != null">
               update_time = #{updateTime},
           </if>
           <if test="updateUser != null">
               update_user = #{updateUser},
           </if>
       </set>
       where id=#{id}
   </update>
   ```

   Dish-flavor-mapper

   ```java
   void deleteByDishIds(List<Long> dishIds);
   ```

   ```xml
   <delete id="deleteByDishIds">
       delete
       from dish_flavor
       where dish_id in
       <foreach collection="dishIds" open="(" close=")" separator="," item="dishId">
           #{dishId}
       </foreach>
   </delete>
   ```

### 功能测试

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240527193707443-1560100743.png" alt="image-20240527193716071" style="zoom:33%;" />

# 套餐管理模块

完成套餐管理模块所有业务功能，包括：

- 新增套餐
- 套餐分页查询
- 删除套餐
- 修改套餐
- 起售停售套餐



要求：

1. 根据产品原型进行需求分析，分析出业务规则
2. 设计接口
3. 梳理表之间的关系（分类表、菜品表、套餐表、口味表、套餐菜品关系表）
4. 根据接口设计进行代码实现
5. 分别通过swagger接口文档和前后端联调进行功能测试

## 新增套餐

### 需求分析

接口设计（共涉及到4个接口）：

- 根据类型查询分类（已完成）
- 根据分类id查询菜品
- 图片上传（已完成）
- 新增套餐

### 代码实现

根据分类id查询菜品

1. Controller

   ```java
   @GetMapping("/list")
   @ApiOperation("根据分类ID查询菜品")
   public Result<List<Dish>> getDishBycategoryId(Long categoryId) {
       log.info("根据分类ID-{}，开始查询菜品", categoryId);
   
       List<Dish> dishes = dishService.getDishBycategoryId(categoryId);
   
       return Result.success(dishes);
   }
   ```

2. Service

   - 取长：在获取菜品时，应该判断状态是否可以用，此处不只是传递一个categoryId参数，而应该传递一个Dish参数
   - 同时操作多个表，使用事务处理

   ```java
   List<Dish> getDishBycategoryId(Long categoryId);
   
   @Override
   @Transactional
   public List<Dish> getDishBycategoryId(Long categoryId) {
        Dish dish = Dish.builder()
                   .categoryId(categoryId)
                   .status(StatusConstant.ENABLE)
                   .build();
           return dishMapper.getDishBycategoryId(dish);
   }
   ```

3. Mapper

   - 取长：查询时采用动态SQL，判断当条件不为空时再查询

   ```java
   List<Dish> getDishBycategoryId(Dish dish);
   
   <select id="getDishBycategoryId" resultType="com.sky.entity.Dish">
       select *
       from dish
       <where>
           <if test="name != null">
               and name like concat('%',#{name},'%')
           </if>
           <if test="categoryId != null">
                and category_id = #{categoryId}
           </if>
           <if test="status != null">
               and status = #{status}
           </if>
       </where>
       order by create_time desc
   </select>
   ```

新增套餐

1. Controller

   - 取长：此处使用的对象应该是SetmealDTO，数据传输对象DTO是封装接受请求头传来的数据，视图对象VO是封装后端返回给前端页面的数据
   - 由于接收的数据是根据前端传来的请求头的JSON字符串里的，所以参数应该加上@RequestBody注释

   ```java
   @RestController
   @RequestMapping("/admin/setmeal")
   @Api(tags = "套餐相关接口")
   @Slf4j
   public class SetmealController {
       @Autowired
       private SetmealService setmealService;
   
       @PostMapping
       @ApiOperation("新增套餐")
       public Result insertSetmeal(@RequestBody SetmealDTO setmealDTO) {
           log.info("开始新增套餐：{}", setmealDTO);
   
           setmealService.insertSetmeal(setmealDTO);
   
           return Result.success();
       }
   }
   ```

2. Service 

   - 取长：应该在插入套餐之后，获取套餐ID并且赋值给套餐里的菜品

   ```java
    void insertSetmeal(SetmealDTO setmealDTO);
   
   @Override
   public void insertSetmeal(SetmealDTO setmealDTO) {
       Setmeal setmeal = new Setmeal();
       BeanUtils.copyProperties(setmealDTO, setmeal);
   
       setmealMapper.insertSetmeal(setmeal);
   
       List<SetmealDish> setmealDishes = setmealDTO.getSetmealDishes();
       Long setmealId = setmeal.getId();
   
       setmealDishes.forEach(setmealDish -> {
           setmealDish.setSetmealId(setmealId);
       });
   
       setmealDishMapper.insertMealDishes(setmealDishes);
   }
   ```

3. mapper

   SetmealMapper

   ```java
   @AutoFill(OperationType.INSERT)
   void insertSetmeal(Setmeal setmeal);
   ```

   - 此处重点是要加上：`useGeneratedKeys="true" keyProperty="id"`  
   - useGeneratedKeys 参数只针对 insert 语句生效，默认为 false。表示插入数据之后`返回一个自增的主键id`给你对应实体类中的主键属性。通过这个设置可以`解决在主键自增的情况下通过实体的getter方法获取主键`
   - 当然还需要keyproperty指明[数据库]中返回的主键id给实体类中的哪个属性。 keyproperty=主键，这样就可以解决在主键自增的情况下获取主键。
   - 如果不加，则在Service中无法获得套餐的ID

   ```xml
   <insert id="insertSetmeal" useGeneratedKeys="true" keyProperty="id">
       insert into setmeal (category_id, name, price, status, description, image, create_time, update_time,
                            create_user, update_user)
       values (#{categoryId}, #{name}, #{price}, #{status}, #{description}, #{image}, #{createTime}, #{updateTime},
               #{createUser}, #{updateUser})
   </insert>
   ```

   SetmealDishMapper

   ```java
   void insertMealDishes(List<SetmealDish> setmealDishes);
   ```

   - 此处重点是要`separator=","`  因为insert into XX(x,x,x)  values (x),(y)
   - 循环遍历插入的值要写为：`item.properties`

   ```xml
   <insert id="insertMealDishes">
           insert into setmeal_dish (setmeal_id, dish_id, name, price, copies) values
           <foreach collection="setmealDishes" item="setmealDish" separator=",">
               (#{setmealDish.setmealId}, #{setmealDish.dishId}, #{setmealDish.name}, #{setmealDish.price},
               #{setmealDish.copies})
           </foreach>
       </insert>
   ```

## 套餐分页查询

### 需求分析

接口路径：GET/admin/setmeal/page

请求参数

Query：

| 参数名称   | 是否必须 | 示例 | 备注         |
| :--------- | :------- | :--- | :----------- |
| categoryId | 否       |      | 分类id       |
| name       | 否       |      | 套餐名称     |
| page       | 是       |      | 页码         |
| pageSize   | 是       |      | 每页记录数   |
| status     | 否       |      | 套餐起售状态 |

返回数据

| 名称           | 类型      | 是否必须 | 默认值 | 备注 | 其他信息              |
| :------------- | :-------- | :------- | :----- | :--- | :-------------------- |
| code           | number    | 必须     |        |      |                       |
| msg            | null      | 非必须   |        |      |                       |
| data           | object    | 非必须   |        |      |                       |
| - total        | number    | 非必须   |        |      |                       |
| - records      | object [] | 非必须   |        |      | **item 类型:** object |
| - id           | number    | 必须     |        |      |                       |
| - categoryId   | number    | 必须     |        |      |                       |
| - name         | string    | 必须     |        |      |                       |
| - price        | number    | 必须     |        |      |                       |
| - status       | number    | 必须     |        |      |                       |
| - description  | string    | 必须     |        |      |                       |
| - image        | string    | 必须     |        |      |                       |
| - updateTime   | string    | 必须     |        |      |                       |
| - categoryName | string    | 必须     |        |      |                       |

### 代码实现

1. Controller

   - 取长：分页查询返回PageResult对象

   ```java
   @GetMapping("/page")
   @ApiOperation("分页查询")
   public Result<PageResult> pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) {
       log.info("分页查询{}", setmealPageQueryDTO);
   
       PageResult pageResult = setmealService.pageQuery(setmealPageQueryDTO);
   
       return Result.success(pageResult);
   }
   ```

2. Service

   ```java
   PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);
   ```

   - 分页使用PageHelper.startPage()方法，页面大小和页数在DTO对象中获取。此方法返回Page泛型，设置类型为SetmealVO
   - return  PageResult对象 参数为page.getTotal(), page.getResult()

   ```java
   @Override
   public PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) {
       PageHelper.startPage(setmealPageQueryDTO.getPage(), setmealPageQueryDTO.getPageSize());
       Page<SetmealVO> page = setmealMapper.pageQuery(setmealPageQueryDTO);
   
       return new PageResult(page.getTotal(), page.getResult());
   }
   ```

3. mapper

   ```java
   Page<SetmealVO> pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);
   ```

   - 查询所有套餐，限制条件为请求体内参数构成的动态SQL
   - 注意：多表查询，分类名称需要从分类表查询；完善排序

   ```xml
   <select id="pageQuery" resultType="com.sky.vo.SetmealVO">
       select s.*,c.name cateGoryName
       from setmeal s left join category c on s.category_id = c.id
       <where>
           <if test="name!=null">
               and s.name like concat('%',#{name},'%')
           </if>
           <if test="categoryId!=null">
               and s.category_id=#{categoryId}
           </if>
           <if test="status!=null">
               and s.status=#{status}
           </if>
       </where>
       order by s.category_id desc
   </select>
   ```

## 删除套餐

### 需求分析

1. 删除套餐

   验证状态

2. 删除套餐关联的菜品

### 代码实现

1. Controller

   - 注意：前端传来的参数ids不是以JSON格式，所以要用@RequestParam；因为参数名不一致，所以要指明传来的参数名

   ```java
   @DeleteMapping
   @ApiOperation("批量删除套餐")
   public Result deleteMeal(@RequestParam("ids") List<Long> setmealIds) {
       log.info("批量删除{}", setmealIds);
   
       setmealService.deleteMeal(setmealIds);
       return Result.success();
   }
   ```

2. Service

   ```java
   void deleteMeal(List<Long> setmealIds);
   ```

   ```java
   @Override
   public void deleteMeal(List<Long> setmealIds) {
       //先判断状态是不是开售，只有停售状态才可以删除
       setmealIds.forEach(setmealId -> {
           Setmeal setmeal = setmealMapper.getMealById(setmealId);
           if (setmeal.getStatus().equals(StatusConstant.ENABLE)) {
               throw new DeletionNotAllowedException(MessageConstant.SETMEAL_ON_SALE);
           }
       });
       setmealMapper.deleteMeal(setmealIds);
       setmealDishMapper.deleteDish(setmealIds);
   }
   ```

3. Mapper

   SetmealMapper

   ```java
   void deleteMeal(List<Long> setmealIds);
   ```

   - 注意foreach标签的使用delete form X where id in (x,x,x)

   ```xml
   <delete id="deleteMeal">
       delete from setmeal where id in
       <foreach collection="setmealIds" item="id" separator="," open="(" close=")">
           #{id}
       </foreach>
   </delete>
   ```

   SetmealDishMapper

   ```java
   void deleteDish(List<Long> setmealIds);
   ```

   ```xml
   <delete id="deleteDish">
       delete
       from setmeal_dish
       where dish_id in
       <foreach collection="setmealIds" item="id" separator="," open="(" close=")">
           #{id}
       </foreach>
   </delete>
   ```

## 修改套餐

### 需求分析

1. 根据ID查询套餐
2. 修改套餐

### 代码实现

根据ID查询套餐

1. Controller

   ```java
   @GetMapping("/{id}")
   @ApiOperation("根据ID查询套餐")
   public Result<SetmealVO> querySetmealById(@PathVariable Long id) {
       log.info("根据ID-{}查询套餐", id);
   
       SetmealVO setmealVO = setmealService.querySetmealById(id);
       return Result.success(setmealVO);
   }
   ```

2. Service

   ```java
   SetmealVO querySetmealById(Long id);
   
   @Override
   public SetmealVO querySetmealById(Long id) {
       Setmeal setmeal = setmealMapper.querySetmealById(id);
   
       SetmealVO setmealVO = new SetmealVO();
       BeanUtils.copyProperties(setmeal, setmealVO);
   
       List<SetmealDish> query = setmealDishMapper.query(id);
       setmealVO.setSetmealDishes(query);
   
       return setmealVO;
   }
   ```

3. Mapper

   setmealMapper

   ```java
   @Select("select * from setmeal where id=#{id} ")
   Setmeal querySetmealById(Long id);
   ```

   setmealDishMapper

   ```java
   @Select("select * from setmeal_dish where dish_id=#{id} ")
   List<SetmealDish> query(Long id);
   ```

修改套餐

1. Controller

   ```java
   @PutMapping
   @ApiOperation("修改套餐")
   public Result update(@RequestBody SetmealDTO setmealDTO) {
       log.info("修改套餐{}", setmealDTO);
   
       setmealService.update(setmealDTO);
       return Result.success();
   }
   ```

2. Service

   - 同时修改两张表，应该加上事务处理

   ```java
   void update(SetmealDTO setmealDTO);
   
   @Override
   @Transactional
   public void update(SetmealDTO setmealDTO) {
       Setmeal setmeal = new Setmeal();
       BeanUtils.copyProperties(setmealDTO, setmeal);
       setmealMapper.update(setmeal);
   
       Long setmealId = setmeal.getId();
   
       setmealDishMapper.deleteDishById(setmealId);
   
       List<SetmealDish> setmealDishes = setmealDTO.getSetmealDishes();
       if (setmealDishes.size() > 0) {
           setmealDishMapper.insertMealDishes(setmealDishes);
       }
   }
   ```

3. Mapper

   SetmealMapper

   ```java
   @AutoFill(OperationType.UPDATE)
   void update(Setmeal setmeal);
   ```

   ```xml
   <update id="update" useGeneratedKeys="true" keyProperty="id">
       update setmeal
       <set>
           <if test="categoryId!=null">
               category_id=#{categoryId},
           </if>
           <if test="name!=null">
               name=#{name},
           </if>
           <if test="price!=null">
               price=#{price},
           </if>
           <if test="status!=null">
               status=#{status},
           </if>
           <if test="description!=null">
               description=#{description},
           </if>
           <if test="image!=null">
               image=#{image},
           </if>
       </set>
       where id=#{id}
   </update>
   ```

   SetmealDishMapper

   ```java
   @Delete("delete from setmeal_dish where setmeal_id=#{setmealId} ")
   void deleteDishById(Long setmealId);
   ```

## 起售停售套餐

### 代码实现

1. Controller

   ```java
   @PostMapping("/status/{status}")
   public Result saleStartOrStop(@PathVariable Long status, @RequestParam Long id) {
       log.info("套餐起售停售状态{}", status);
   
       setmealService.saleStartOrStop(status, id);
       return Result.success();
   }
   ```

2. Service

   ```java
   void saleStartOrStop(Long status, Long id);
   
   @Override
   public void saleStartOrStop(Long status, Long id) {
       setmealMapper.saleStartOrStop(status, id);
   }
   ```

3. Mapper

   ```java
   @Update("update setmeal set status = #{status} where id=#{id}")
   void saleStartOrStop(Long status, Long id);
   ```

# 参数小结

| 参数位置        | 注释          |
| --------------- | ------------- |
| 路径参数        | @PathVariable |
| Query，请求参数 | @RequestParam |
| Body，请求体    | @RequestBody  |

# 店铺营业状态设置

## 需求分析

涉及到的接口：

1. 设置营业状态
2. 客户端获取营业状态
3. 服务端获取营业状态

营业状态数据存储方式：基于Redis的字符串来存储【不常变动，访问多】

|     key     |  value  |
| :---------: | :-----: |
| SHOP_STATUS | 1[营业] |

## 代码开发

管理端

```java
@RestController("adminShopController")
@RequestMapping("/admin/shop")
@Api(tags = "店铺相关接口")
@Slf4j
public class ShopController {
    public static final String KEY="SHOP_STATUS";
    
    @Autowired
    RedisTemplate redisTemplate;

    @PutMapping("/{status}")
    @ApiOperation("设置营业状态")
    public Result setStatus(@PathVariable Integer status) {
        log.info("设置营业状态：{}", status == 1 ? "营业中" : "打烊中");

        redisTemplate.opsForValue().set(KEY, status);
        return Result.success();
    }

    @GetMapping("/status")
    @ApiOperation("获取店铺的营业状态")
    public Result<Integer> getStatus() {
        Integer shopStatus = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info("获取店铺的营业状态为：{}", shopStatus == 1 ? "营业中" : "打烊中");
        return Result.success(shopStatus);
    }
}
```

客户端

```java
@RestController("userShopController")
@RequestMapping("/user/shop")
@Api(tags = "店铺相关接口")
@Slf4j
public class ShopController {
    public static final String KEY = "SHOP_STATUS";

    @Autowired
    RedisTemplate redisTemplate;

    @GetMapping("/status")
    @ApiOperation("获取店铺的营业状态")
    public Result<Integer> getStatus() {
        Integer shopStatus = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info("获取店铺的营业状态为：{}", shopStatus == 1 ? "营业中" : "打烊中");
        return Result.success(shopStatus);
    }
}
```

## 优化接口文档

```java
//WebMvcConfigura
/**
 * 通过knife4j生成接口文档
 *
 * @return
 */
@Bean
public Docket docket() {
    log.info("准备生成接口文档....");
    ApiInfo apiInfo = new ApiInfoBuilder()
            .title("苍穹外卖项目接口文档")
            .version("2.0")
            .description("苍穹外卖项目接口文档")
            .build();
    Docket docket = new Docket(DocumentationType.SWAGGER_2)
            .groupName("管理端接口")
            .apiInfo(apiInfo)
            .select()
            .apis(RequestHandlerSelectors.basePackage("com.sky.controller.admin"))
            .paths(PathSelectors.any())
            .build();
    return docket;
}

@Bean
public Docket docket2() {
    log.info("准备生成接口文档....");
    ApiInfo apiInfo = new ApiInfoBuilder()
            .title("苍穹外卖项目接口文档")
            .version("2.0")
            .description("苍穹外卖项目接口文档")
            .build();
    Docket docket = new Docket(DocumentationType.SWAGGER_2)
            .groupName("客户端接口")
            .apiInfo(apiInfo)
            .select()
            .apis(RequestHandlerSelectors.basePackage("com.sky.controller.user"))
            .paths(PathSelectors.any())
            .build();
    return docket;
}
```

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240529152739767-718339263.png" alt="image-20240529152747562" style="zoom:30%;" />

# VUE

参考文章：http://t.csdnimg.cn/QlTsL

## Vue基础

### 使用VueCli创建前端工程

#### 环境要求

要想基于脚手架创建前端工程，需要具备如下环境要求：

- ​	**node.js** 	前端项目的运行环境
- ​	**npm**          JavaScript的包管理工具
- ​	**Vue CLI**    基于Vue进行快速开发的完整系统，实现交互式的项目脚手架

#### 操作过程

使用 Vue CLI 创建前端工程的方式：

- ​	方式一：vue create 项目名称
- ​	方式二：vue ui

1. vue create vue-demo-1

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604162945756-2085755915.png" alt="image-20240604162945735" style="zoom:33%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604163034995-117580765.png" alt="image-20240604163035178" style="zoom:33%;" />

2. vue ui

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604163219640-1098441130.png" alt="image-20240604163219364" style="zoom: 33%;" />

   第一步：在命令行输入命令 vue ui,在浏览器ui界面中选择前端工程存放的位置

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604163903277-19862629.png" alt="image-20230925100950987" style="zoom:33%;" />

   第二步：点击“在此创建新项目”按钮，跳转到创建新项目设置页面

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604163903227-244199943.png" alt="image-20230925101106692" style="zoom:33%;" />

   第三步：填写项目名称、选择包管理器为npm，点击“下一步”按钮

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604163903297-672995758.png" alt="image-20230925101202363" style="zoom:33%;" />

   第四步：选择 Default(Vue 2)，点击"创建项目"按钮，完成项目的创建

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604163903163-89999322.png" alt="image-20230925101317873" style="zoom:33%;" />

#### 工程结构

工程目录结构：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031479-268578812.png" alt="image-20230925103418213" style="zoom:43%;" />

重点文件或目录介绍：

- node_modules：当前项目依赖的js包
- src
  - assets：静态资源存放目录
  - components：公共组件存放目录
  - App.vue：项目的主组件，页面的入口文件
  - main.js：整个项目的入口文件

- package.json：项目的配置信息、依赖包管理
- vue.config.js：vue-cli配置文件

#### 启动前端服务

使用VS Code打开创建的前端工程，启动前端工程：`npm run serve`

![image-20230925103813210](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031527-1841909784.png)

访问前端工程：

![image-20230925103913672](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031665-2084472519.png)

注：要停止前端服务，可以在命令行终端使用 `ctrl + C `

前端项目启动后，服务端口默认为8080，很容易和后端tomcat端口号冲突。可以在vue.config.js中配置前端服务端口号：

~~~javascript
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  devServer: {
    port: 7070  //指定前端服务端口号
  }
})
~~~

### vue基本使用方式

本章节从如下几个方面进行vue回顾：

- vue 组件
- 文本插值
- 属性绑定
- 事件绑定
- 双向绑定
- 条件渲染
- axios

#### vue 组件

Vue 的组件文件以 .vue 结尾，每个组件由三部分组成：

- 结构 <template>
- 样式 <style>
- 逻辑 <script>

![image-20230925111404674](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031624-1950670229.png)

#### 文本插值

作用：用来绑定 data 方法返回的对象属性

用法：{{插值表达式}}

示例：

![image-20230925111739838](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031532-10062728.png)

#### 属性绑定v-bind

作用：为标签的属性绑定 data 方法中返回的属性

用法：v-bind:xxx，简写为 :xxx

示例：

![image-20230925112435816](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031557-1405523326.png)

#### 事件绑定v-on

作用：为元素绑定对应的事件

用法：v-on:xxx，简写为 @xxx

示例：

![image-20230925112514956](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031496-1085146642.png)

#### 双向绑定v-model

作用：表单输入项和 data 方法中的属性进行绑定，任意一方改变都会同步给另一方

用法：v-model

示例：

![image-20230925112600375](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031679-1201904310.png)

#### 条件渲染v-else-if

作用：根据表达式的值来动态渲染页面元素

用法：v-if、v-else、v-else-if

示例：

![image-20230925112635467](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031691-91683055.png)

#### axios

[Axios](https://www.axios-http.cn/) 是一个基于 promise 的 网络请求库，作用于浏览器和 node.js 中。使用Axios可以在前端项目中发送各种方式的HTTP请求。

- 安装命令：npm install axios


- 导入：import axios from 'axios'


axios 的 API 列表：

![image-20230925112806943](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031745-702706073.png)

参数说明：

- url：请求路径
- data：请求体数据，最常见的是JSON格式数据
- config：配置对象，可以设置查询参数、请求头信息

注：在使用axios时，经常会遇到跨域问题，可以在 vue.config.js 文件中配置代理：

![image-20240604172552459](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604172552746-590616958.png)

~~~javascript
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  devServer: {
    port: 7070,
    proxy: {
      '/api': {	//	拦截/api请求
        target: 'http://localhost:8080',	//转发到该地址
        pathRewrite: {	//把/api改为空
          '^/api': ''
        }
      }
    }
  }
})
~~~

axios的post请求示例：

~~~javascript
axios.post('/api/admin/employee/login',{
      username:'admin',
      password: '123456'
    }).then(res => {
      console.log(res.data)
    }).catch(error => {
      console.log(error.response)
    })
~~~

axios的get请求示例：

~~~javascript
axios.get('/api/admin/shop/status',{
        headers: {
          token: ‘xxx.yyy.zzz’
        }
      })
~~~

axios提供的统一使用方式示例一（可以发送各种方式的请求）：axios(config)

![image-20230925113501390](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031666-704360883.png)

axios提供的统一使用方式示例二（可以发送各种方式的请求）：https://www.axios-http.cn/docs/req_config

~~~javascript
axios({
      url: '/api/admin/employee/login',
      method:'post',
      data: {
        username:'admin',
        password: '123456'
      }
    }).then((res) => {
      console.log(res.data.data.token)
      axios({
        url: '/api/admin/shop/status',
        method: 'get',
        params: {id: 100},
        headers: {
          token: res.data.data.token
        }
      })
    }).catch((error) => {
      console.log(error)
    })
~~~

## 路由 Vue-Router

### Vue-Router 介绍

vue 属于单页面应用，所谓路由，就是根据浏览器路径不同，用不同的视图组件替换这个页面内容。

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031712-799959978.png" alt="image-20230925142650279" style="zoom:50%;" />

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032624-241046026.png" alt="image-20230925142705351" style="zoom:50%;" />

如上图所示：不同的访问路径，对应不同的页面展示。在vue应用中使用路由功能，需要安装Vue-Router：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032402-951432476.png" alt="image-20230925142957238" style="zoom: 50%;" />

注：创建完带有路由功能的前端项目后，在工程中会生成一个路由文件，如下所示：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032720-485210996.png" alt="image-20230925144015768" style="zoom:50%;" />

关于路由的配置，主要就是在这个路由文件中完成的。

为了能够使用路由功能，在前端项目的入口文件main.js中，创建Vue实例时需要指定路由对象：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032045-1224970664.png" alt="image-20230925144400285" style="zoom:50%;" />

### 路由配置

首先了解一下路由组成：

- VueRouter：路由器，根据路由请求在路由视图中动态渲染对应的视图组件
- <router-link>：路由链接组件，浏览器会解析成<a>
- <router-view>：路由视图组件，用来展示与路由路径匹配的视图组件

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032402-357431789.png" alt="image-20230925143537869" style="zoom:50%;" />

具体配置方式：

1) 在路由文件中配置路由路径和视图的对应关系：

~~~javascript
import Vue from 'vue'
import VueRouter from 'vue-router'
import HomeView from '../views/HomeView.vue'

Vue.use(VueRouter)

//维护路由表，某个路由路径对应哪个视图组件
const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/about',
    name: 'about',
      //懒加载，使用的时候才加载
    component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue')
  }
  ,
  {
    path: '/404',
    component: () => import('../views/404View.vue')
  },
  {
    path: '*',
    redirect: '/404'
  }
]

const router = new VueRouter({
  routes
})

export default router
~~~

2) 在视图组件中配置 router-link标签，用于生成超链接

~~~html
<router-link to="/">Home</router-link> |
<router-link to="/about">About</router-link> |
<router-link to="/test">Test</router-link> |
~~~

3) 在视图组件汇总配置router-view标签

~~~html
<!--视图组件展示的位置-->
<router-view/>
~~~

要实现路由跳转，可以通过标签式和编程式两种：

- 标签式：<router-link to="/about">About</router-link>
- 编程式：this.$router.push('/about')

```vue
<template>
  <div id="app">
    <nav>
      <router-link to="/">Home</router-link> |
      <router-link to="/about">About</router-link>
      <input type="button" value="编程式跳转" @click="jump"/>
    </nav>
    <router-view/>
  </div>
</template>

<script>
export default{
  methods:{
    jump(){
      this.$router.push('about')
    }
  }
}
</script>
```

**问题思考：**如果用户访问的路由地址不存在，该如何处理？

可以通过在路由表中配置一个404视图组件，当访问的路由地址不存在时，则重定向到此视图组件，具体配置如下：

~~~javascript
  {
    path: '/404',
    component: () => import('../views/404View.vue')
  },
  {
    path: '*',
    redirect: '/404' //重定向
  }
~~~

### 嵌套路由

嵌套路由：`组件内要切换内容`，就需要用到嵌套路由（子路由），效果如下：

在App.vue视图组件中有<router-view>标签，其他视图组件可以展示在此

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031792-1139806453.png" alt="image-20230925153930006" style="zoom: 33%;" />

ContainerView.vue组件可以展示在App.vue视图组件的<router-view>位置

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032045-5752105.png" alt="image-20230925153854881" style="zoom: 33%;" />

ContainerView.vue组件进行了区域划分（分为上、左、右），在右边编写了<router-view>标签，点击左侧菜单时，可以将对应的子视图组件展示在此

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032369-861847226.png" alt="image-20230925154346635" style="zoom: 33%;" />

实现步骤：

第一步：安装并导入 [elementui](https://element.eleme.io/)，实现页面布局（Container 布局容器）---ContainerView.vue

```javascript
<!--安装：npm i element-ui -S-->
<!--导入-->
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';

Vue.use(ElementUI);	<!--全局使用-->
```

~~~html
<template>
  <el-container>
    <el-header>Header</el-header>
    <el-container>
        <el-aside width="200px">
        </el-aside>
        <el-main>
        </el-main>
    </el-container>
  </el-container>
</template>

<script>
export default {

}
</script>

<style>
.el-header, .el-footer {
    background-color: #B3C0D1;
    color: #333;
    text-align: center;
    line-height: 60px;
  }
  
  .el-aside {
    background-color: #D3DCE6;
    color: #333;
    text-align: center;
    line-height: 200px;
  }
  
  .el-main {
    background-color: #E9EEF3;
    color: #333;
    text-align: center;
    line-height: 160px;
  }
  
  body > .el-container {
    margin-bottom: 40px;
  }
  
  .el-container:nth-child(5) .el-aside,
  .el-container:nth-child(6) .el-aside {
    line-height: 260px;
  }
  
  .el-container:nth-child(7) .el-aside {
    line-height: 320px;
  }
</style>
~~~

第二步：提供子视图组件，用于效果展示  ---P1View.vue、P2View.vue、P3View.vue

~~~html
<template>
  <div>
    这是P1 View
  </div>
</template>

<script>
export default {

}
</script>

<style>
.el-header, .el-footer {
    background-color: #B3C0D1;
    color: #333;
    text-align: center;
    line-height: 60px;
  }
  
  .el-aside {
    background-color: #D3DCE6;
    color: #333;
    text-align: center;
    line-height: 200px;
  }
  
  .el-main {
    background-color: #E9EEF3;
    color: #333;
    text-align: center;
    line-height: 160px;
  }
  
  body > .el-container {
    margin-bottom: 40px;
  }
  
  .el-container:nth-child(5) .el-aside,
  .el-container:nth-child(6) .el-aside {
    line-height: 260px;
  }
  
  .el-container:nth-child(7) .el-aside {
    line-height: 320px;
  }
</style>
~~~

第三步：在 src/router/index.js 中配置路由映射规则（嵌套路由配置）

- 通过children属性指定各个子路由信息(path、component)

~~~javascript
   {
    path: '/c',
    component: () => import('../views/container/ContainerView.vue'),
    //嵌套路由（子路由），对应的组件会展示在当前组件内部
    children: [//通过children属性指定子路由相关信息（path、component）
      {
        path: '/c/p1',
        component: () => import('../views/container/P1View.vue')
      },
      {
        path: '/c/p2',
        component: () => import('../views/container/P2View.vue')
      },
      {
        path: '/c/p3',
        component: () => import('../views/container/P3View.vue')
      }
    ]
  }
~~~

第四步：在ContainerView.vue 布局容器视图中添加<router-view>，实现子视图组件展示

~~~html
<el-main>
    <router-view/>
</el-main>
~~~

第五步：在ContainerView.vue 布局容器视图中添加<router-link>，实现路由请求

~~~html
<el-aside width="200px">
    <router-link to="/c/p1">P1</router-link><br>
    <router-link to="/c/p2">P2</router-link><br>
    <router-link to="/c/p3">P3</router-link><br>
</el-aside>
~~~

注意：子路由变化，切换的是【ContainerView 组件】中 `<router-view></router-view>` 部分的内容

问题思考：

1.对于前面的案例，如果用户访问的路由是 /c，会有什么效果呢？

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032445-1455751652.png" alt="image-20230925160657497" style="zoom:50%;" />

2.如何实现在访问 /c 时，默认就展示某个子视图组件呢？

配置重定向，当访问/c时，直接重定向到/c/p1即可，如下配置：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032064-82882893.png" alt="image-20230925160730746" style="zoom:50%;" />

## 状态管理 vuex

### vuex 介绍

- vuex 是一个专为 Vue.js 应用程序开发的状态管理库
- vuex 可以在`多个组件之间共享数据`，并且共享的数据是响应式的，即数据的变更能及时渲染到模板
- vuex 采用集中式存储管理所有组件的状态

每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：

1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

> 安装vuex：npm install vuex@next --save

vuex中的几个核心概念：

- state：状态对象，集中定义各个组件共享的数据
- mutations：类似于一个事件，用于修改共享数据，要求必须是同步函数
- actions：类似于mutation，可以包含异步操作，通过调用mutation来改变共享数据

###  使用方式

本章节通过一个案例来学习vuex的使用方式，具体操作步骤如下：

第一步：创建带有vuex功能的前端项目

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032702-314200770.png" alt="image-20230926094537147" style="zoom:50%;" />

注：在创建的前端工程中，可以发现自动创建了vuex相关的文件(src/store/index.js)，并且在main.js中创建Vue实例时，需要将store对象传入，代码如下：

~~~javascript
import Vue from 'vue'
import App from './App.vue'
import store from './store'

Vue.config.productionTip = false

new Vue({
  store,//使用vuex功能
  render: h => h(App)
}).$mount('#app')
~~~

第二步：在src/store/index.js文件中集中定义和管理共享数据

~~~javascript
import Vue from 'vue'
import Vuex from 'vuex'
import axios from 'axios'

Vue.use(Vuex)

//集中管理多个组件共享的数据
export default new Vuex.Store({
  //集中定义共享数据
  state: {
    name: '未登录游客'
  },
  getters: {
  },
  //通过当前属性中定义的函数修改共享数据，必须都是同步操作
  mutations: {
  },
  //通过actions调用mutation，在actions中可以进行异步操作
  actions: {
  },
  modules: {
  }
})
~~~

第三步：在视图组件中展示共享数据

~~~html
<template>
  <div class="hello">
    <h1>欢迎你，{{$store.state.name}}</h1>
  </div>
</template>
~~~

注：$store.state为固定写法，用于访问共享数据

第四步：在mutations中定义函数，用于修改共享数据

~~~javascript
  //通过当前属性中定义的函数修改共享数据，必须都是同步操作
  mutations: {
    setName(state,newName) {
      state.name = newName
    }
  },
~~~

第五步：在视图组件中调用 mutations 中定义的函数

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032360-209073409.png" alt="image-20230926102311897" style="zoom:50%;" />

注：mutations中定义的函数不能直接调用，必须通过状态对象的 commit 方法来调用

第六步：如果在修改共享数据的过程中有异步操作，则需要将异步操作的代码编写在actions的函数中

~~~javascript
  //通过actions调用mutation，在actions中可以进行异步操作
  actions: {
    setNameByAxios(context){
      axios({ //异步请求
        url: '/api/admin/employee/login',
        method: 'post',
        data: {
          username: 'admin',
          password: '123456'
        }
      }).then(res => {
        if(res.data.code == 1){
          //异步请求后，需要修改共享数据
          //在actions中调用mutation中定义的setName函数
          context.commit('setName',res.data.data.name)
        }
      })
    }
  },
~~~

注：在actions中定义的函数可以声明context参数，通过此参数可以调用mutations中定义的函数

第七步：在视图组件中调用actions中定义的函数

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032600-1980282377.png" alt="image-20230926103114922" style="zoom:50%;" />

注：在actions中定义的函数不能直接调用，必须通过 **this.$store.dispatch('函数名称')** 这种方式调用

## TypeScript

### TypeScript 介绍

- TypeScript（简称：TS） 是微软推出的开源语言
- TypeScript 是 JavaScript 的超集（JS 有的 TS 都有）

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604193454544-514547611.png" alt="image-20240604193454130" style="zoom:50%;" />

- TypeScript = Type + JavaScript（在 JS 基础上增加了类型支持）

- TypeScript 文件扩展名为 ts

- TypeScript 可编译成标准的 JavaScript，并且在编译时进行类型检查

  ```tsx
  //TypeScript 有明确的数据类型
  let age1:number = 18
  //JavaScript 
  let age2 = 18
  ```

![image-20230926112649750](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031857-2097750445.png)

- TypeScript 代码不能直接运行，需要用tsc编译为传统的js代码

- 在前端项目中使用TS，需要进行安装，命令为：npm install -g typescript

  查看TS版本：

  <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604194038180-229312808.png" alt="image-20240604194038508" style="zoom:67%;" />

TS初体验：

1) 创建 hello.ts 文件，内容如下：

~~~typescript
//定义一个函数 hello，并且指定参数类型为string
function hello(msg:string) {
      console.log(msg)
}

//调用上面的函数，传递非string类型的参数
hello(123)
~~~

2. 使用 tsc 命令编译 hello.ts 文件

   可以看到编译报错，提示参数类型不匹配。这说明在编译时TS会进行类型检查。需要注意的是在编译为JS文件后，类型会被擦除。

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604194257734-602948862.png" alt="image-20240604194257798" style="zoom:40%;" />

   修改为正确的格式

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604194526252-341100302.png" alt="image-20240604194526344" style="zoom:43%;" />

   生成的hello.js

   ```js
   //定义一个函数 hello，并且指定参数类型为string
   function hello(msg) {
       console.log(msg);
   }
   //调用上面的函数，传递非string类型的参数
   hello("string");
   ```

思考：TS 为什么要增加类型支持 ？

- TS 属于静态类型编程语言，JS 属于动态类型编程语言
- 静态类型在编译期做类型检查，动态类型在执行期做类型检查
- 对于 JS 来说，需要等到代码执行的时候才能发现错误（晚）
- 对于 TS 来说，在代码编译的时候就可以发现错误（早）
- 配合 VSCode 开发工具，TS 可以提前到在编写代码的同时就发现代码中的错误，减少找 Bug、改 Bug 的时间

在前端项目中使用TS，需要创建基于TS的前端工程：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032065-789567633.png" alt="image-20230926145235469" style="zoom:43%;" />

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032317-1722237954.png" alt="image-20230926145349976" style="zoom:43%;" />

### TypeScript 常用类型

TS中的常用类型如下：

| **类型**   | **例**                                 | **备注**                         |
| ---------- | -------------------------------------- | -------------------------------- |
| 字符串类型 | string                                 |                                  |
| 数字类型   | number                                 |                                  |
| 布尔类型   | boolean                                |                                  |
| 数组类型   | number[],string[],  boolean[] 依此类推 |                                  |
| 任意类型   | any                                    | 相当于又回到了没有类型的时代     |
| 复杂类型   | type 与 interface                      |                                  |
| 函数类型   | () =>  void                            | 对函数的参数和返回值进行说明     |
| 字面量类型 | "a"\|"b"\|"c"                          | 限制变量或参数的取值，类似于枚举 |
| class 类   | class Animal                           |                                  |

#### 类型标注的位置

基于TS进行前端开发时，类型标注的位置有如下3个：

- 标注变量
- 标注参数
- 标注返回值

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164031810-441633292.png" alt="image-20230926145517782" style="zoom: 67%;" />

#### string、number、boolean类型

字符串、数字、布尔类型是前端开发中常用的类型

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032680-1081445357.png" alt="image-20230926145634149" style="zoom: 67%;" />

#### 字面量类型

字面量类型用于限定数据的取值范围，类似于java中的枚举

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032306-18887112.png" alt="image-20230926145813932" style="zoom: 67%;" />

#### interface 类型

interface 类型是TS中的复杂类型，它让 TypeScript 具备了 JavaScript 所缺少的、描述较为复杂数据结构的能力。

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032485-341155666.png" alt="image-20230926150816090" style="zoom: 67%;" />

可以通过在`属性名后面加上？`，表示`当前属性为可选`，如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032535-589572940.png" alt="image-20230926150946103" style="zoom:67%;" />

#### class 类型

使用 class 关键字来定义类，类中可以包含属性、构造方法、普通方法等

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032571-1096899447.png" alt="image-20230926151839881" style="zoom:67%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605100626593-1360116084.png" alt="image-20240605100626236" style="zoom:40%;" />

在定义类时，可以使用 implments 关键字实现接口，如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032833-384541004.png" alt="image-20230926152034526" style="zoom:67%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101319489-2117827501.png" alt="image-20240605101319495" style="zoom:40%;" />

在定义类时，可以使用 extends 关键字 继承其他类，如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240604164032805-1317041469.png" alt="image-20230926152222634" style="zoom:67%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101714843-225283589.png" alt="image-20240605101714586" style="zoom:40%;" />

# 员工管理

## 前端环境搭建

### 技术选型

本项目使用到的前端技术如下：

- node.js
- vue
- ElementUI
- axios
- vuex
- vue-router
- typescript

### 熟悉前端代码结构

直接导入课程资料中提供的苍穹外卖项目前端初始工程，此工程中已经开发了部分功能，后续我们在此基础上开发新功能即可。

导入后的效果如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101918695-604108982.png" alt="image-20231009112322302" style="zoom:33%;" />

主要代码在src目录中，src目录结构如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919056-637324667.png" alt="image-20231009112436925" style="zoom:33%;" />

下面重点介绍一下src中的重点文件和目录：

- src
  - api：存放封装了Ajax请求文件的目录
  - components：公共组件存放目录
  - views：存放视图组件的目录

- App.vue：项目的主组件，页面的入口文件
- main.ts：整个项目的入口文件
- router.ts：路由文件

注意：我们上面导入的初始工程中并没有前端项目运行所依赖的JS包，需要在终端通过 npm install 命令进行安装。安装完成后，可以看到生成了node_modules目录，目录中就是安装的JS包，效果如下：

![image-20231009154944721](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101922381-1615094390.png)

接下来，我们通过初始工程中已经完成的登录功能来跟踪程序的执行过程，熟悉前端项目的代码结构。

首先需要启动前端项目，命令为：npm run serve，然后访问前端项目，效果如下：

![image-20231010103544159](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919076-1905784414.png)

注意：需要同时启动后端 java 服务，才能进行前后端交互。

具体操作的步骤如下：

① 获得登录页面路由地址

​	登录页面完整的访问地址为 http://localhost:8888/#/login，其中登录页面的路由地址为 /login，我们需要通过此路由地址找到对应的登录视图组件

② 从main.ts中找到路由文件

​	main.ts是整个前端项目的入口文件，在此文件中会创建Vue实例，在创建Vue实例时需要传入路由对象，所以从此文件中可以找到对应的路由文件位置。如下所示：@表示src

![image-20231011101828271](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101918748-361198692.png)

③ 从路由文件中找到登录视图组件

​	在路由文件中会配置整个项目所有的路由映射规则，我们只需要找到 /login 这个路径对应的实体组件即可。如下所示：

![image-20231011102024084](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101918978-256632224.png)

④ 从登录视图组件中找到登录方法

​	从上面的路由文件可以确定登录视图组件就是src/views/login/index.vue，此时就可以打开这个文件，然后仔细阅读代码，找到登录方法，如下所示：

![image-20231011102341145](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919094-1263891363.png)

⑤ 跟踪登录方法的执行过程

​	找到登录方法后，就需要跟踪代码的执行过程，主要就是观察前后端的交互过程。例如前端如何发送的Ajax请求，后端返回的数据格式等等

## 1.员工分页查询

### 需求分析

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919123-1086766843.png" alt="image-20231012104130496" style="zoom:50%;" />

业务规则：

- 根据页码展示员工信息(员工姓名、账号、手机号、账号状态、最后操作时间等)
- 每页展示10条数据
- 分页查询时可以根据需要，输入员工姓名进行查询

要展示员工分页数据，就需要前后端进行数据交互，对应的接口如下：

**基本信息**

**Path：** /admin/employee/page-GET

**请求参数**

**Query**

| 参数名称 | 是否必须 | 示例 | 备注       |
| -------- | -------- | ---- | ---------- |
| name     | 否       | 张三 | 员工姓名   |
| page     | 是       | 1    | 页码       |
| pageSize | 是       | 10   | 每页记录数 |

**返回数据**

| 名称       | 类型      | 是否必须 | 默认值 | 备注 | 其他信息          |
| ---------- | --------- | -------- | ------ | ---- | ----------------- |
| code       | number    | 必须     |        |      |                   |
| msg        | null      | 非必须   |        |      |                   |
| data       | object    | 必须     |        |      |                   |
| ├─ total   | number    | 必须     |        |      |                   |
| ├─ records | object [] | 必须     |        |      | item 类型: object |

### 代码开发

要开发前端代码，首先需要找到对应的组件。从路由文件 router.ts 中找到员工管理页面（组件）。

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101920941-636839183.png" alt="image-20231012100658784" style="zoom:50%;" />

可以看到，员工管理页面（组件）的位置为：src/views/employee/index.vue。我们只需要在此文件中开发员工分页查询相关的前端代码即可，整个开发过程大概可以分为以下几个关键步骤：

1. 根据产品原型，制作页面头部效果（输入框、查询按钮等）
2. 为查询按钮绑定单击事件，发送Ajax请求，查询员工分页数据，实现前后端交互
3. 提供 vue 的初始化方法，在页面加载后就查询分页数据
4. 使用ElementUI提供的表格组件展示分页数据
5. 使用ElementUI提供的分页条组件实现翻页效果

注意：开发过程中，并不是所有的代码都实现了再测试，而是开发一部分，就需要测试一下，看效果，如果有问题再调整。没有问题，再继续开发、测试。所以，这是一个逐渐完善的过程。下面我们就按照上面的几个关键步骤来开发，每开发完一个关键步骤，就需要测试一下，来验证我们的代码是否正确。

#### 制作页面头部效果

根据产品原型，制作页面头部效果（输入框、查询按钮等）。产品原型中的头部效果如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919036-1215374593.png" alt="image-20231012114155894" style="zoom:67%;" />

注意：输入框和按钮都是使用 ElementUI 提供的组件，对于前端的组件只需要参考 ElementUI 提供的文档，进行修改即可。实现代码如下：

~~~vue
<div class="tableBar">
    <label style="margin-right: 5px">	<!--右侧留白-->
        员工姓名: 
    </label>
    <el-input placeholder="请输入员工姓名" style="width: 15%" />
    <el-button type="primary" style="margin-left: 20px">查询</el-button>	<!--左侧留白-->
    <el-button type="primary" style="float: right">+添加员工</el-button>	<!--向右对齐-->
</div>
~~~

开发完上面代码后，就可以测试一下

#### 实现前后端数据交互

前面我们已经完成了页面头部效果开发，接下来就需要开发前后端数据交互的动态效果。

1. 第一步：为查询按钮绑定单击事件

   ![image-20231016094210211](https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921612-364107494.png)

2. 第二步：在methods中定义 pageQuery 方法，先验证当前方法能否正常执行

   注意：按照开发规范，真正发送Ajax请求的代码需要封装到 api目录下的ts文件中（src/api/employee.ts）

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605151200157-1258685710.png" alt="image-20240605151200268" style="zoom:43%;" />

3. 第三步：在src/api/employee.ts 中定义 getEmployeeList 方法，实现发送Ajax请求获取分页数据

   注意：发送 Ajax 请求的URL地址需要和前面我们设计的分页查询接口对应

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605151316771-1357960695.png" alt="image-20240605151317073" style="zoom:43%;" />

4. 第四步：在员工管理组件中导入 employee.ts 中定义的方法，并在data() 方法中定义分页相关的模型数据

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921520-434278143.png" alt="image-20231016094930398" style="zoom:40%;" />

5. 第五步：在pageQuery 方法中调用 getEmployeeList 方法

   注意：需要将name属性和上面的员工姓名输入框进行双向绑定，如下：<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919555-213479059.png" alt="image-20231016095018274" style="zoom:50%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919859-938380207.png" alt="image-20231016095152184" style="zoom:50%;" />

#### 自动发送Ajax请求

前面的代码我们已经实现了前后端数据交互，但是有一个问题，就是只有在点击查询按钮时才会发生Ajax请求，实现分页数据查询。我们通常需要的是在当前页面（组件）加载后，就需要发送Ajax请求，查询第一页的数据。要实现这个效果，我们可以通过vue的生命周期方法，即created方法来做到，代码如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919015-1271302968.png" alt="image-20231016095540340" style="zoom:50%;" />

#### 使用表格展示分页数据

前面我们已经实现了前后端数据交互，现在就需要将后端返回的数据通过表格展示出来，我们可以使用ElementUI提供的表格组件，具体使用方法可以参照官方提供的示例 https://element.eleme.io/#/zh-CN/component/table

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919950-330705166.png" alt="image-20231016100031134" style="zoom: 67%;" />

#### 使用分页条实现翻页效果

使用 ElementUI 提供的分页条组件，并绑定事件处理函数，具体使用方法可以参照官方提供的示例 https://element.eleme.io/#/zh-CN/component/pagination

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919677-2114795544.png" alt="image-20231016100300675" style="zoom: 50%;" />

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921199-182399914.png" alt="image-20231016100327628" style="zoom:50%;" />

### 总结

1. 在路由管理router.ts中找到员工管理对应的映射组件

   ```tsx
   {
       path: 'employee',
       component: () => import('@/views/employee/index.vue'),
       meta: {
             title: '员工管理',
             icon: 'icon-employee'
      }
   }
   ```

2. 在组件@/views/employee/index.vue中编写员工管理页面

   ```vue
   <template>
     <div class="dashboard-container">
       <div class="container">
          <!--页面头部--> 
         <label style="margin-right: 5px">员工姓名：</label>
         <el-input v-model="name" placeholder="请输入员工姓名" style="width: 15%" />
         <el-button type="primary" style="margin-left: 25px" @click="pageQuery()">查询</el-button>
         <el-button type="primary" style="float: right"> +添加员工</el-button>
           <!--页面主体-表格--> 
         <el-table :data="records" stripe style="width: 100%">
           <el-table-column prop="name" label="员工姓名" width="180" />
           <el-table-column prop="username" label="账号" width="180" />
           <el-table-column prop="phone" label="手机号" />
           <el-table-column prop="status" label="账号状态">
             <template slot-scope="scope">
               {{ scope.row.status === 0 ? '禁用' : '启用' }}
             </template>
           </el-table-column>
           <el-table-column prop="updateTime" label="最后操作时间" />
           <el-table-column label="操作">
             <template slot-scope="scope">
               <el-button type="text">
                 修改
               </el-button>
               <el-button type="text">
                 {{ scope.row.status === 1 ? '禁用' : '启用' }}
               </el-button>
             </template>
           </el-table-column>
         </el-table>
   		<!--页面底部-分页条--> 
         <el-pagination
           class="pageList"
           :current-page="page"
           :page-sizes="[10, 20, 30, 40,50]"
           :page-size="pageSize"
           layout="total, sizes, prev, pager, next, jumper"
           :total="total"
           @size-change="handleSizeChange"
           @current-change="handleCurrentChange"
         />
       </div>
     </div>
   </template>
   <script lang="ts">
   import { getEmployeeList } from '@/api/employee'	//引入Ajax请求代码
   export default {
     data() {
       return {
         name: '', //员工姓名，对应上面的输入框
         page: 1, //页码
         pageSize: 10, //每页的记录数
         total: 0, //查询到的总记录数
         records: [], //当前页要展示的数据集合
       }
     },
     created() {
       this.pageQuery()
     },
     methods: {
       //查询按钮
       pageQuery() {
         //准备请求参数
         const params = {
           name: this.name,
           page: this.page,
           pageSize: this.pageSize,
         }
         //发送Ajax请求，访问后端服务，获取分页数据
         getEmployeeList(params)
           .then((res) => {
             if (res.data.code === 1) {
               this.total = res.data.data.total
               this.records = res.data.data.records
             }
           })
           .catch((err) => {
             this.$message.error('请求出错了：' + err.message)
           })
       },
       //pageSize发生变化时触发
       handleSizeChange(pageSize){
         this.pageSize=pageSize;
         this.pageQuery();
       },
       //page发生变化时触发
       handleCurrentChange(page){
         this.page=page;
         this.pageQuery();
       }
     },
   }
   </script>
   
   <style lang="scss" scoped>
   .disabled-text {
     color: #bac0cd !important;
   }
   </style>
   ```

3. 在@/api/employee.ts/编写Ajax代码getEmployeeList

   ```typescript
   // 分页查询
   export const getEmployeeList = (params: any) =>
     request({
       'url': `/employee/page`,
       'method': 'get',
       params: params
     })
   ```

## 2.启用禁用员工账号

### 需求分析和接口设计

根据产品原型来进行需求分析：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921356-365622324.png" alt="image-20231016103554407" style="zoom:53%;" />

可以对状态为“启用” 的员工账号进行“禁用”操作，可以对状态为“禁用”的员工账号进行“启用”操作，状态为“禁用”的员工账号不能登录系统

接口设计如下：

 **基本信息**

**Path：** /admin/employee/status/{status}

**Method：** POST

**请求参数**

**Headers**

| 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
| ------------ | ---------------- | -------- | ---- | ---- |
| Content-Type | application/json | 是       |      |      |

**路径参数**

| 参数名称 | 示例 | 备注                  |
| -------- | ---- | --------------------- |
| status   | 1    | 状态，1为启用 0为禁用 |

**Query**

| 参数名称 | 是否必须 | 示例 | 备注   |
| -------- | -------- | ---- | ------ |
| id       | 是       |      | 员工id |

**返回数据**

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息      |
| ---- | ------- | -------- | ------ | ---- | ------------- |
| code | integer | 必须     |        |      | format: int32 |
| data | string  | 非必须   |        |      |               |
| msg  | string  | 非必须   |        |      |               |

### 代码开发

1. 第一步：为启用、禁用按钮绑定单击事件

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921502-565715035.png" alt="image-20231016154949134" style="zoom: 50%;" />

2. 第二步：编写对应的处理函数handleStartOrStop

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101920003-30568551.png" alt="image-20231016155041179" style="zoom:50%;" />

   到此可以先测试一下，检查当前方法能否成功执行，页面效果如下：

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919539-381342686.png" alt="image-20231016155124396" style="zoom:50%;" />

3. 第三步：在 employee.ts 中封装启用禁用员工账号方法，发送Ajax请求

   注意：发送请求的方式和相关参数，必须和前面的接口设计保持一致

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919803-1188053151.png" alt="image-20231016155246041" style="zoom:50%;" />

4. 第四步：在员工管理组件中引入上面定义的enableOrDisableEmployee方法，并完善 handleStartOrStop 方法

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101920915-266231746.png" alt="image-20231016155426898" style="zoom:50%;" />

5. 第五步：代码优化，如果是管理员账号则不允许更改账号状态

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919818-469305295.png" alt="image-20231016155558430" style="zoom:50%;" />

###  总结

1. 给按钮绑定事件

   ```vue
   <el-button type="text" @click="handleStartOrStop(scope.row)">
       {{ scope.row.status === 1 ? '禁用' : '启用' }}
   </el-button>
   ```

2. 编写事件方法

   ```js
   //启用，禁用员工账号
       handleStartOrStop(row){
         // alert(`id=${row.id} status=${row.status}`)
         //6.优化，不能修改管理员账号
         if(row.username==='admin'){
           this.$message.error('admin为系统管理员账号，不能更改账户状态')
           return
         }
         //3.弹出确认提示框
         this.$confirm('确认要修改当前员工账号的状态吗?', '提示', {
             confirmButtonText: '确定',
             cancelButtonText: '取消',
             type: 'warning'
           }).then(() => { //4.确定后的操作
               //1.构造参数
               const p={
                 id: row.id,
                 status: !row.status?1:0
               }
               //2.调用Ajax请求
               enableOrDisableEmployee(p).then(res => {
                 if(res.data.code===1){
                   this.$message.success('员工的账号状态修改成功！')
                   this.pageQuery()
                 }
               })
             })
           .catch(() => { //5.取消后的操作
             this.$message({
               type: 'info',
               message: '已取消此次修改'
             })
           })
       }
   ```

3. 编写异步请求

   ```tsx
   // 启用、禁用员工账号
   export const enableOrDisableEmployee = (params: any) =>
     request({
       'url': `/employee/status/${params.status}`,	//动态参数作为路径
       'method': 'POST',
       params: {id:params.id}	//请求的参数Query中含有id
     })
   ```

## 3.新增员工

###  需求分析和接口设计

根据产品原型来进行需求分析，产品原型如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919514-10312990.png" alt="image-20231017105355195" style="zoom:50%;" />

新增员工时需要录入 账号、员工姓名、手机号、性别、身份证号等信息。其中账号因为是登录凭证，所以必须是唯一的。手机号要求必须是合法的11位手机号码，身份证号为合法的18位身份证号码。

当新员工入职后，可以通过当前的新增员工功能来为新员工开通账号，新员工通过开通的账号来登录商家管理端系统。

接口设计如下：

 **基本信息**

**Path：** /admin/employee

**Method：** POST

**请求参数**

**Headers**

| 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
| ------------ | ---------------- | -------- | ---- | ---- |
| Content-Type | application/json | 是       |      |      |

**Body**

| 名称     | 类型    | 是否必须 | 默认值 | 备注   | 其他信息      |
| -------- | ------- | -------- | ------ | ------ | ------------- |
| id       | integer | 非必须   |        | 员工id | format: int64 |
| idNumber | string  | 必须     |        | 身份证 |               |
| name     | string  | 必须     |        | 姓名   |               |
| phone    | string  | 必须     |        | 手机号 |               |
| sex      | string  | 必须     |        | 性别   |               |
| username | string  | 必须     |        | 用户名 |               |

**返回数据**

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息      |
| ---- | ------- | -------- | ------ | ---- | ------------- |
| code | integer | 必须     |        |      | format: int32 |
| data | object  | 非必须   |        |      |               |
| msg  | string  | 非必须   |        |      |               |

### 代码开发

要开发新增员工前端代码，首先需要了解添加员工业务功能的操作步骤：

1. 在员工管理列表页面，点击 “添加员工”按钮，跳转到新增页面
2. 在新增员工页面录入员工相关信息
3. 点击“保存”按钮完成新增操作

接下来我们就可以按照上面的操作步骤来具体开发前端的代码。

1. 第一步：为“添加员工”按钮绑定单击事件

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921085-884596908.png" alt="image-20231017162453327" style="zoom:50%;" />

2. 第二步：编写 handleAddEmp 方法，进行路由跳转

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921021-2115782650.png" alt="image-20231017162515941" style="zoom:50%;" />

3. 第三步：根据产品原型，开发页面元素

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919478-400717243.png" alt="image-20231017162553386" style="zoom:50%;" /><img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921381-712523862.png" alt="image-20231017162651760" style="zoom:50%;" />

4. 第四步：定义模型数据和表单校验规则

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919121-944360472.png" alt="image-20231017162927506" style="zoom:50%;" />

   注意：在路由文件中已经配置了如下路由规则

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921246-929486237.png" alt="image-20231017162808963" style="zoom:50%;" />

5. 第五步：在 employee.ts 中封装新增员工方法，发送Ajax请求，实现前后端交互

   注意：

   - 发送请求的方式和相关参数，必须和前面的接口设计保持一致
   - 使用此方法时，别忘了在组件中通过import导入

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921351-1805466082.png" alt="image-20231017163005227" style="zoom:50%;" />

6. 第六步：在 methods 中定义提交表单的方法 submitForm

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101920734-2147185057.png" alt="image-20231017163116948" style="zoom:50%;" />

###  总结

1. 给添加员工绑定事件

   ```vue
   <el-button type="primary" style="float: right" @click="handleAddEmp">
       +添加员工
   </el-button>
   ```

2. 编写事件方法

   ```js
   //跳转到新增员工组件
   handleAddEmp(){
       // alert(111)
       //路由跳转
       this.$router.push('/employee/add')
   }
   ```

3. 添加路由信息

   ```typescript
   {
       path: '/employee/add',
       component: () => import('@/views/employee/addEmployee.vue'),
      //设置页面标题为 "添加/修改员工"，同时该路由在菜单中是隐藏的
       meta: {
             title: '添加/修改员工',
             hidden: true
      }
   }
   ```

4. 编写addEmployee.vue页面

   表单页面

   ```vue
   <template>
     <div class="addBrand-container">
       <div class="container">
         <!-- form表单 -->
         <el-form ref="ruleForm" :model="ruleForm" :rules="rules" label-width="180px">
           <el-form-item label="账号" prop="username">
             <el-input v-model="ruleForm.username" />
           </el-form-item>
           <el-form-item label="员工姓名" prop="name">
             <el-input v-model="ruleForm.name" />
           </el-form-item>
           <el-form-item label="手机号" prop="phone">
             <el-input v-model="ruleForm.phone" />
           </el-form-item>
           <el-form-item label="性别" prop="sex">
             <el-radio v-model="ruleForm.sex" label="1">
               男
             </el-radio>
             <el-radio v-model="ruleForm.sex" label="2">
               女
             </el-radio>
           </el-form-item>
           <el-form-item label="身份证号" prop="idNumber">
             <el-input v-model="ruleForm.idNumber" />
           </el-form-item>
           <div class="subBox">
             <!-- 修改，保存后跳转到列表页面 -->
             <el-button type="primary" @click="submitForm('ruleForm', false)">
               保存
             </el-button>
             <!-- 添加，保存后留在本页面 -->
             <el-button v-if="this.optType === 'add'" type="primary" @click="submitForm('ruleForm', true)">
               保存并继续添加员工
             </el-button>
             <el-button @click="() => this.$router.push('/employee')">
               返回
             </el-button>
           </div>
         </el-form>
       </div>
     </div>
   </template>
   ```

   逻辑处理

   ```vue
   <script lang="ts">
   import { addEmployee } from '@/api/employee'
   export default {
      //1.数据方法
     data() {
       //返回一个对象
       return {
         //2.操作类型
         optType: 'add',
         //3.这个数据对象中有一个名为 ruleForm 的属性，封装了prop的值
         ruleForm: {
           username: '',
           name: '',
           phone: '',
           sex: '1',
           idNumber: '',
         },
         //4.校验规则
         rules: {
           name: [
             { required: true, message: '请输入员工姓名', trigger: 'blur' }, //要求内容非空，校验不通过的信息，失去焦点时触发
             // { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' }
           ],
           username: [
             { required: true, message: '请输入员工账号', trigger: 'blur' },
           ],
           phone: [
             {
               required: true,
               trigger: 'blur',
               //自定义的验证函数  rule：当前的验证规则对象 value：当前字段的值 callback：用于传递验证结果的回调函数
               validator: (rule, value, callback) => {
                 if (value === '' || !/^1(3|4|5|6|7|8)\d{9}$/.test(value)) {
                   //1开头 第二位为3/4/5/6/7/8 后跟9位纯数字 $结束 /正则/
                   callback(new Error('请输入正确的手机号！'))
                 } else {
                   callback()
                 }
               },
             },
           ],
           idNumber: [
             {
               required: true,
               trigger: 'blur',
               //自定义的验证函数
               validator: (rule, value, callback) => {
                 if (
                   value === '' ||
                   !/^(\d{15}$)|(^\d{18}$)|(^\d{17}(x|X)$)/.test(value)
                 ) {
                   callback(new Error('请输入正确的身份证号！'))
                 } else {
                   callback()
                 }
               },
             },
           ],
         },
       }
     },
     methods: {
        //5.点击"保存"时触发的操作
       submitForm(formName, isContinue) {
         //6.进行表单校验
         this.$refs[formName].validate((valid) => {
           if (valid) {//表单校验通过
             // alert('所有表单项都符合要求!')
             //调用Ajax请求
             addEmployee(this.ruleForm).then((res) => {
               if (res.data.code === 1) {
                 this.$message.success('员工添加成功')
                 if (isContinue) {
                   this.ruleForm = {
                     username: '',
                     name: '',
                     phone: '',
                     sex: '1',
                     idNumber: '',
                   }
                 } else {
                   this.$router.push('/employee')
                 }
               }else {
                 this.$message.error('res.data.msg')
               }
             })
           }
         })
       },
     },
   }
   </script>
   ```

5. Ajax请求

   ```typescript
   // 新增员工
   export const addEmployee = (params: any) =>
     request({
       'url': `/employee`,
       'method': 'POST',
       'data': params	//请求的参数是在请求体body中
     })
   ```

## 4.修改员工

### 需求分析和接口设计

根据产品原型来进行需求分析，产品原型如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101919514-10312990.png" alt="image-20231017105355195" style="zoom:50%;" />

修改员工时需要回显 账号、员工姓名、手机号、性别、身份证号等信息。其中账号因为是登录凭证，所以必须是唯一的。手机号要求必须是合法的11位手机号码，身份证号为合法的18位身份证号码。根据需要对数据进行修改即可。

修改员工功能涉及到2个接口，分别是根据id查询员工信息和根据id修改员工信息。具体接口设计如下：

（1）根据id查询员工 接口

**基本信息**

**Path：** /admin/employee/{id}

**Method：** GET

**请求参数**

**路径参数**

| 参数名称 | 示例 | 备注   |
| -------- | ---- | ------ |
| id       | 100  | 员工id |

**返回数据**

| 名称          | 类型    | 是否必须 | 默认值 | 备注 | 其他信息          |
| ------------- | ------- | -------- | ------ | ---- | ----------------- |
| code          | integer | 必须     |        |      | format: int32     |
| data          | object  | 必须     |        |      |                   |
| ├─ createTime | string  | 非必须   |        |      | format: date-time |
| ├─ createUser | integer | 非必须   |        |      | format: int64     |
| ├─ id         | integer | 非必须   |        |      | format: int64     |
| ├─ idNumber   | string  | 非必须   |        |      |                   |
| ├─ name       | string  | 非必须   |        |      |                   |
| ├─ password   | string  | 非必须   |        |      |                   |
| ├─ phone      | string  | 非必须   |        |      |                   |
| ├─ sex        | string  | 非必须   |        |      |                   |
| ├─ status     | integer | 非必须   |        |      | format: int32     |
| ├─ updateTime | string  | 非必须   |        |      | format: date-time |
| ├─ updateUser | integer | 非必须   |        |      | format: int64     |
| ├─ username   | string  | 非必须   |        |      |                   |
| msg           | string  | 非必须   |        |      |                   |

（2）根据id修改员工信息 接口

**基本信息**

**Path：** /admin/employee

**Method：** PUT

**请求参数**

**Headers**

| 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
| ------------ | ---------------- | -------- | ---- | ---- |
| Content-Type | application/json | 是       |      |      |

**Body**

| 名称     | 类型    | 是否必须 | 默认值 | 备注 | 其他信息      |
| -------- | ------- | -------- | ------ | ---- | ------------- |
| id       | integer | 必须     |        |      | format: int64 |
| idNumber | string  | 必须     |        |      |               |
| name     | string  | 必须     |        |      |               |
| phone    | string  | 必须     |        |      |               |
| sex      | string  | 必须     |        |      |               |
| username | string  | 必须     |        |      |               |

**返回数据**

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息      |
| ---- | ------- | -------- | ------ | ---- | ------------- |
| code | integer | 必须     |        |      | format: int32 |
| data | string  | 非必须   |        |      |               |
| msg  | string  | 非必须   |        |      |               |

### 代码开发

要开发修改员工前端代码，首先需要了解修改员工业务功能的操作步骤：

1. 在员工管理列表页面点击 “修改”按钮，跳转到修改页面
2. 在修改员工页面录入员工相关信息
3. 点击“保存”按钮完成修改操作

注意：

- 由于添加员工和修改员工的表单项非常类似，所以添加和修改操作可以共用同一个页面（addEmployee.vue）
- 修改员工涉及到原始数据回显，所以页面跳转时需要传递员工id作为参数

接下来我们就可以按照上面的操作步骤来具体开发前端的代码。

1. 第一步：在员工管理页面中，为“修改”按钮绑定单击事件，用于跳转到修改页面

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921347-217851499.png" alt="image-20231018153123546" style="zoom:50%;" />

2. 第二步：在methods中编写 handleUpdateEmp 方法，实现路由跳转

   注意：使用路由对象的push方法在进行路由跳转时，可以通过地址栏传递参数，具体语法为：

   ~~~javascript
   this.$router.push({path: 路由路径, query:{参数名:参数值}})
   ~~~

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101920707-2130425473.png" alt="image-20231018153201351" style="zoom:50%;" />

3. 第三步：在 addEmployee.vue 组件中定义模型数据optType，用于区分本次操作是新增还是修改

   注意：区分当前操作是新增员工还是修改员工，只需要尝试获取路由参数id。

   如果能获取到则当前操作为修改，否则为新增。具体获取路由参数的语法为：

   ~~~javascript
   //this.$router路由器对象	this.$route路由对象
   this.$route.query.参数名
   ~~~

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101920693-586741550.png" alt="image-20231018153639687" style="zoom:40%;" />

4. 第四步：如果是修改操作，需要根据id查询员工原始信息用于页面回显，需要在 employee.ts 中创建queryEmployeeById方法

   注意：

   - 发送请求的方式和相关参数，必须和前面的接口设计保持一致
   - 使用此方法时，别忘了在组件中通过import导入

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101920565-322045911.png" alt="image-20231018154041788" style="zoom:50%;" />

5. 第五步：在 addEmployee.vue 组件的 created 方法中查询员工原始信息用于页面数据回显

   到目前位置已经实现了员工信息的回显，可以进行简单的测试，如果回显没有问题再继续开发后面的代码

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921418-703511437.png" alt="image-20231018154225861" style="zoom:50%;" />

6. 第六步：如果是修改操作，“保存并继续添加员工” 按钮则不需要显示，通过 v-if 指令进行判断

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921289-2146504425.png" alt="image-20231018154415419" style="zoom:50%;" />

7. 第七步：在 employee.ts 中创建方法，用于修改员工，发送Ajax请求

   注意：

   - 发送请求的方式和相关参数，必须和前面的接口设计保持一致
   - 使用此方法时，别忘了在组件中通过import导入

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101921420-912490998.png" alt="image-20231018154443989" style="zoom:50%;" />

8. 第八步：修改 addEmployee.vue 组件中的 submitForm 方法，需要根据当前操作类型执行新增或者修改操作

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605101920745-1220582089.png" alt="image-20231018154601719" style="zoom:50%;" />

###  总结

页面回显

1. 给修改绑定事件

   ```vue
   <!--scope.row：当前员工的JSON对象-->
   <el-button type="text" @click="handleUpdateEmp(scope.row)">
       修改
   </el-button>
   ```

2. 编写事件方法

   ```js
   //跳转到修改员工组件
   handleUpdateEmp(row) {
       //优化：不允许修改admin
       if (row.username === 'admin') {
           this.$message.error('admin为系统的管理员账号，不允许修改！')
           return
       }
       //路由跳转到修改页面，通过地址栏传递参数
       this.$router.push({
           path: '/employee/add',
           query: { id: row.id },
       })
   },
   ```

3. 编写路由跳转

   ```typescript
   {
       path: '/employee/add',
       component: () => import('@/views/employee/addEmployee.vue'),
       meta: {
             title: '添加/修改员工',
             hidden: true
       }
   }
   ```

4. 编写addEmployee.vue视图

   ```js
   //1.设置操作类型为空
   data() {
       //返回一个对象
       return {
         //当前操作类型
         optType: ''
       }
   }，
   //2.利用钩子函数，初识时判断操作类型并赋值 当修改操作时，回显数据
   created() {
       //获取路由参数（id）,如果有就是修改，否则为新增
       this.optType = this.$route.query.id ? 'update' : 'add'
       if (this.optType === 'update') {
         //页面回显
         queryEmployeeById(this.$route.query.id).then((res) => {
           if (res.data.code === 1) {
             this.ruleForm = res.data.data
           }
         })
       }
     }
   ```

5. 编写根据id查询员工的Ajax请求

   ```typescript
   // 根据id查询员工
   export const queryEmployeeById = (id: number) =>
     request({
       'url': `/employee/${id}`,
       'method': 'GET',
     })
   ```

提交修改操作

1. 在方法submitForm中添加操作判断逻辑

   ```js
   methods: {
       submitForm(formName, isContinue) {
         //进行表单校验
         this.$refs[formName].validate((valid) => {
           if (valid) {
             //表单校验通过
   
             //1.判断当前操作是修改还是新增
             if (this.optType === 'add') {
               //2.新增操作
               //调用Ajax请求
               addEmployee(this.ruleForm).then((res) => {
                 if (res.data.code === 1) {
                   this.$message.success('员工添加成功')
                   if (isContinue) {
                     this.ruleForm = {
                       username: '',
                       name: '',
                       phone: '',
                       sex: '1',
                       idNumber: '',
                     }
                   } else {
                     this.$router.push('/employee')
                   }
                 } else {
                   this.$message.error('res.data.msg')
                 }
               })
             } else {
               //3.修改操作
               updateEmployee(this.ruleForm).then((res) => {
                 if (res.data.code === 1) {
                   this.$message.success('员工信息修改成功！')
                   this.$router.push('/employee')
                 }
               })
             }
           }
         })
       },
     }
   ```

2. 编写修改员工的Ajax请求

   ```typescript
   // 修改员工
   export const updateEmployee = (params: any) =>
     request({
       'url': `/employee`,
       'method': 'PUT',
       'data': params
     })
   ```

# 套餐管理

## 1. 套餐分页查询

###  需求分析

根据产品原型来了解需求，套餐分页查询的产品原型如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947930-468067675.png" alt="image-20231019100236805" style="zoom:50%;" />

业务规则：

- 根据页码展示套餐信息(套餐名称、套餐图片、套餐分类、价格、售卖状态、最后操作时间等)
- 每页展示10条数据
- 分页查询时可以根据需要，输入套餐名、套餐分类、售卖状态 进行查询

要展示套餐分页数据，就需要前后端进行数据交互，对应的接口有两个：

- 分类查询接口（用于套餐分类下拉框中分类数据展示）
- 套餐分页查询接口

（1）分类查询接口

 **基本信息**

**Path：** /admin/category/list

**Method：** GET

**请求参数**

**Query**

| 参数名称 | 是否必须 | 示例 | 备注                               |
| -------- | -------- | ---- | ---------------------------------- |
| type     | 否       | 2    | 分类类型：1为菜品分类，2为套餐分类 |

**返回数据**

| 名称          | 类型      | 是否必须 | 默认值 | 备注 | 其他信息          |
| ------------- | --------- | -------- | ------ | ---- | ----------------- |
| code          | integer   | 必须     |        |      | format: int32     |
| data          | object [] | 非必须   |        |      | item 类型: object |
| ├─ createTime | string    | 非必须   |        |      | format: date-time |
| ├─ createUser | integer   | 非必须   |        |      | format: int64     |
| ├─ id         | integer   | 非必须   |        |      | format: int64     |
| ├─ name       | string    | 非必须   |        |      |                   |
| ├─ sort       | integer   | 非必须   |        |      | format: int32     |
| ├─ status     | integer   | 非必须   |        |      | format: int32     |
| ├─ type       | integer   | 非必须   |        |      | format: int32     |
| ├─ updateTime | string    | 非必须   |        |      | format: date-time |
| ├─ updateUser | integer   | 非必须   |        |      | format: int64     |
| msg           | string    | 非必须   |        |      |                   |

（2）套餐分页查询接口

 **基本信息**

**Path：** /admin/setmeal/page

**Method：** GET

**请求参数**

**Query**

| 参数名称   | 是否必须 | 示例 | 备注         |
| ---------- | -------- | ---- | ------------ |
| categoryId | 否       |      | 分类id       |
| name       | 否       |      | 套餐名称     |
| page       | 是       |      | 页码         |
| pageSize   | 是       |      | 每页记录数   |
| status     | 否       |      | 套餐起售状态 |

**返回数据**

| 名称       | 类型      | 是否必须 | 默认值 | 备注 | 其他信息          |
| ---------- | --------- | -------- | ------ | ---- | ----------------- |
| code       | number    | 必须     |        |      |                   |
| msg        | null      | 非必须   |        |      |                   |
| data       | object    | 非必须   |        |      |                   |
| ├─ total   | number    | 非必须   |        |      |                   |
| ├─ records | object [] | 非必须   |        |      | item 类型: object |

### 代码开发

要开发前端代码，首先需要找到对应的组件。从路由文件 router.ts 中找到套餐管理页面（组件）。

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947755-1216552996.png" alt="image-20231020143129575" style="zoom:50%;" />

可以看到，套餐管理页面（组件）的位置为：src/views/setmeal/index.vue。我们只需要在此文件中开发套餐分页查询相关的前端代码即可，整个开发过程大概可以分为以下几个关键步骤：

1. 根据产品原型，制作页面头部效果（输入框、下拉框、查询按钮等）
2. 动态填充套餐分类下拉框中的分类数据
3. 为查询按钮绑定单击事件，发送Ajax请求，查询套餐分页数据，实现前后端交互
4. 提供 vue 的初始化方法，在页面加载后就查询分页数据
5. 使用ElementUI提供的表格组件展示分页数据
6. 使用ElementUI提供的分页条组件实现翻页效果

####  制作页面头部效果

根据产品原型，制作页面头部效果（输入框、查询按钮等）。产品原型中的头部效果如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947836-841781136.png" alt="image-20231020153003427" style="zoom:50%;" />

注意：输入框和按钮都是使用 ElementUI 提供的组件，对于前端的组件只需要参考 ElementUI 提供的文档，进行修改即可。实现代码如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947960-209082839.png" alt="image-20231020153413719" style="zoom:50%;" />

注意：当前套餐分类下拉框中的数据是直接在页面固定写死的，后续需要改为从后端动态获取。

####  动态填充套餐分类下拉框数据

现在需要将套餐分类下拉框中的数据改为动态获取，即前端需要发送Ajax请求，调用后端的分类查询接口，然后将后端返回的套餐分类数据动态展示在下拉框中。因为本次前后端交互是需要查询分类数据，所以按照项目规范，发送Ajax请求的代码需要定义到 src/api/category.ts 文件中。其实在此文件中已经定义了此方法，如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947967-482398072.png" alt="image-20231020153956869" style="zoom:50%;" />

所以，此处只需要将此方法(getCategoryByType)导入当前组件，然后在 created 方法中调用此方法，获取套餐分类数据，动态填充套餐分类下拉框即可。具体代码如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947874-1188139147.png" alt="image-20231020154449782" style="zoom:50%;" />

注意：因为此处我们要查询的是套餐分类，所以传递的参数type值为2。

前面我们已经初步实现了页面头部制作，并且可以填充下拉框中的数据了。但是命名上并不是特别规范，所以我们需要进行一个调整，具体修改后端的代码如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947864-540572667.png" alt="image-20231020154747092" style="zoom:50%;" />

两个下拉框的测试效果如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947936-1885495158.png" alt="image-20231020154909513" style="zoom:50%;" />

####  动态获取套餐分页数据

前面我们已经完成了页面头部效果开发，接下来就需要开发前后端数据交互的动态效果。

1. 第一步：为查询按钮绑定单击事件

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947747-783413930.png" alt="image-20231020155054149" style="zoom:50%;" />

2. 第二步：在methods中定义 pageQuery 方法，先验证当前方法能否正常执行

   注意：按照开发规范，真正发送Ajax请求的代码需要封装到 api目录下的ts文件中（src/api/setMeal.ts）

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947778-1674275908.png" alt="image-20231020155113565" style="zoom:50%;" />

3. 第三步：在src/api/setMeal.ts 中定义 getSetmealPage 方法，实现发送Ajax请求获取分页数据

   注意：发送 Ajax 请求的URL地址需要和前面我们设计的分页查询接口对应

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948885-1927796405.png" alt="image-20231020155235487" style="zoom:50%;" />

4. 第四步：在套餐管理组件中导入 setMeal.ts 中定义的方法，并在data() 方法中定义分页相关的模型数据

   注意：需要将属性和上面的输入框、下拉框进行双向绑定。

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947790-1949625900.png" alt="image-20231020155347403" style="zoom:50%;" />

5. 第五步：在pageQuery 方法中调用 getSetmealPage方法，实现前后端数据交互

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947965-1857862841.png" alt="image-20231020155526957" style="zoom:50%;" />

#### 自动发送Ajax请求

前面的代码我们已经实现了前后端数据交互，但是有一个问题，就是只有在点击查询按钮时才会发生Ajax请求，实现分页数据查询。我们通常需要的是在当前页面（组件）加载后，就需要发送Ajax请求，查询第一页的数据。要实现这个效果，我们可以通过vue的生命周期方法，即created方法来做到，代码如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947687-641080501.png" alt="image-20231020155637956" style="zoom:50%;" />

#### 使用表格展示分页数据

前面我们已经实现了前后端数据交互，现在就需要将后端返回的数据通过表格展示出来，我们可以使用ElementUI提供的表格组件，具体使用方法可以参照官方提供的示例 https://element.eleme.io/#/zh-CN/component/table

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947801-969555424.png" alt="image-20231020155734122" style="zoom:50%;" />

#### 使用分页条实现翻页效果

使用 ElementUI 提供的分页条组件，并绑定事件处理函数，具体使用方法可以参照官方提供的示例 https://element.eleme.io/#/zh-CN/component/pagination

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172949324-2073611017.png" alt="image-20231020155812305" style="zoom:50%;" />

###  总结

头部动态效果

1. 在路由信息中找到套餐管理的路由

   ```typescript
   {
       path: 'setmeal',
       component: () => import('@/views/setmeal/index.vue'),
       meta: {
              title: '套餐管理',
              icon: 'icon-combo'
       }
   }
   ```

2. 编写页面头部效果

   ```vue
   <div class="tableBar">
       <label style="margin-right: 5px">套餐名称：</label>
       <el-input v-model="name" placeholder="请输入套餐名称" style="width: 15%" />
       
       <label style="margin-right: 5px;margin-left: 10px;">套餐分类：</label>
       <!--此处categoryId为下拉框双向绑定的值-->
       <el-select v-model="categoryId" placeholder="请选择">
           <!--此处options为循环的集合  属性绑定的key值为获取到的id值，label为name值-->
           <el-option v-for="item in options" :key="item.id" :label="item.name" :value="item.id" />
       </el-select>
       
       <label style="margin-right: 5px;margin-left: 10px;">售卖状态：</label>
       <el-select v-model="status" placeholder="请选择">
           <el-option v-for="item in statusArr" :key="item.value" :label="item.label" :value="item.value" />
       </el-select>
       
       <el-button type="primary" style="margin-left: 15px" @click="pageQuery()">
           查询
       </el-button>
       <div style="float: right;">
           <el-button type="danger">
               批量删除
           </el-button>
           <el-button type="info">
               +新建套餐
           </el-button>
       </div>
   </div>
   ```

3. 编写对应的模型数据和动态填充套餐分类数据

   ```js
     //模型数据
     data() {
       return {
         name: '', //套餐名称，对应上面的输入框
         page: 1, //页码
         pageSize: 10, //每页的记录数
         total: 0, //查询到的总记录数
         records: [], //当前页要展示的数据集合
           
         //套餐分类下拉框
         options: [],
         categoryId: '',
   
         //状态下拉框
         statusArr: [
           {
             value: '0',
             label: '停售',
           },
           {
             value: '1',
             label: '启售',
           },
         ],
         status: '',
       }
     },
     created() {
       //查询套餐分类，填充下拉框
       getCategoryByType({ type: 2 }).then((res) => {
         if (res.data.code === 1) {
           this.options = res.data.data
         }
       })
     },
   ```

4. 编写查询套餐分类Ajax请求

   ```typescript
   // 根据类型查询分类：1为菜品分类 2为套餐分类
   export const getCategoryByType = (params: any) => {
     return request({
       url: `/category/list`,
       method: 'get',
       params: params
     })
   }
   ```

分页查询

1. 绑定查询事件

   ```vue
   <el-button type="primary" style="margin-left: 15px" @click="pageQuery()">
       查询
   </el-button>
   ```

2. 编写事件方法

   ```js
     created() {
       //查询套餐分类，填充下拉框
       getCategoryByType({ type: 2 }).then((res) => {
         if (res.data.code === 1) {
           this.options = res.data.data
         }
       })
   
       //页面加载完成后，查询套餐分页
       this.pageQuery()
     },
     methods: {
       pageQuery() {
         const params = {
           page: this.page,
           pageSize: this.pageSize,
           name: this.name,
           status: this.status,
           categoryId: this.categoryId,
         }
         getSetmealPage(params).then((res) => {
           if (res.data.code === 1) {
             this.total = res.data.data.total
             this.records = res.data.data.records
           }
         })
       }
     }
   ```

3. 分页查询的Ajax请求

   ```typescript
   //套餐分页查询
   export const getSetmealPage = (params: any) => {
       return request({
           url: '/setmeal/page',
           method: 'GET',
           params: params
       })
   }
   ```

4. 编写结果视图

   ```vue
   <el-table :data="records" stripe class="tableBox" @selection-change="handleSelectionChange">
           <el-table-column type="selection" width="25" />
           <el-table-column prop="name" label="套餐名称" />
           <el-table-column label="图片">
             <template slot-scope="scope">
               <el-image style="width: 80px; height: 40px; border: none" :src="scope.row.image" />
             </template>
           </el-table-column>
           <el-table-column prop="categoryName" label="套餐分类" />
           <el-table-column prop="price" label="套餐价" />
           <el-table-column label="售卖状态">
             <template slot-scope="scope">
               <div class="tableColumn-status" :class="{ 'stop-use': scope.row.status === 0 }">
                 {{ scope.row.status === 0 ? '停售' : '启售' }}
               </div>
             </template>
           </el-table-column>
           <el-table-column prop="updateTime" label="最后操作时间" />
           <el-table-column label="操作" align="center" width="250px">
             <template slot-scope="scope">
               <el-button type="text" size="small">
                 修改
               </el-button>
               <el-button type="text" size="small" @click="handleStartOrStop(scope.row)">
                 {{ scope.row.status == '1' ? '停售' : '启售' }}
               </el-button>
               <el-button type="text" size="small" @click="handleDelete('S',scope.row.id)">
                 删除
               </el-button>
             </template>
           </el-table-column>
         </el-table>
         <el-pagination class="pageList" :page-sizes="[10, 20, 30, 40]" :page-size="pageSize"
           layout="total, sizes, prev, pager, next, jumper" :total="total" @size-change="handleSizeChange"
           @current-change="handleCurrentChange" />
   ```

5. 编写方法

   ```js
   //pageSize发生变化时触发
   handleSizeChange(pageSize) {
       this.pageSize = pageSize
       this.pageQuery()
   },
   //page发生变化时触发
   handleCurrentChange(page) {
      this.page = page
      this.pageQuery()
   },
   ```

## 2. 启售停售套餐

### 需求分析和接口设计

根据产品原型来进行需求分析：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947848-1509930669.png" alt="image-20231023094228836" style="zoom:50%;" />

可以对状态为“启售” 的套餐进行“停售”操作

可以对状态为“停售”的套餐进行“启售”操作

状态为“停售”的套餐不展示在用户端小程序中，所以用户不能购买停售的套餐

接口设计如下：

**基本信息**

**Path：** /admin/setmeal/status/{status}

**Method：** POST

**请求参数**

**Headers**

| 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
| ------------ | ---------------- | -------- | ---- | ---- |
| Content-Type | application/json | 是       |      |      |

**路径参数**

| 参数名称 | 示例 | 备注                           |
| -------- | ---- | ------------------------------ |
| status   | 1    | 套餐状态，1表示起售，0表示停售 |

**Query**

| 参数名称 | 是否必须 | 示例 | 备注   |
| -------- | -------- | ---- | ------ |
| id       | 是       | 101  | 套餐id |

**返回数据**

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息      |
| ---- | ------- | -------- | ------ | ---- | ------------- |
| code | integer | 必须     |        |      | format: int32 |
| data | object  | 非必须   |        |      |               |
| msg  | string  | 非必须   |        |      |               |

### 代码开发

1. 第一步：为启售停售按钮绑定单击事件

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947989-1817602054.png" alt="image-20231023095123819" style="zoom:50%;" />

   ```vue
   <el-button type="text" size="small" @click="handleStartOrStop(scope.row)">
       {{ scope.row.status == '1' ? '停售' : '启售' }}
   </el-button>
   ```

2. 第二步：编写对应的处理函数handleStartOrStop

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947881-801102778.png" alt="image-20231023095249208" style="zoom:50%;" />

   到此可以先测试一下，检查当前方法能否成功执行，页面效果如下：

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172949043-2123728419.png" alt="image-20231023095322300" style="zoom:50%;" />

3. 第三步：在 setMeal.ts 中封装套餐起售停售方法，发送Ajax请求

   注意：发送请求的方式和相关参数，必须和前面的接口设计保持一致

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947793-1373836040.png" alt="image-20231023095630819" style="zoom:50%;" />

   ```typescript
   //套餐启售停售
   export const enableOrDisableSetmeal = (params: any) => {
       return request({
           url: `/setmeal/status/${params.status}`,
           method: 'POST',
           params: {id: params.id}	//从JSON中取， ?x=y
       })
   }
   ```

4. 第四步：在套餐管理组件中引入上面定义的enableOrDisableSetmeal方法，并完善 handleStartOrStop 方法

   注意：

   - 在进行套餐启售停售操作时，建议先弹出确认框，用户点击确定按钮后再进行前后端交互
   - 在传递套餐状态参数status时，需要进行简单的处理，即：如果当前套餐状态值为1，则传递过去的参数为0；如果当前套餐状态值为0，则传递过去的参数为1

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172949179-1037234733.png" alt="image-20231023095730185" style="zoom:50%;" />

   ```js
   handleStartOrStop(row) {
       this.$confirm('确认调整当前售卖状态?', '提示', {
           confirmButtonText: '确定',
           cancelButtonText: '取消',
           type: 'warning',
       }).then(() => {
           const p = {
               id: row.id,
               status: !row.status ? 1 : 0,
           }
           enableOrDisableSetmeal(p).then((res) => {
               if (res.data.code === 1) {
                   this.$message.success('套餐售卖状态更改成功！')
                   this.pageQuery()
               }
           })
       })
   }
   ```

## 3. 删除套餐

###  需求分析和接口设计

根据产品原型来进行需求分析，产品原型如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948221-1028794785.png" alt="image-20231023142125944" style="zoom:50%;" />

- 点击 删除 按钮，删除指定的一个套餐
- 勾选需要删除的套餐，点击 批量删除 按钮，删除选中的一个或多个套餐
- 状态为 “启售” 的套餐不能删除，需要给出操作提示

可以看到，删除套餐功能在操作时有两种方式。一种是点击【删除】按钮，可以删除对应的一个套餐；一种是勾选需要删除的套餐，然后点击【批量删除】按钮，可以删除勾选的多个套餐。我们在设计接口时可以兼容这两种不同的操作方式，也就是只需要一个接口即可。

接口设计如下：

**基本信息**

**Path：** /admin/setmeal

**Method：** DELETE

**请求参数**

**Query**

| 参数名称 | 是否必须 | 示例  | 备注 |
| -------- | -------- | ----- | ---- |
| ids      | 是       | 1,2,3 | ids  |

**返回数据**

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息      |
| ---- | ------- | -------- | ------ | ---- | ------------- |
| code | integer | 非必须   |        |      | format: int32 |
| data | object  | 非必须   |        |      |               |
| msg  | string  | 非必须   |        |      |               |

###  代码开发

要开发删除套餐前端代码，首先需要了解删除套餐业务功能的操作步骤：

1. 在套餐管理列表页面，点击 【删除】按钮，或者勾选套餐然后点击【批量删除】按钮，弹出确认对话框
2. 点击确认对话框中的【确定】按钮，则执行删除操作。如果套餐状态为“启售”，则不能删除，弹出信息提示
3. 点击确认对话框中的【取消】按钮，则关闭对话框，不执行删除操作

接下来我们就可以按照上面的操作步骤来具体开发前端的代码。

1. 第一步：在 setMeal.ts 中封装删除套餐方法，发送Ajax请求，用于实现前后端交互

   注意：

   - 发送请求的方式和相关参数，必须和前面的接口设计保持一致
   - 使用此方法时，别忘了在组件中通过import导入

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948982-925423229.png" alt="image-20231023163921668" style="zoom:50%;" />

   ```typescript
   //删除套餐
   export const deleteSetmeal = (ids: string) => { //1,2,3
       return request({
           url: '/setmeal',
           method: 'DELETE',
           params: {ids: ids}
       })
   }
   ```

2. 第二步：为【批量删除】和【删除】按钮绑定单击事件，并在methods中编写对应的处理函数

   到目前为止我们点击【批量删除】按钮，是可以执行handleDelete方法的。接下来我们需要解决一个问题，就是当前选中了哪些套餐呢？我们需要能够动态获取到，因为我们需要将这些套餐的id作为参数传递到后端。

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947941-607324077.png" alt="image-20231023164110268" style="zoom:50%;" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172947962-1057857157.png" alt="image-20231023164255891" style="zoom:50%;" />

   ```vue
   <el-button type="danger" @click="handleDelete('B')">
       批量删除
   </el-button>
   <el-button type="text" size="small" @click="handleDelete('S',scope.row.id)">
       删除
   </el-button>
   ```

3. 第三步：单个删除，为【删除】按钮绑定单击事件，处理函数还是 handleDelete

   注意：

   - 在 handleDelete 方法中通过第一个参数来区分是单个删除还是批量删除
   - S表示单个删除，B表示批量删除

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948856-139276067.png" alt="image-20231023170440585" style="zoom:50%;" />

   ```js
   handleDelete(type:string,id:string) {
       deleteSetmeal(id).then((res) => {
           if (res.data.code === 1) {
               this.$message.success('删除成功！')
               this.pageQuery()
           } else {
               this.$message.error(res.data.msg)
           }
       })
   }
   ```

4. 第四步：参考 ElementUI 的官方文档，为表格组件添加 **selection-change** 事件和对应的处理函数，通过此事件我们就可以动态获取到当前勾选的套餐有哪些

   注： **selection-change** 事件为 当选择项发生变化时触发的事件

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172949048-229077212.png" alt="image-20231023165937804" style="zoom:50%;" />

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948542-1774943845.png" alt="image-20231023170202159" style="zoom:50%;" />

5. 第五步：完善 handleDelete 方法，获取当前被选中的行，并进行参数准备

   注意：单个删除 和 批量删除，都是调用 handleDelete 方法，所以此方法还需要进一步调整

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172949006-1451576760.png" alt="image-20231023170312864" style="zoom:50%;" />

6. 第六步：调整 handleDelete 方法，使其兼容单个删除和批量删除

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948601-218477026.png" alt="image-20231023170612705" style="zoom:50%;" />

7. 第七步：完善 handleDelete 方法，进行相应提示

   注：

   - 批量删除时，如果没有选中套餐，给出提示
   - 删除之前需要弹出确认框，让用户确认

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948630-1899121407.png" alt="image-20231023170710212" style="zoom:50%;" />

```js
handleDelete(type: string, id: string) {
      this.$confirm('确认删除当前选中的套餐吗?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning',
      }).then(() => {
        let param = ''
        if (type == 'B') {
          //批量删除
          const arr = new Array()
          this.multipleSelection.forEach((element) => {
            arr.push(element.id)
          })
          param = arr.join(',')
        } else {
          //单个删除
          param = id
        }

        deleteSetmeal(param).then((res) => {
          if (res.data.code === 1) {
            this.$message.success('删除成功！')
            this.pageQuery()
          } else {
            this.$message.error(res.data.msg)
          }
        })
      })
    },
```

## 4. 新增套餐

### 需求分析和接口设计

根据产品原型来进行需求分析，产品原型如下：

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948659-417728796.png" alt="image-20231025113638867" style="zoom:50%;" />

<img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948521-37148955.png" alt="image-20231025113707572" style="zoom:50%;" />

新增套餐时需要录入套餐名称、所属分类、套餐价格、套餐包含的菜品、套餐图片、描述等信息。其中套餐包含的菜品需要在弹出的添加菜品窗口中勾选。在弹出的添加菜品窗口中需要按照分类来展示菜品。

新增套餐功能涉及到4个接口，分别是：

- 根据类型查询分类 接口
- 根据分类查询菜品 接口
- 文件上传 接口
- 新增套餐 接口

(1) 根据类型查询分类 接口

 **基本信息**

**Path：** /admin/category/list

**Method：** GET

**请求参数**

**Query**

| 参数名称 | 是否必须 | 示例 | 备注                               |
| -------- | -------- | ---- | ---------------------------------- |
| type     | 否       | 2    | 分类类型：1为菜品分类，2为套餐分类 |

**返回数据**

| 名称          | 类型      | 是否必须 | 默认值 | 备注 | 其他信息          |
| ------------- | --------- | -------- | ------ | ---- | ----------------- |
| code          | integer   | 必须     |        |      | format: int32     |
| data          | object [] | 非必须   |        |      | item 类型: object |
| ├─ createTime | string    | 非必须   |        |      | format: date-time |
| ├─ createUser | integer   | 非必须   |        |      | format: int64     |
| ├─ id         | integer   | 非必须   |        |      | format: int64     |
| ├─ name       | string    | 非必须   |        |      |                   |
| ├─ sort       | integer   | 非必须   |        |      | format: int32     |
| ├─ status     | integer   | 非必须   |        |      | format: int32     |
| ├─ type       | integer   | 非必须   |        |      | format: int32     |
| ├─ updateTime | string    | 非必须   |        |      | format: date-time |
| ├─ updateUser | integer   | 非必须   |        |      | format: int64     |
| msg           | string    | 非必须   |        |      |                   |

(2) 根据分类查询菜品 接口

 **基本信息**

**Path：** /admin/dish/list

**Method：** GET

**请求参数**

**Query**

| 参数名称   | 是否必须 | 示例 | 备注   |
| ---------- | -------- | ---- | ------ |
| categoryId | 是       | 101  | 分类id |

**返回数据**

| 名称           | 类型      | 是否必须 | 默认值 | 备注 | 其他信息          |
| -------------- | --------- | -------- | ------ | ---- | ----------------- |
| code           | integer   | 必须     |        |      | format: int32     |
| data           | object [] | 非必须   |        |      | item 类型: object |
| ├─ categoryId  | integer   | 非必须   |        |      | format: int64     |
| ├─ createTime  | string    | 非必须   |        |      | format: date-time |
| ├─ createUser  | integer   | 非必须   |        |      | format: int64     |
| ├─ description | string    | 非必须   |        |      |                   |
| ├─ id          | integer   | 非必须   |        |      | format: int64     |
| ├─ image       | string    | 非必须   |        |      |                   |
| ├─ name        | string    | 非必须   |        |      |                   |
| ├─ price       | number    | 非必须   |        |      |                   |
| ├─ status      | integer   | 非必须   |        |      | format: int32     |
| ├─ updateTime  | string    | 非必须   |        |      | format: date-time |
| ├─ updateUser  | integer   | 非必须   |        |      | format: int64     |
| msg            | string    | 非必须   |        |      |                   |

(3) 文件上传 接口

**基本信息**

**Path：** /admin/common/upload

**Method：** POST

**请求参数**

**Headers**

| 参数名称     | 参数值              | 是否必须 | 示例 | 备注 |
| ------------ | ------------------- | -------- | ---- | ---- |
| Content-Type | multipart/form-data | 是       |      |      |

**Body**

| 参数名称 | 参数类型 | 是否必须 | 示例 | 备注 |
| -------- | -------- | -------- | ---- | ---- |
| file     | file     | 是       |      | 文件 |

**返回数据**

| 名称 | 类型    | 是否必须 | 默认值 | 备注         | 其他信息      |
| ---- | ------- | -------- | ------ | ------------ | ------------- |
| code | integer | 必须     |        |              | format: int32 |
| data | string  | 必须     |        | 文件上传路径 |               |
| msg  | string  | 非必须   |        |              |               |

(4) 新增套餐 接口

**基本信息**

**Path：** /admin/setmeal

**Method：** POST

**接口描述：**

**请求参数**

**Headers**

| 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
| ------------ | ---------------- | -------- | ---- | ---- |
| Content-Type | application/json | 是       |      |      |

**Body**

| 名称          | 类型      | 是否必须 | 默认值 | 备注                      | 其他信息          |
| ------------- | --------- | -------- | ------ | ------------------------- | ----------------- |
| categoryId    | integer   | 必须     |        | 分类id                    | format: int64     |
| description   | string    | 非必须   |        | 套餐描述                  |                   |
| id            | integer   | 非必须   |        | 套餐id                    | format: int64     |
| image         | string    | 必须     |        | 套餐图片                  |                   |
| name          | string    | 必须     |        | 套餐名称                  |                   |
| price         | number    | 必须     |        | 套餐价格                  |                   |
| setmealDishes | object [] | 必须     |        | 套餐包含的菜品            | item 类型: object |
| ├─ copies     | integer   | 必须     |        | 份数                      | format: int32     |
| ├─ dishId     | integer   | 必须     |        | 菜品id                    | format: int64     |
| ├─ id         | integer   | 非必须   |        | 套餐和菜品关系id          | format: int64     |
| ├─ name       | string    | 必须     |        | 菜品名称                  |                   |
| ├─ price      | number    | 必须     |        | 菜品价格                  |                   |
| ├─ setmealId  | integer   | 必须     |        | 套餐id                    | format: int64     |
| status        | integer   | 必须     |        | 套餐状态：1位起售 0为停售 | format: int32     |

**返回数据**

| 名称 | 类型    | 是否必须 | 默认值 | 备注 | 其他信息      |
| ---- | ------- | -------- | ------ | ---- | ------------- |
| code | integer | 必须     |        |      | format: int32 |
| data | object  | 非必须   |        |      |               |
| msg  | string  | 非必须   |        |      |               |

###  代码解读

新增套餐操作步骤：

①点击 “新建套餐”按钮，跳转到新增页面

②在新增套餐页面录入套餐相关信息

③点击“保存”按钮完成新增操作

首先需要找到新增套餐页面，可以通过操作过程来找：

1. 第一步：在套餐管理列表页面中找到【新建套餐】按钮，查看按钮绑定的事件和对应的处理函数

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948367-1668418690.png" alt="image-20231026101005983" style="zoom:50%;" />

   ```vue
   <el-button type="info" @click="handleAdd">
       +新建套餐
   </el-button>
   ```

2. 第二步：在methods中找到handleAdd函数，查看跳转的路由路径

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948717-1577316700.png" alt="image-20231026101037315" style="zoom:50%;" />

   ```js
   handleAdd(){
       this.$router.push('/setmeal/add')
   }
   ```

3. 第三步：在路由文件中找到此路径对应的视图组件，可以看到是src/views/setmeal/addSetmeal.vue

   <img src="https://img2023.cnblogs.com/blog/3406637/202406/3406637-20240605172948543-355532279.png" alt="image-20231026101135442" style="zoom:50%;" />

   ```typescript
   {
       path: '/setmeal/add',
       component: () => import('@/views/setmeal/addSetmeal.vue'),
       meta: {
             title: '添加套餐',
             hidden: true
      }
   }
   ```

4. 第四步：解读src/views/setmeal/addSetmeal.vue这个文件即可
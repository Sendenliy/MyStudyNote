# 注解Annotation

## 概述

1. Annotation 是从JDK5.0开始引入的新技术

2. Annotation的作用

   - 不是程序本身 , 可以对程序作出解释，这一点和注释(comment)没什么区别
   - `可以被其他程序(比如:编译器等)读取`

3. Annotation的格式

   - 注解是以"@注释名"在代码中存在的
   - 还可以添加一些参数值 , 例如:@SuppressWarnings(value="unchecked") 

   ```java
   //1.@Override 重写的注解
   @Override
   //2.函数式接口
   //有且仅有一个抽象方法的接口
   @FunctionalInterface
   //3.已经被废弃
   @Deprecated
   ```

4. Annotation在哪里使用?

   - 可以附加在package , class , method , field 等上面 , 相当于给他们添加了额外的辅助信息
   - 我们可以通过反射机制实现对这些元数据的访问

## 内置注解

1. @Override

   定义在 java.lang.Override 中 , 此注释`只适用于修辞方法` , 表示一个方法声明打算`重写`超类中的另一个方法声明.

2. @Deprecated

   定义在java.lang.Deprecated中 , 此注释可以用于修辞`方法 , 属性 , 类 `,表示`不鼓励程序员使用`这样的元素 , 通常是因为它很危险或者存在更好的选择 

3. @SuppressWarnings

   定义在java.lang.SuppressWarnings中,用来`抑制编译时的警告信息`。

   与前两个注释有所不同,你`需要添加一个参数`才能正确使用,这些参数都是已经定义好了的,我们选择性的使用就好了 

   - @SuppressWarnings("all") 	镇压全部的警告
   - @SuppressWarnings("unchecked") 
   - @SuppressWarnings(value={"unchecked","deprecation"})等等 .....

```java
public class Test01 extends Object {
    //@Override 重写的注解
    @Override
    public String toString() {
        return super.toString();
    }

    //不推荐使用 但是可以使用
    @Deprecated
    public static void test() {
        System.out.println("Deprecated");
    }

    //镇压警告
    @SuppressWarnings("all")
    public void test02() {
        List list = new ArrayList();
    }

    public static void main(String[] args) {
        test();
    }
}
```

## 元注解

1. 元注解的作用就是负责`注解其他注解` , Java定义了4个标准的`meta-annotation类型`，他们被用来提供对其他annotation类型作说明
2. 这些类型和它们所支持的类在java.lang.annotation包中可以找到 .( @Target , @Retention , @Documented , @Inherited )
   - @Target : 用于描述注解的使用范围(即:被描述的注解可以用在什么地方)
   - @Retention : 表示需要在什么级别保存该注释信息 , 用于描述注解的生命周期(SOURCE < CLASS < `RUNTIME`)
   - @Document：说明该注解将被包含在javadoc中
   - @Inherited：说明子类可以继承父类中的该注解

```java
@MyAnnotation
public class Test02 {
    @MyAnnotation
    public void test() {}
}
//自定义一个注解

//1.@Target 表示我们的注解可以用在哪些地方
@Target(value = {ElementType.METHOD, ElementType.TYPE})
//2.@Retention  表示注解在什么地方有效
//RUNTIME > CLASS > SOURCE
@Retention(value = RetentionPolicy.RUNTIME)
//3.@Documented  表示注解是否在JAVAdoc中生成
@Documented
//4.@Inherited  表示子类可以继承父类的注解
@Inherited
@interface MyAnnotation {}
```

## 自定义注解

1. 使用 @interface自定义注解时 , 自动继承了java.lang.annotation.Annotation接口
2. 分析
   - `@ interface`用来声明一个注解 , 格式 : `public @ interface 注解名 { 定义内容 }`
   - 其中的每一个方法实际上是声明了一个配置参数
   - 方法的名称就是参数的名称
   - 返回值类型就是参数的类型 ( 返回值只能是基本类型,Class , String , enum )
   - 可以通过`default来声明参数的默认值`
   - `如果只有一个参数成员 , 一般参数名为value`
   - 注解元素必须要有值 , 我们定义注解元素时 , 经常使用空字符串,0作为默认值 .

```java
public class Test03 {
    //注解可以显示复制 如果没有默认值，就必须给注解赋值
    @MyAnnotation2(name = "注解2", schools = "aaa")
    public void test() {}
    
    //注解参数只有一个value,可以省略书写
    @MyAnnotation3("注解3")
    public void test2(){}
}

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation2 {
    //注解的参数：参数类型 + 参数名（）
    String name() default "";

    int age() default 0;

    int id() default -1;    //默认值为-1，代表不存在

    String[] schools() default {"bbb", "ccc"};
}
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation3{
    String value();
}
```

## 反射读取注解

1. 

# 反射Reflection

## 静态和动态语言

### 动态语言

1. 是一类在`运行时可以改变其结构的语言`：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。
2. 主要动态语言：Object-C、C#、JavaScript、PHP、Python等。

```javascript
//体现动态语言的代码
function test() {
    var x = "var a=3;var b=5;alert(a+b)";
    eval(x);
}
```

### 静态语言

1. 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。
2. Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活

## Java Reflection

### 概述

1. Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期`借助于Reflection API取得任何类的内部信息`(类名、接口、方法、字段、属性)，并能`直接操作任意对象的内部属性及方法`。

   ```java
   Class c=class.forName("java.lang.String")
   ```

2. 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以`通过这个对象看到类的结构`。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射

   <img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240331115843963-1691602719.png" alt="image-20240331115843481" width="400" />

### Java反射机制提供的功能

1. 在运行时判断任意一个对象所属的类
2. 在运行时构造任意一个类的对象
3. 在运行时判断任意一个类所具有的成员变量和方法
4. 在运行时获取泛型信息
5. 在运行时调用任意一个对象的成员变量和方法
6. 在运行时处理注解
7. 生成动态代理

### Java反射优点和缺点

1. 优点：可以实现动态创建对象和编译，体现出很大的灵活性 !
2. 缺点：对性能有影响。使用反射基本上是一种`解释操作`，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是`慢于`直接执行相同的操作

### 反射相关API

```java
java.lang.Class 	//: 代表一个类
java.lang.reflect.Method 	//: 代表类的方法
java.lang.reflect.Field 	//: 代表类的成员变量
java.lang.reflect.Constructor 	//: 代表类的构造器
```

### 获得反射对象

```java
public static void main(String[] args) throws ClassNotFoundException {
    //1.通过反射获取类的Class对象
    Class c1 = Class.forName("com.reflection.User");
    System.out.println(c1); //class com.reflection.User

    //2.通过Objecct类的getClass方法
    Class<? extends Test02> c5 = new Test02().getClass();
    System.out.println(c5); //class com.reflection.Test02

    Class<? extends User> c6 = new User().getClass();
    System.out.println(c6); //class com.reflection.User

    //3.一个类在内存中只有一个Class对象
    //4.一个类被加载后，类的整个结构都会被封装在Class对象中
    Class c2 = Class.forName("com.reflection.User");
    System.out.println(c2.hashCode());  //356573597
    Class c3 = Class.forName("com.reflection.User");
    System.out.println(c3.hashCode());  //356573597
    Class c4 = Class.forName("com.reflection.User");
    System.out.println(c4.hashCode());  //356573597
}
```

## Class类

### getClass方法

在Object类中定义了以下的方法，此方法将被所有子类继承

```java
public final Class getClass();
//以上的方法返回值的类型是一个Class类，此类是Java反射的源头
//实际上所谓反射从程序的运行结果来看也很好理解
//即：可以通过对象反射求出类的名称
```

<img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240331121809567-493575793.png" alt="image-20240331121808784" width="300" />

### Class对象

1. 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。
2. 对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。
   - Class 本身也是一个类
   - Class 对象只能由系统建立对象
   - 一个加载的类在 JVM 中只会有一个Class实例
   - 一个Class对象对应的是一个加载到JVM中的一个.class文件
   - 每个类的实例都会记得自己是由哪个 Class 实例所生成
   - 通过Class可以完整地得到一个类中的所有被加载的结构
   - Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象

### 常用方法

| 方法名                                  | 功能说明                                                     |
| :-------------------------------------- | :----------------------------------------------------------- |
| static ClassforName(String name)        | 返回指定类名name的Class对象                                  |
| Object newInstance()                    | 调用缺省构造函数，返回Class对象的一个实例                    |
| getName()                               | 返回此Class对象所表示的实体（类，接口，数组类或void）的名称。 |
| Class getSuperClass()                   | 返回当前Class对象的父类的Class对象                           |
| Class[] getinterfaces()                 | 获取当前Class对象的接口                                      |
| ClassLoader getClassLoader()            | 返回该类的类加载器                                           |
| Constructor[] getConstructors()         | 返回一个包含某些Constructor对象的数组                        |
| Method getMothed(String name,Class.. T) | 返回一个Method对象，此对象的形参类型为paramType              |
| Field[] getDeclaredFields()             | 返回Field对象的一个数组                                      |

### 获得Class类的实例

1. 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高
2. 已知某个类的实例，调用该实例的getClass()方法获取Class对象
3. 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException
4. 内置基本数据类型可以直接用类名.Type 
5. 还可以利用ClassLoader我们之后讲解

```java
public static void main(String[] args) throws ClassNotFoundException {
    Person student = new Student();
    System.out.println("这个人是：" + student.name); //这个人是：学生

    //1.通过对象获得
    Class c1 = student.getClass();
    System.out.println(c1.hashCode());  //356573597

    //2.forName获得
    Class c2 = Class.forName("com.reflection.Student");
    System.out.println(c2.hashCode());  //356573597

    //3.通过类名.class获得
    Class<Student> c3 = Student.class;
    System.out.println(c3.hashCode());  //356573597

    //4.基本内置类型的包装类都有一个Type属性
    Class<Integer> c4 = Integer.TYPE;
    System.out.println(c4); //int
    System.out.println(c4.hashCode());  //1735600054

    //1.获得父类类型
    Class c5 = c1.getSuperclass();
    System.out.println(c5); //class com.reflection.Person
}
```

### 哪些类型有Class对象

1. class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。
2. interface：接口
3. []：数组
4. num：枚举
5. annotation：注解@interface 
6. primitive type：基本数据类型
7. void

```java
public static void main(String[] args) {
    /* Alt长按 复制多行  */

    //1.类
    Class c1 = Object.class;
    System.out.println(c1); //class java.lang.Object

    //2.接口
    Class c2 = Comparable.class;
    System.out.println(c2); //interface java.lang.Comparable
    //3.一维数组[]
    Class c3 = String[].class;
    System.out.println(c3); //class [Ljava.lang.String;
    //4.二维数组[][]
    Class c4 = int[][].class;
    System.out.println(c4); //class [[I
    //5.注解
    Class c5 = Override.class;
    System.out.println(c5); //interface java.lang.Override
    //6.枚举
    Class c6 = ElementType.class;
    System.out.println(c6); //class java.lang.annotation.ElementType
    //7.基本数据类型
    Class c7 = Integer.class;
    System.out.println(c7); //class java.lang.Integer
    //8.void
    Class c8 = void.class;
    System.out.println(c8); //void
    //9.Class本身
    Class c9 = Class.class;
    System.out.println(c9); //class java.lang.Class

    //只要元素与维度类型一样 就是同一个Class
    int[] a = new int[10];
    int[] b = new int[100];
    System.out.println(a.getClass().hashCode());    //356573597
    System.out.println(b.getClass().hashCode());    //356573597
}
```

## Java内存分析

<img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240331143459230-774977987.png" alt="image-20240331143458574" width="500" />

方法区是特殊的堆

### 类的加载

<img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240331143734072-1674263663.png" alt="image-20240331143733829" width="400" />

类的加载与ClassLoader的理解

1. 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后`生成一个代表这个类的java.lang.Class对象`.

2. 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。

   1. 验证：确保加载的类信息符合JVM规范，没有安全方面的问题
   2. 准备：正式`为类变量（static）分配内存并设置类变量默认初始值`的阶段，这些内存都将在方法区中进行分配。
   3. 解析：虚拟机`常量池`内的符号引用（常量名）替换为直接引用（地址）的过程。

3. 初始化：

   1. `执行类构造器()方法`的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。
   2. 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
   3. 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。

   <img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240331150535030-1938644261.png" alt="image-20240331150534223" width="500" />

```java
1.加载到内存，会产生一个类对应Classduix
2.链接，链接结束后 m=0
3.初始化
    <clinit>(){
    	System.out.println("A类静态代码块初始化");
        m = 300;
    	m = 100;
	}
public class Test05 {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(A.m);
        /*
        A类静态代码块初始化
        A类的无参构造初始化
        100
         */
    }
}

class A {
    static {
        System.out.println("A类静态代码块初始化");
        m = 300;
    }
    /*
    m=300;
    m=100;
    */
    static int m = 100;
    public A() {
        System.out.println("A类的无参构造初始化");
    }
}
```

### 类初始化的发生

1. 类的主动引用（一定会发生类的初始化）
   - 当虚拟机启动，先初始化main方法所在的类
   - new一个类的对象
   - 调用类的静态成员（除了final常量）和静态方法
   - 使用java.lang.reflect包的方法对类进行反射调用
   - 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类
2. 类的被动引用（不会发生类的初始化）
   - 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化
   - 通过数组定义类引用，不会触发此类的初始化
   - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）

```java
public class Test06 {
    static {
        System.out.println("Main类被加载");
    }

    public static void main(String[] args) throws ClassNotFoundException {
        //主动引用
        //1.new一个类的对象，
        Son son = new Son();
        /*
        Main类被加载
        父类被加载
        子类被加载
         */
        
        //2.反射，也会产生主动引用
        Class.forName("com.reflection.Son");
        /*
        Main类被加载
        父类被加载
        子类被加载
         */
        
        //不会产生类的引用
        //1.通过子类引用父类的静态变量，不会导致子类初始化
        System.out.println(Son.b);
        /*
        Main类被加载
        父类被加载
        2
         */
        
        //2.通过数组定义类引用，不会触发此类的初始化
        Son[] array = new Son[5];
        /*
        Main类被加载
         */
        
        //3.引用常量,不会触发此类的初始化
        System.out.println(Son.M);
        /*
        Main类被加载
        1
         */
    }
}

class Father {
    static int b = 2;
    static {
        System.out.println("父类被加载");
    }
}

class Son extends Father {
    static int m = 100;
    static final int M = 1;
    static {
        System.out.println("子类被加载");
        m = 300;
    }
}
```

### 类加载器的作用

1. 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。

2. 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象

   <img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240331144520432-1420106241.png" alt="image-20240331144520077" width="400" />

3. 类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器  

   <img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240331144526461-759913973.png" alt="image-20240331144526237" width="500" />

   ```java
   public static void main(String[] args) throws ClassNotFoundException {
       //获取系统类的加载器
       ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
       System.out.println(systemClassLoader);  //sun.misc.Launcher$AppClassLoader@18b4aac2
   
       //获取扩展类加载器->系统类加载器的父类
       ClassLoader parent = systemClassLoader.getParent();
       System.out.println(parent); //sun.misc.Launcher$ExtClassLoader@1540e19d
   
       //获取根加载器(C/C++)->扩展类加载器的父类
       ClassLoader parent1 = parent.getParent();
       System.out.println(parent1);    //null
   
       //测试当前类是哪个加载器加载的    自定义的类由系统类加载器加载
       ClassLoader classLoader = Class.forName("com.reflection.Test07").getClassLoader();
       System.out.println(classLoader);    //sun.misc.Launcher$AppClassLoader@18b4aac2
   
       //测试JDK内置的类是谁加载的    核心类由根加载器加载
       ClassLoader classLoader1 = Class.forName("java.lang.Object").getClassLoader();
       System.out.println(classLoader1);    //null
   
       //如何获得系统类加载器可以加载的路径
       System.out.println(System.getProperty("java.class.path"));
       /*
       双亲委派机制
           java.lang.String
        */
       
       /*
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\charsets.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\deploy.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\javaws.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\jce.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfr.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\jsse.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\management-agent.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\plugin.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\resources.jar;
       C:\Program Files\Java\jdk1.8.0_181\jre\lib\rt.jar;
       D:\JAVA Class\JavaSE\out\production\JichuYufa;
       D:\JAVA Class\JavaSE\JichuYufa\src\com\lib\commons-io-2.15.1.jar;
       D:\IntelliJ IDEA 2023.3.4\lib\idea_rt.jar
        */
   }
   ```

## 获取运行时类的完整结构

1. 通过反射获取运行时类的完整结构Field、Method、Constructor、Superclass、Interface、Annotation
   - 实现的全部接口
   - 所继承的父类
   - 全部的构造器
   - 全部的方法
   - 全部的Field注解。。。

```java
public static void main(String[] args) throws Exception {
    Class c1 = Class.forName("com.reflection.User");
    User user = new User();
    Class c2 = user.getClass();

    //1.获得类的名字 包名+类名
    System.out.println(c2.getName());   //com.reflection.User
    //2.获得类的简单名字 类名
    System.out.println(c2.getSimpleName()); //User
    //3.获得类的属性
    Field[] fields = c2.getFields();
    for (Field field : fields) {
        System.out.println(field);  //只能找到public属性
    }
    System.out.println("=========================================");
    for (Field declaredField : c2.getDeclaredFields()) {
        System.out.println(declaredField);  //可以找到全部的属性
    }
    /*
    private java.lang.String com.reflection.User.name
    private int com.reflection.User.id
    private int com.reflection.User.age
     */
    //4.获得指定属性的值
    //Field name = c2.getField("name");   //.NoSuchFieldException
    //System.out.println(name);

    Field name1 = c2.getDeclaredField("name");
    System.out.println(name1);  //private java.lang.String com.reflection.User.name

    //5.获得类的方法
    for (Method method : c2.getMethods()) {
        System.out.println("getMethods-->" + method);   //获得本类及其父类的全部public方法
    }
    /*
    getMethods-->public java.lang.String com.reflection.User.toString()
    getMethods-->public java.lang.String com.reflection.User.getName()
    getMethods-->public int com.reflection.User.getId()
    getMethods-->public void com.reflection.User.setName(java.lang.String)
    getMethods-->public int com.reflection.User.getAge()
    getMethods-->public void com.reflection.User.setAge(int)
    getMethods-->public void com.reflection.User.setId(int)
    ---------------------------------------------------------------------------------------------
    getMethods-->public final void java.lang.Object.wait() throws java.lang.InterruptedException
    getMethods-->public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
    getMethods-->public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
    getMethods-->public boolean java.lang.Object.equals(java.lang.Object)
    getMethods-->public native int java.lang.Object.hashCode()
    getMethods-->public final native java.lang.Class java.lang.Object.getClass()
    getMethods-->public final native void java.lang.Object.notify()
    getMethods-->public final native void java.lang.Object.notifyAll()
     */
    for (Method declaredMethod : c2.getDeclaredMethods()) {
        System.out.println("getDeclaredMethods-->" + declaredMethod);   //获得本类的所有方法，包括私有的
    }
    /*
    getDeclaredMethods-->public java.lang.String com.reflection.User.toString()
    getDeclaredMethods-->public java.lang.String com.reflection.User.getName()
    getDeclaredMethods-->public int com.reflection.User.getId()
    getDeclaredMethods-->public void com.reflection.User.setName(java.lang.String)
    getDeclaredMethods-->public int com.reflection.User.getAge()
    getDeclaredMethods-->public void com.reflection.User.setAge(int)
    getDeclaredMethods-->public void com.reflection.User.setId(int)
     */

    //6.获得指定方法
    //需要参数，是因为方法有重载
    Method getName = c2.getMethod("getName", null);
    System.out.println(getName);    //public java.lang.String com.reflection.User.getName()

    //方法名 + 参数类型
    Method setName = c2.getMethod("setName", String.class);
    System.out.println(setName);    //public void com.reflection.User.setName(java.lang.String)
    System.out.println("=========================================");

    //7.获得构造器
    for (Constructor constructor : c2.getConstructors()) {
        System.out.println("getConstructors-->" + constructor);
    }
    /*
    getConstructors-->public com.reflection.User()
    getConstructors-->public com.reflection.User(java.lang.String,int,int)
     */

    for (Constructor declaredConstructor : c2.getDeclaredConstructors()) {
        System.out.println("getDeclaredConstructors-->" + declaredConstructor);
    }
    /*
    getDeclaredConstructors-->public com.reflection.User()
    getDeclaredConstructors-->public com.reflection.User(java.lang.String,int,int)
     */
    //8.获得指定的构造器
    System.out.println(c2.getConstructor(String.class, int.class, int.class));
    //public com.reflection.User(java.lang.String,int,int)
    System.out.println(c2.getDeclaredConstructor(null));
    //public com.reflection.User()
}
```

小结

- 在实际的操作中，取得类的信息的操作代码，并不会经常开发。
- 一定要熟悉java.lang.reflect包的作用，反射机制。
- 如何取得属性、方法、构造器的名称，修饰符等。

## Class类对象的作用

### 创建类的对象

1. 调用Class对象的newInstance()方法类

   - 必须有一个无参数的构造器。
   - 类的构造器的访问权限需要足够

2. 思考？

   难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。

3. 步骤如下：

   - 通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器
   - 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。
   - 通过Constructor实例化对象

### 调用指定的方法

1. 通过反射，调用类中的方法，通过Method类完成。

   <img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240331152420330-1279784389.png" alt="image-20240331152419498" width="400" />

   1. 通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。
   2. 之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。

2. Object invoke(Object obj, Object[] args)

   - Object 对应原方法的返回值，若原方法无返回值，此时返回null
   - 若原方法若为静态方法，此时形参Object obj可为null
   - 若原方法形参列表为空，则Object[] args为null
   - 若原方法声明为`private`,则需要在调用此invoke()方法前，显式调用方法对象的`setAccessible(true)`方法，将可访问private的方法。

3. setAccessible(boolean b)

   - Method和Field、Constructor对象都有setAccessible()方法。
   - setAccessible作用是启动和禁用访问安全检查的开关。
   - 参数值为`true`则指示反射的对象在使用时应该`取消Java语言访问检查`。
   - 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。
   - 使得原本无法访问的私有成员也可以访问
   - 参数值为false则指示反射的对象应该实施Java语言访问检查

```java
//动态的创建对象 通过反射
public static void main(String[] args) throws Exception {
    //1.获得Class对象
    Class c1 = Class.forName("com.reflection.User");

    //2.构造一个对象
    User user = (User) c1.newInstance();    //本质上是调用了类的无参构造器
    System.out.println(user);   //User{name='null', id=0, age=0}

    //3.通过构造器创建对象
    Constructor constructor = c1.getConstructor(String.class, int.class, int.class);
    User user2 = (User) constructor.newInstance("张三", 001, 18);
    System.out.println(user2);  //User{name='张三', id=1, age=18}

    //4.通过反射 调用普通方法
    User user3 = (User) c1.newInstance();
    //通过反射 获取一个方法
    Method setName = c1.getMethod("setName", String.class);
    //**invoke 激活  （对象,"方法的值"）
    setName.invoke(user3, "李四");
    System.out.println(user3.getName());    //李四

    //5.通过反射 操作属性
    User user4 = (User) c1.newInstance();
    Field name = c1.getDeclaredField("name");

    //**不能直接操作私有属性 需要关闭程序的安全检测 设置setAccessible
    name.setAccessible(true);
    name.set(user4, "王五");
    System.out.println(user4.getName());    //.IllegalAccessException   王五
}
```

### 方法调用-性能对比分析

```java
public class Test10 {
    //1.普通方式调用
    public static void test01() {
        User user = new User();
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000000000; i++) {
            user.getName();
        }
        long endTime = System.currentTimeMillis();
        System.out.println("普通方法执行时间：" + (endTime - startTime) + "ms"); //普通方法执行时间：2ms
    }

    //2.反射方式调用
    public static void test02() throws Exception {
        User user = new User();
        Class c1 = user.getClass();
        Method getName = c1.getMethod("getName", null);

        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000000000; i++) {
            getName.invoke(user, null);
        }
        long endTime = System.currentTimeMillis();
        System.out.println("反射方式执行时间：" + (endTime - startTime) + "ms"); //反射方式执行时间：1540ms
    }

    //3.反射方式调用 关闭检测
    public static void test03() throws Exception {
        User user = new User();
        Class c1 = user.getClass();
        Method getName = c1.getMethod("getName", null);
        getName.setAccessible(true);

        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000000000; i++) {
            getName.invoke(user, null);
        }
        long endTime = System.currentTimeMillis();
        System.out.println("关闭检测的反射方式执行时间：" + (endTime - startTime) + "ms");    //关闭检测的反射方式执行时间：956ms
    }

    public static void main(String[] args) throws Exception {
        test01();
        test02();
        test03();
    }
}
```

## 反射操作泛型

### 概述

1. Java采用泛型擦除的机制来引入泛型 , Java中的泛型仅仅是给编译器javac使用的,确保数据的安全性和免去强制类型转换问题 , 但是 , 一旦编译完成 , 所有和泛型有关的类型全部擦除
2. 为了通过反射操作这些类型 , Java新增了 ParameterizedType , GenericArrayType , TypeVariable和 WildcardType 几种类型。代表不能被归一到Class类中的类型但是又和原始类型齐名的类型. 
   - ParameterizedType : 表示一种参数化类型,比如Collection
   - GenericArrayType : 表示一种元素类型是参数化类型或者类型变量的数组类型
   - TypeVariable : 是各种类型变量的公共父接口
   - WildcardType : 代表一种通配符类型表达式

### 获取泛型信息

```java
//通过反射  获得泛型信息
public class Test11 {
    public void test01(Map<String, User> map, List<User> list) {
        System.out.println("test01");
    }

    public Map<String, User> test02() {
        System.out.println("test02");
        return null;
    }

    public static void main(String[] args) throws NoSuchMethodException {
        Method method = Test11.class.getMethod("test01", Map.class, List.class);
        //1.getGenericParameterTypes() 获得泛型的参数类型
        for (Type genericParameterType : method.getGenericParameterTypes()) {
            System.out.println("Test01的泛型参数信息：" + genericParameterType);

            if (genericParameterType instanceof ParameterizedType) {
                for (Type actualTypeArgument : ((ParameterizedType) genericParameterType).getActualTypeArguments()) {
                    System.out.println("真实的泛型参数信息：" + actualTypeArgument);
                }
            }
        }
        /*
        public void test01(Map<String, User> map, List<User> list)
        Test01的泛型参数信息：java.util.Map<java.lang.String, com.reflection.User>
        真实的泛型参数信息：class java.lang.String
        真实的泛型参数信息：class com.reflection.User
        Test01的泛型参数信息：java.util.List<com.reflection.User>
        真实的泛型参数信息：class com.reflection.User
         */

        Method method1 = Test11.class.getMethod("test02", null);
        //2.getGenericReturnType() 获得泛型的返回值类型
        Type genericReturnType = method1.getGenericReturnType();
        if (genericReturnType instanceof ParameterizedType) {
            for (Type actualTypeArgument : ((ParameterizedType) genericReturnType).getActualTypeArguments()) {
                System.out.println("Test02的泛型返回值类型" + actualTypeArgument);
            }
        }
        /*
        public Map<String, User> test02()
        Test02的泛型返回值类型class java.lang.String
        Test02的泛型返回值类型class com.reflection.User
         */
    }
}
```

## 反射操作注解

### ORM

Object relationship Mapping --> 对象关系映射 

<img src="https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240331172859243-1169267165.png" alt="image-20240331172858587" width="500" />

- 类和表结构对应
- 属性和字段对应
- 对象和记录对应

要求 : 利用注解和反射完成类和表结构的映射关系

### 获取注解信息

```java
public class Test12 {
    public static void main(String[] args) throws Exception {
        Class c1 = Class.forName("com.reflection.Student2");

        //1.通过反射 获取注解
        for (Annotation annotation : c1.getAnnotations()) {
            System.out.println(annotation); //@com.reflection.Tablename(value=db_student)
        }

        //2.获得注解value的值
        Tablename tablename = (Tablename) c1.getAnnotation(Tablename.class);
        String value = tablename.value();
        System.out.println(value);  //db_student

        //3.获得类指定字段的注解
        Field f = c1.getDeclaredField("name");
        Fieldname annotation = f.getAnnotation(Fieldname.class);
        System.out.println(annotation.columName()); //db_name
        System.out.println(annotation.type());  //varchar
        System.out.println(annotation.length());    //3
        System.out.println(annotation); //@com.reflection.Fieldname(columName=db_name, type=varchar, length=3)
    }
}

@Tablename("db_student")
class Student2 {
    @Fieldname(columName = "db_id", type = "int", length = 10)
    private int id;
    @Fieldname(columName = "db_age", type = "int", length = 10)
    private int age;
    @Fieldname(columName = "db_name", type = "varchar", length = 3)
    private String name;

    @Override
    public String toString() {
        return "Student2{" + "id=" + id + ", age=" + age +
                ", name='" + name + '\'' + '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Student2(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    public Student2() {}
}

//类名的注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Tablename {
    String value();
}

//属性的注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface Fieldname {
    String columName();

    String type();

    int length();
}
```
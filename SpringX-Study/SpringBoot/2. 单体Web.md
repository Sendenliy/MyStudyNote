# SpringBoot Web开发

## 使用SpringBoot的步骤

1. 创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好。
2. 手动在配置文件中配置部分配置项目就可以运行起来了
3. 专注编写业务代码，不需要考虑以前那样一大堆的配置了。

## 自动装配

springboot到底帮我们配置了什么？能不能修改，能修改哪些东西？能不能拓展

- xxxxAutoConfigurartion…向容器中自动配置组件
- xxxxProperties:自动配置类，装配配置文件中自定义的一些内容

## 要解决的问题

- 导入静态资源…
- 首页
- jsp,模版引擎Thymeleaf
- 装配扩展SpringMVC
- 增删改查
- 拦截器
- 国际化

## 静态资源总结

在springboot，我们 可以使用以下方式处理静态资源

- webjarslocalhost:8080/wbjars/
- Public, static,/**,resources, localhost:8080
- 优先级：resources>static>(默认)>public

# 静态资源处理

## Webjars

Webjars本质就是以jar包的方式引入我们的静态资源 ， 使用SpringBoot需要使用Webjars。我们以前要导入一个静态资源文件(比如jQuery)，直接导入即可。

- 网站：https://www.webjars.org/

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516162008836-280224005.png" alt="image-20240516162012449" width="400" />

如果要使用jQuery

- 我们只要要引入jQuery对应版本的pom依赖即可！

  ```xml
  <dependency>
      <groupId>org.webjars</groupId>
      <artifactId>jquery</artifactId>
      <version>3.7.1</version>
  </dependency>
  ```

- 导入完毕，查看webjars目录结构，并访问Jquery.js文件！

  Maven安装的都符合"classpath:/META-INF/resources/webjars/"结构

  <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516162314682-782425897.png" alt="image-20240516162319995" width="300" />

- 访问：http://localhost:8080/webjars/jquery/3.7.1/jquery.js

  只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问.   

## 源码分析

SpringBoot中，SpringMVC的web配置都在` WebMvcAutoConfiguration` 这个配置类里面；我们可以去看看 `WebMvcAutoConfigurationAdapter` 中有很多配置方法；有一个方法：` addResourceHandlers `添加资源处理。

```java
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    if (!this.resourceProperties.isAddMappings()) {
        //如果自定义配置 则禁用默认资源处理
        logger.debug("Default resource handling disabled");
    } else {
        //getWebjarsPathPattern()--> webjarsPathPattern = "/webjars/**";
        this.addResourceHandler(registry, this.mvcProperties.getWebjarsPathPattern(), "classpath:/META-INF/resources/webjars/");
        //getStaticPathPattern()--> staticPathPattern = "/**";
        this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {
            //resourceProperties --> CLASSPATH_RESOURCE_LOCATIONS = new String[]{"classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"};
            registration.addResourceLocations(this.resourceProperties.getStaticLocations());
            if (this.servletContext != null) {
                ServletContextResource resource = new ServletContextResource(this.servletContext, "/");
                registration.addResourceLocations(new Resource[]{resource});
            }

        });
    }
}
```

## 静态资源映射规则

### 默认访问方式

1. Maven引入webjars包：访问`/webjars/** ` 路径的，会被映射到`"classpath:/META-INF/resources/webjars/"`

2. 访问静态资源路径为`/**`的，会被映射到以下路径去寻找

   classpath- -> SpringBoot自带的resources资源目录下

   `优先级：resources > static[默认] > public`

   - "/META-INF/resources/"
   - "classpath:/resources/"
   -  "classpath:/static/"
   - "classpath:/public/

测试：

1. 在src\main\resources\public下新建1.js

   ```js
   hello
   ```

2. 访问localhost:8080/1.js

3. 访问成功

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516164847283-1562756448.png" alt="image-20240516164852257" width="300" />

### 自定义方式

1. 在application.properties中设置

   【注意】一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！  

   ```properties
   #修改扫描静态资源的位置
   spring.web.resources.static-locations=classpath:/hello/
   
   #修改访问的地址：spring.mvc.static-path-pattern=/hello/**
   ```

2. 访问localhost:8080/3.js

3. 访问成功

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516173145269-1714134695.png" alt="image-20240516173150132" width="300" />

# 首页处理

## 源码分析

欢迎页的映射，就是我们的首页！ ` welcomePageHandlerMapping`

```java
@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {
    // ::是java8 中新引入的运算符
	// Class::function的时候function是属于Class的，应该是静态方法。
	// this::function的funtion是属于这个对象的。
    return (WelcomePageHandlerMapping)this.createWelcomePageHandlerMapping(applicationContext, mvcConversionService, mvcResourceUrlProvider, WelcomePageHandlerMapping::new);
}
```

往下看，`createWelcomePageHandlerMapping`

```java
private <T extends AbstractUrlHandlerMapping> T createWelcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider, WelcomePageHandlerMappingFactory<T> factory) {
    TemplateAvailabilityProviders templateAvailabilityProviders = new TemplateAvailabilityProviders(applicationContext);
    //刚才默认静态资源的位置mvcProperties.getStaticPathPattern()-->/**
    String staticPathPattern = this.mvcProperties.getStaticPathPattern();
    T handlerMapping = factory.create(templateAvailabilityProviders, applicationContext, this.getIndexHtmlResource(), staticPathPattern);
    handlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider));
    handlerMapping.setCorsConfigurations(this.getCorsConfigurations());
    return handlerMapping;
}
```

往下看，`this.getIndexHtmlResource()`

```java
//第一步
private Resource getIndexHtmlResource() {
    //getStaticLocations() -->静态资源目录
    for (String location : this.resourceProperties.getStaticLocations()) {
        Resource indexHtml = getIndexHtmlResource(location);
        if (indexHtml != null) {
            return indexHtml;
        }
    }
    ServletContext servletContext = getServletContext();
    if (servletContext != null) {
        return getIndexHtmlResource(new ServletContextResource(servletContext, SERVLET_LOCATION));
    }
    return null;
}
//第二步
private Resource getIndexHtmlResource(String location) {
    //获取location资源
    return getIndexHtmlResource(this.resourceLoader.getResource(location));
}
//第三步
private Resource getIndexHtmlResource(Resource location) {
    try {
        //欢迎页就是一个location下的的 index.html 而已
        //欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射
        Resource resource = location.createRelative("index.html");
        if (resource.exists() && (resource.getURL() != null)) {
            return resource;
        }
    }
    catch (Exception ex) {
        // Ignore
    }
    return null;
}
```

## 自定义首页

### 方式一

1. 新建一个 index.html ，在3个静态资源目录中任意一个，比如public目录下；

   ```html
   <body>
   <h1>首页</h1>
   
   </body>
   ```

2. 然后访问测试 http://localhost:8080/ 看结果

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516181936437-2024884076.png" alt="image-20240516181941108" width="200" />

### 方式二

templates目录下的所有页面，只能通过Controller来跳转

1. 在templates目录下，建一个 index.html 

   ```html
   <body>
   <h1>首页</h1>
   
   </body>
   ```

2. 新建一个IndexController来跳转

   这里需要模版引擎支持

3. 然后访问测试 http://localhost:8080/ 看结果

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516181936437-2024884076.png" alt="image-20240516181941108" width="200"/>

## 自定义网站图标

### 2.2+

1. 自己放一个 favicon.ico图标在静态资源目录下

2. 在页面中引用

   ```html
   <link rel="icon" href="/favicon.ico">
   ```

3. 显示成功

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516185042969-441706013.png" alt="image-20240516185047837" width="200" />

### 2.2版本以前

与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。

1. 关闭SpringBoot默认图标

   ```properties
   #关闭默认图标【已失效】
   spring.mvc.favicon.enabled=false
   ```

2. 自己放一个图标在静态资源目录下，我放在 public 目录下

3. 清除浏览器缓存！刷新网页，发现图标已经变成自己的了！

# Thymeleaf

**`读音：[taimli:f]`**

## 模板引擎

前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。

jsp支持非常强大的功能，包括能写Java代码。但是我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war；第二，我们用的还是嵌入式的Tomcat，所以，他现在默认是不支持jsp的。那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？

SpringBoot推荐你可以来使用模板引擎：

模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有以用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图：

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240513210605910-282931975.png" alt="image-20240513210609510" width="400" />

模板引擎的作用

- 就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。
- 而这些值，就是我们在后台封装一些数据。
- 然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去

这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。Thymeleaf模板引擎是一个高级语言的模板引擎，他的这个语法更简单，功能更强大。

## 引入Thymeleaf

怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：

- Thymeleaf 官网：https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html

- Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf 

- Spring官方文档： 找到我们对应的版本https://springdoc.cn/spring-boot/using.html#using.build-systems.starters

  <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516190321961-1042702369.png" alt="image-20240516190326693" style="zoom:67%;" />

找到对应的pom依赖：可以适当点进源码看下本来的包！  

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
<!--内部是-->
    <dependency>
        <groupId>org.thymeleaf</groupId>
        <artifactId>thymeleaf-spring6</artifactId>
        <version>3.1.2.RELEASE</version>
        <scope>compile</scope>
    </dependency>
```

Maven会自动下载jar包，我们可以去看下下载的东西；

## thymeleaf 分析

### 源码

我们首先得按照Thymeleaf的自动配置类：ThymeleafProperties，看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。

```java
@ConfigurationProperties(prefix = "spring.thymeleaf")
public class ThymeleafProperties {

    private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;

    public static final String DEFAULT_PREFIX = "classpath:/templates/";

    public static final String DEFAULT_SUFFIX = ".html";
```

- 我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。
- 使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！

### 测试

1. 编写一个TestController

   ```java
   @Controller
   public class index {
       @RequestMapping("/test")
       public String index() {
           return "test";
       }
   }
   ```

2. 编写一个测试页面 test.html 放在 templates 目录下

   ```html
   <body>
       <link rel="icon" href="/favicon.ico">
       <h1>test</h1>
   </body>
   ```

3. 启动项目请求测试

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516191755080-1569441944.png" alt="image-20240516191800058" width="200" />

## Thymeleaf 使用

Thymeleaf 官网：https://www.thymeleaf.org/ 

我们做个最简单的练习 ： 我们需要查出一些数据，在页面中展示

1. 修改测试controller请求，增加数据传输；

   ```java
   @Controller
   public class index {
       @RequestMapping("/test")
       public String index(Model model) {
           model.addAttribute("msg", "Hello thymeleaf");
           return "test";
       }
   }
   ```

2. 我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。

   ```html
   <html xmlns:th="http://www.thymeleaf.org">
   ```

3. 我们去编写下前端页面

   ```html
   <body>
       <link rel="icon" href="/favicon.ico">
       <h1>test</h1>
       <!--所有的html元素都可以被thymeleaf替换接管  th:元素名
           元素名：text/class/style...
       -->
       <div th:text="${msg}"></div>
   </body>
   ```

4. 启动测试！  

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516193104115-573816991.png" alt="image-20240516193108704" width="200" />

## Thymeleaf语法

### 属性优先级

| Order | Feature                                             | Attributes                                   |
| :---- | :-------------------------------------------------- | :------------------------------------------- |
| 1     | Fragment inclusion[片段包含jsp:include]             | `th:insert`  `th:replace`                    |
| 2     | Fragment iteration[遍历c:forEach]                   | `th:each`                                    |
| 3     | Conditional evaluation[条件判断c:if]                | `th:if`  `th:unless`  `th:switch`  `th:case` |
| 4     | Local variable definition[声明变量C:set]            | `th:object`  `th:with`                       |
| 5     | General attribute modification[任意属性修改]        | `th:attr`  `th:attrprepend`  `th:attrappend` |
| 6     | Specific attribute modification[修改指定属性默认值] | `th:value`  `th:href`  `th:src`  `...`       |
| 7     | Text (tag body modification)[修改标签体内容]        | `th:text`  `th:utext`                        |
| 8     | Fragment specification[声明片段]                    | `th:fragment`                                |
| 9     | Fragment removal                                    | `th:remove`                                  |

### 标准表达式

1. Simple expressions:表达式语法

   - Variable Expressions变量: `${...}`
   - Selection Variable Expressions: `*{...}`
   - Message Expressions: `#{...}`
   - Link URL Expressions: `@{...}`
   - Fragment Expressions: `~{...}`

   ```properties
   1）、获取对象的属性、调用方法
   2）、使用内置的基本对象： #18
   #ctx : the context object.
   #vars: the context variables.
   #locale : the context locale.
   #request : (only in Web Contexts) the HttpServletRequest object.
   #response : (only in Web Contexts) the HttpServletResponse object.
   #session : (only in Web Contexts) the HttpSession object.
   #servletContext : (only in Web Contexts) the ServletContext object.
   3）、内置的一些工具对象：
   #execInfo : information about the template being processed.
   #uris : methods for escaping parts of URLs/URIs
   #conversions : methods for executing the configured conversionservice (if any).
   #dates : methods for java.util.Date objects: formatting, componentextraction, etc.
   #calendars : analogous to #dates , but for java.util.Calendarobjects.
   #numbers : methods for formatting numeric objects.
   #strings : methods for String objects: contains, startsWith,prepending/appending, etc.
   #objects : methods for objects in general.
   #bools : methods for boolean evaluation.
   #arrays : methods for arrays.
   #lists : methods for lists.
   #sets : methods for sets.
   #maps : methods for maps.
   #aggregates : methods for creating aggregates on arrays orcollections.
   ```

2. Literals字面量

   - Text literals文本: `'one text'`, `'Another one!'`,…
   - Number literals数字: `0`, `34`, `3.0`, `12.3`,…
   - Boolean literals: `true`, `false`
   - Null literal空值: `null`
   - Literal tokens: `one`, `sometext`, `main`,…

3. Text operations:文本操作

   - String concatenation: `+`
   - Literal substitutions: `|The name is ${name}|`

4. Arithmetic operations:数学运算

   - Binary operators: `+`, `-`, `*`, `/`, `%`
   - Minus sign (unary operator): `-`

5. Boolean operations:布尔运算

   - Binary operators: `and`, `or`
   - Boolean negation (unary operator): `!`, `not`

6. Comparisons and equality:比较运算

   - Comparators: `>`, `<`, `>=`, `<=` (`gt`, `lt`, `ge`, `le`)
   - Equality operators: `==`, `!=` (`eq`, `ne`)

7. Conditional operators:条件运算

   - If-then: `(if) ? (then)`
   - If-then-else: `(if) ? (then) : (else)`
   - Default: `(value) ?: (defaultvalue)`

8. Special tokens:分隔

   - No-Operation: `_`

### 测试

1. 我们编写一个Controller，放一些数据

   ```java
   @Controller
   public class index {
       @RequestMapping("/test")
       public String index(Model model) {
           model.addAttribute("msg", "<h1>Hello thymeleaf</h1>");
   
           model.addAttribute("users", Arrays.asList("sun1", "sun2", "sun3", "sun4", "sun5", "sun6", "sun7"));
           return "test";
       }
   }
   ```

2. 测试页面取出数据

   ```html
   <body>
       1.取值
       <div th:text="${msg}"></div>
       <!--<h1>Hello thymeleaf</h1>-->
   
       <div th:utext="${msg}"></div>
       <!--Hello thymeleaf-->
   
       2.遍历
       <h3 th:each="user:${users}" th:text="${user}"></h3>
       <h3 th:each="user:${users}">[[${user}]]</h3>
       <!--
       sun1
       sun2
       sun3
       sun4
       sun5
       sun6
       sun7
       -->
   </body>
   ```

3. 启动项目测试！

# MVC 自动配置原理

## 简介

### 分析途径

SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。只有把这些都搞清楚了，我们在之后使用才会更加得心应手。

-  途径一：源码分析，

- 途径二：中文文档！

  地址 ：https://springdoc.cn/spring-boot/web.html#web.servlet.spring-mvc

- 官网：https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/#web.servlet.spring-mvc.auto-configuration

### 自动配置MVC

Spring Boot为Spring MVC提供了自动配置功能，对大多数应用程序都很适用。

自动配置在Spring的默认值基础上增加了以下功能。

- 包含了 `ContentNegotiatingViewResolver` 和 `BeanNameViewResolver` Bean。
- 支持为静态资源提供服务，包括对WebJars的支持
- 自动注册 `Converter`、`GenericConverter` 和 `Formatter` Bean。
- 支持 `HttpMessageConverters`
- 自动注册 `MessageCodesResolver`
- 支持静态的 `index.html`。
- 自动使用 `ConfigurableWebBindingInitializer` bean

## 扩展Spring Boot MVC

### 扩展内容

既保留了SpringBoot所有的自动配置，也能用我们扩展的配置！

- Interceptor
- Formatter
- 视图控制器
- 和其他功能

### 扩展方法

1. 添加自己的 @Configuration 类：变成配置类

2. 实现接口 WebMvcConfigurer

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516201131068-222260905.png" alt="image-20240516201136076" width="500" />

3. 不含@EnableWebMvc

代码实现：

- 新建一个包叫config，写一个类MyMvcConfig

```java
//1.添加自己的 @Configuration 类：变成配置类
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
    //2.实现接口 WebMvcConfigurer
    
    //.....
}

//例如：扩展一个视图跳转
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
    //视图跳转
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        //访问"/sunm" 可以获取/templates/test.html
        registry.addViewController("/sunm").setViewName("test");
    }
}
```

### 扩展原理

1. WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter
2. 这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)
3. 我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类： DelegatingWebMvcConfiguration这个父类中有这样一段代码：
4. 我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个
5. 我们点进去看一下
6. 所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；

### 扩展视图解析器

spring Boot自动配置在Spring的默认值基础上增加了 `视图解析器`

- `ContentNegotiatingViewResolver` 
- 和 BeanNameViewResolver  Bean

#### 源码分析

`自动配置了ViewResolver`，就是我们之前学习的SpringMVC的视图解析器；即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。

我们去看看这里的源码：ContentNegotiatingViewResolver

```java
//实现了视图解析器接口ViewResolver的类 就可以看作是视图解析器
//重写了ViewResolver的resolveViewName()方法
public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport implements ViewResolver, Ordered, InitializingBean {
    //.....
    
    @Override
    @Nullable
    public View resolveViewName(String viewName, Locale locale) throws Exception {
        RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
        Assert.state(attrs instanceof ServletRequestAttributes, "No current ServletRequestAttributes");
        List<MediaType> requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());
        if (requestedMediaTypes != null) {
            //获取候选的视图getCandidateViews
            List<View> candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);
            View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);
            if (bestView != null) {
                return bestView;
            }
        }

        String mediaTypeInfo = this.logger.isDebugEnabled() && requestedMediaTypes != null ? " given " + requestedMediaTypes.toString() : "";
        if (this.useNotAcceptableStatusCode) {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug("Using 406 NOT_ACCEPTABLE" + mediaTypeInfo);
            }

            return NOT_ACCEPTABLE_VIEW;
        } else {
            this.logger.debug("View remains unresolved" + mediaTypeInfo);
            return null;
        }
    }
    //.....
}
```

怎么获得候选的视图的呢？进入getCandidateViews()

- getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！

```java
private List<View> getCandidateViews(String viewName, Locale locale, List<MediaType> requestedMediaTypes) throws Exception {
    List<View> candidateViews = new ArrayList();
    if (this.viewResolvers != null) {
        Assert.state(this.contentNegotiationManager != null, "No ContentNegotiationManager set");
        Iterator var5 = this.viewResolvers.iterator();
		//不为空，就遍历所有的视图解析器viewResolvers
        while(var5.hasNext()) {
            ViewResolver viewResolver = (ViewResolver)var5.next();
            //封装对象
            View view = viewResolver.resolveViewName(viewName, locale);
            if (view != null) {
                //添加到候选视图
                candidateViews.add(view);
            }

            Iterator var8 = requestedMediaTypes.iterator();

            while(var8.hasNext()) {
                MediaType requestedMediaType = (MediaType)var8.next();
                List<String> extensions = this.contentNegotiationManager.resolveFileExtensions(requestedMediaType);
                Iterator var11 = extensions.iterator();

                while(var11.hasNext()) {
                    String extension = (String)var11.next();
                    String viewNameWithExtension = viewName + "." + extension;
                    view = viewResolver.resolveViewName(viewNameWithExtension, locale);
                    if (view != null) {
                        candidateViews.add(view);
                    }
                }
            }
        }
    }
    if (!CollectionUtils.isEmpty(this.defaultViews)) {
        candidateViews.addAll(this.defaultViews);
    }
    //返回候选视图
    return candidateViews;
}
```

所以得出结论：`ContentNegotiatingViewResolver` 这个视图解析器就是用来`组合所有的视图解析器的`

我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！

#### 自定义实现

1. 我们在我们的主程序中去写一个视图解析器来试试；

   ```java
   @Configuration
   public class MyMvcConfig implements WebMvcConfigurer {
       //2.将自定义的视图解析器交给到Springboot，springboot就会帮我们自动装配
       @Bean
       public ViewResolver myViewResolver() {
           return new MyViewResolver();
       }
   
       //1.自定义视图解析器
       public static class MyViewResolver implements ViewResolver {
           @Override
           public View resolveViewName(String viewName, Locale locale) throws Exception {
               return null;
           }
       }
   }
   ```

2. 怎么看我们自己写的视图解析器有没有起作用呢？我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中

3. 我们启动我们的项目，然后随便访问一个页面，看一下Debug信息；找到this

4. 找到视图解析器，我们看到我们自己定义的就在这里了；

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240516204418236-143800152.png" alt="image-20240516204423054" width="500" />

5. 所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了

### 扩展格式化器

WebMvcAutoConfiguration中找格式化转换器：

```java
@Bean
@Override
public FormattingConversionService mvcConversionService() {
    //从配置文件中找到格式化的信息
    Format format = this.mvcProperties.getFormat();
    WebConversionService conversionService = new WebConversionService(
          new DateTimeFormatters().dateFormat(format.getDate())
             .timeFormat(format.getTime())
             .dateTimeFormat(format.getDateTime()));
    addFormatters(conversionService);
    return conversionService;
}
```

可以看到在我们的Properties文件中，我们可以进行自动配置它！

```java
public static class Format {
    /**
     * Date format to use, for example 'dd/MM/yyyy'.
     */
    private String date;

    /**
     * Time format to use, for example 'HH:mm:ss'.
     */
    private String time;

    /**
     * Date-time format to use, for example 'yyyy-MM-dd HH:mm:ss'.
     */
    private String dateTime;
}
```

我们可以在配置文件中配置日期格式化的规则：

```properties
#日期格式化
spring.mvc.format.date=dd/MM/yyyy
```

## SpringBoot自动配置

这么多的自动配置，原理都是一样的。通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论，这个结论一定是属于自己的，而且一通百通。SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码，得出结论。

SpringBoot在自动配置很多组件的时候：

- 先看容器中有没有用户自己配置的（如果用户自己配置@bean）
- 如果有，就用用户配置的
- 如果没有，就用自动配置的
- 如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！

## 全面接管Spring Boot MVC

### 完全控制Spring MVC的方式：

- 添加自己的 @Configuration ，并使用 @EnableWebMvc 注解
- 或者添加你自己的 @Configuration 并使用 DelegatingWebMvcConfiguration 注解 ，如 @EnableWebMvc 的Javadoc中所述。

### 全面接管的含义

- SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！
- 我们之前SpringBoot给我们配置的静态资源映射一定会无效【我们开发中，不推荐使用全面接管SpringMVC】

### @EnableWebMvc

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
//导入一个类 DelegatingWebMvcConfiguration
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
}
```

为什么加了一个注解@EnableWebMvc，自动配置就失效了！我们看下源码：

1. 这里发现它是导入了一个类DelegatingWebMvcConfiguration，我们可以继续进去看

   它继承了一个父类 WebMvcConfigurationSupport

   ```java
   @Configuration(proxyBeanMethods = false)
   public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
   	//....
       @Autowired(required = false)
       public void setConfigurers(List<WebMvcConfigurer> configurers) {
          if (!CollectionUtils.isEmpty(configurers)) {
              //从容器中获取所有的WebMvcConfigurers
             this.configurers.addWebMvcConfigurers(configurers);
          }
       }
       //....
   }
   ```

2. 我们来回顾一下WebMvcAutoConfiguration里面的方法WebMvcAutoConfigurationAdapter

   ```java
   //EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration
   @Import(EnableWebMvcConfiguration.class)
   public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware {}
   ```

3. webmvc的自动配置类WebMvcAutoConfiguration

   ```java
   //WebMvcConfigurationSupport这个类不存在才生效
   //但一加上@EnableWebMvc这个类就存在了
   @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
   public class WebMvcAutoConfiguration {}
   ```

## 总结

- @EnableWebMvc将WebMvcConfigurationSupport组件导入进来了；
- 而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！

在SpringBoot中会有非常多的XXXConfiguration 帮助我们进行扩展配置，只要看见了这个，我们就应该多留心注意。

写一个starter

- 写一个@Configuration，要带@ConditionalOnXXX
- 写两个类打到autofigure-jar包的org内
  - XXXAutoConfiguration
  - XXXProperties

# 配置项目环境及首页

## 环境搭建

### 导入静态资源

1. css，js等放在static文件夹下
2. html 放在 templates文件夹下

### 伪造数据库

1. 导入依赖lombok

   ```xml
   <dependency>
       <groupId>org.projectlombok</groupId>
       <artifactId>lombok</artifactId>
   </dependency>
   ```

2. 编写pojo实体类Department和Emplyee

   ```java
   //部门类
   @Data
   @AllArgsConstructor
   @NoArgsConstructor
   public class Department {
       private Integer id;
       private String departmentName;
   }
   //员工类
   @Data
   @AllArgsConstructor
   @NoArgsConstructor
   public class Employee {
       private Integer id;
       private String lastName;
       private String email;
       private Integer gender; //1 male, 0 female
       private Department department;
       private Date birth;
       
       public Employee(Integer id, String lastName, String email, Integer gender, Department department) {
           this.id = id;
           this.lastName = lastName;
           this.email = email;
           this.gender = gender;
           this.department = department;
           //默认的日期
           this.birth = new Date();
       }
   }
   ```

3. 编写dao层 DepartmentDao和EmplyeeDao操作数据

   ```java
   //部门Dao
   @Repository
   public class DepartmentDao {
       //模拟数据库中的数据
       private static Map<Integer, Department> departmentMap = null;
   
       static {
           departmentMap = new HashMap<Integer, Department>(); //创建一个部门表
   
           departmentMap.put(101, new Department(101, "教学部"));
           departmentMap.put(102, new Department(102, "市场部"));
           departmentMap.put(103, new Department(103, "教研部"));
           departmentMap.put(104, new Department(104, "运营部"));
           departmentMap.put(105, new Department(105, "后勤部"));
       }
   
       //获得所有部门信息
       public Collection<Department> getDepartments() {
           return departmentMap.values();
       }
   
       //通过ID得到部门
       public Department getDepartmentById(Integer id) {
           return departmentMap.get(id);
       }
   }
   
   @Repository
   public class EmployeeDao {
       //模拟数据库中的数据
       private static Map<Integer, Employee> employees = null;
   
       //员工有所属的部门
       @Autowired
       private DepartmentDao departmentDao;
   
       static {
           employees = new HashMap<Integer, Employee>();
   
           employees.put(201, new Employee(201, "张1", "02345678@qq.com", 0, new Department(101, "教学部")));
           employees.put(202, new Employee(202, "张2", "02345678@qq.com", 0, new Department(102, "市场部")));
           employees.put(203, new Employee(203, "张3", "02345678@qq.com", 0, new Department(103, "教研部")));
           employees.put(204, new Employee(204, "张4", "02345678@qq.com", 0, new Department(104, "运营部")));
           employees.put(205, new Employee(205, "张5", "02345678@qq.com", 0, new Department(105, "后勤部")));
       }
   
       //增加员工  主键自增
       private static Integer initId = 206;
   
       public void add(Employee employee) {
           if (employee.getId() == null) {
               employee.setId(initId++);
           }
           employee.setDepartment(departmentDao.getDepartmentById(employee.getDepartment().getId()));
           employees.put(employee.getId(), employee);
       }
   
       //查询全部员工信息
       public Collection<Employee> getEmployees() {
           return employees.values();
       }
   
       //通过ID查询员工
       public Employee getEmployeeById(Integer id) {
           return employees.get(id);
       }
   
       //删除员工
       public void delete(Integer id) {
           employees.remove(id);
       }
   }
   ```

## 首页实现

### 页面跳转

方式一：写一个controller实现！

```java
@Controller
public class IndexController {
    @RequestMapping({"/", "index.html"})
    public String index() {
        return "index";
    }
}
```

方式二：自己编写MVC的扩展配置

```java
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
    //添加视图映射
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("index");
        registry.addViewController("/index.html").setViewName("index");
    }
}
```

### 静态资源接管

解决了首页问题，我们还需要解决一个资源导入的问题。为了保证资源导入稳定，我们建议在所有资源导入时候使用thymeleaf模板规范：

1. html标签中导入命名空间的约束，让标签生效，方便提示。

   ```html
   <html xmlns:th="http://www.thymeleaf.org">
   ```

2. 使用` th:去替换原有的资源路径`，比如herf和src等

3. `URL使用@{}包围`，【注意】路径不需要包括static

   - 使用@{}包裹可以让静态资源一直有效，哪怕访问路径改变

   - 此时访问localhost：8080/sunm，静态资源依旧生效，因为@{}自动帮我们加上了/sunm路径

     ```properties
     #相当于修改了Tomcat里的项目路径
     server.servlet.context-path=/sunm
     ```

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240517171011447-1293423958.png" alt="image-20240517171016874" width="400" />

例如：index.html中

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <!-- Bootstrap core CSS -->
    <link th:href="@{/css/bootstrap.min.css}" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link th:href="@{/css/signin.css}" rel="stylesheet">
</head>
<body class="text-center">
    <form class="form-signin" action="dashboard.html">
        <img class="mb-4" th:src="@{/img/bootstrap-solid.svg}" alt="" width="72" height="72">
    </form>
</body>

</html>
```

## 页面国际化

### 简介

有的时候，我们的网站会去涉及中英文甚至多语言的切换，这时候我们就需要学习国际化了！

`i18n`（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称

- L10n：本地化

- k8s：kubernetes，是用8代替名字中间的8个字符“ubernete”而成的缩写。是一个开源的，用于管理[云平台]中多个主机上的容器化的应用。提供了应用部署，规划，更新，维护的一种机制。

先在IDEA中统一设置properties的编码问题！设置为UTF-8。

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240517171433064-1888575474.png" alt="image-20240517171438613" width="300" />

抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！

- 登录按钮
- 用户名
- 密码
- 等等

### 配置文件编写

1. 在Resource资源目录下新建一个i18n目录

2. 添加国际化配置文件login.properties和login_zh_CN.properties

   - 发现IDEA会自动把这两个配置文件合并为一个资源包login
   - 可以右键资源包直接新建配置文件，或者手动

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240517172525646-1226002889.png" alt="image-20240517172530886" width="500" />

3. 安装ResourceBundleEditor插件，点击资源包，可以对login进行可视化配置

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240517173049162-1388262478.png" alt="image-20240517173054863" width="400" />

4. 添加配置

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240517174136907-845912917.png" alt="image-20240517174142362" width="400" />

5. 配置效果

   ```properties
   #login.properties
       login.btn=登录
       login.password=密码
       login.remember=记住我
       login.tip=请登录
       login.username=用户名
   #login_zh_CN.properties
       login.btn=登录
       login.password=密码
       login.remember=记住我
       login.tip=请登录
       login.username=用户名
   #login_en_US.properties
       login.btn=Sign in
       login.password=Password
       login.remember=Remember me
       login.tip=Please sign in
       login.username=UserName
   ```

### 配置文件生效

探究我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：`MessageSourceAutoConfiguration`里面有一个方法messageSource，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件ResourceBundleMessageSource；

```java
@Bean
@ConfigurationProperties(prefix = "spring.messages")
public MessageSourceProperties messageSourceProperties() {
    return new MessageSourceProperties();
}

@Bean
public MessageSource messageSource(MessageSourceProperties properties) {
    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
    // 获取 properties 传递过来的值进行判断
    if (StringUtils.hasText(properties.getBasename())) {
        // 设置国际化文件的基础名（去掉语言国家代码的）
       messageSource.setBasenames(StringUtils
          .commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename())));
    }
    if (properties.getEncoding() != null) {
       messageSource.setDefaultEncoding(properties.getEncoding().name());
    }
    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
    Duration cacheDuration = properties.getCacheDuration();
    if (cacheDuration != null) {
       messageSource.setCacheMillis(cacheDuration.toMillis());
    }
    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
    return messageSource;
}
```

进入MessageSourceProperties查看默认属性

```java
public class MessageSourceProperties {
	//默认的国际化消息资源名为messages
    private String basename = "messages";

    private Charset encoding = StandardCharsets.UTF_8;
```

我们真实 的情况是放在了i18n目录下，所以我们要去application.properties配置这个messages的路径；

```properties
#我们的配置文件的真实位置
spring.messages.basename=i18n.login
```

### 配置页面国际化值

去页面获取国际化的值，`找到message取值操作为： #{...}`

我们去页面测试下：

```html
<h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}">Please sign in</h1>
<label class="sr-only" th:text="#{login.username}">Username</label>
<input type="text" class="form-control" th:placeholder="#{login.username}" required="" autofocus="">
<label class="sr-only" th:text="#{login.password}">Password</label>
<input type="password" class="form-control" th:placeholder="#{login.password}" required="">
<div class="checkbox mb-3">
    <label>
        <input type="checkbox" value="remember-me" th:text="#{login.remember}">
    </label>
</div>
<button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#{login.btn}">Sign in</button>
```

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240517180001361-1815156361.png" alt="image-20240517180006353" width="500" />

我们可以去启动项目，访问一下，发现已经自动识别为中文的了！

### 配置国际化解析

#### 需求

但是我们想要更好！可以根据按钮自动切换中文英文！观察切换按钮的代码

```html
<a class="btn btn-sm">中文</a>
<a class="btn btn-sm">English</a>
```

#### 源码分析

我们去我们webmvc自动配置文件，寻找一下！看到SpringBoot默认配置：

- 在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！

```java
@Override
@Bean
@ConditionalOnMissingBean(name = DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME)
public LocaleResolver localeResolver() {
    //如果获取区域信息解析器的方式为FIXED：固定方式
    if (this.webProperties.getLocaleResolver() == WebProperties.LocaleResolver.FIXED) {
        //就返回配置里默认的
       return new FixedLocaleResolver(this.webProperties.getLocale());
    }
    //否则，获取区域信息解析器的方式还有一种ACCEPT_HEADER:根据请求头方式
    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
    localeResolver.setDefaultLocale(this.webProperties.getLocale());
    return localeResolver;
}
```

AcceptHeaderLocaleResolver 这个类中有一个方法

```java
//实现了AbstractLocaleResolver类，这个类实现了接口LocaleResolver
//说明是一个区域信息解析器
public class AcceptHeaderLocaleResolver extends AbstractLocaleResolver {
    @Override
	public Locale resolveLocale(HttpServletRequest request) {
        //接收请求，获得默认的区域信息
		Locale defaultLocale = getDefaultLocale();
        //如果请求头的"Accept-Language"为空，就使用默认的
		if (defaultLocale != null && request.getHeader("Accept-Language") == null) {
			return defaultLocale;
		}
        //否则获取请求中的区域信息，并设置
		Locale requestLocale = request.getLocale();
		List<Locale> supportedLocales = getSupportedLocales();
		if (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) {
			return requestLocale;
		}
		Locale supportedLocale = findSupportedLocale(request, supportedLocales);
		if (supportedLocale != null) {
			return supportedLocale;
		}
		return (defaultLocale != null ? defaultLocale : requestLocale);
	}
}
```

那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！我们去自己写一个自己的LocaleResolver，实现LocaleResolver接口。可以在链接上携带区域信息！

#### 自定义实现

1. 修改一下前端页面的跳转连接：

   - 修改为跳转到/index.html
   - thymeleaf风格的参数为地址后加()
   - l是language的缩写

   ```html
   <a class="btn btn-sm" th:href="@{/index.html(l=zh_CN)}">中文</a>
   <a class="btn btn-sm" th:href="@{/index.html(l=en_US)}">English</a>
   ```

2. 去写一个处理的组件类，在config目录下新建MyLocaleResolver类实现接口LocaleResolver

   ```java
   public class MyLocaleResolver implements LocaleResolver {
       //解析请求
       @Override
       public Locale resolveLocale(HttpServletRequest request) {
           //获取请求中的语言参数
           String language = request.getParameter("l");
           //获取默认的区域信息
           Locale locale = Locale.getDefault();
   
           //如果请求中携带语言参数
           if (!StringUtils.isEmpty(language)) {
               //zh_CN  分隔参数
               String[] split = language.split("_");
               //语言_国家 创建自己的区域信息对象
               locale = new Locale(split[0], split[1]);
           }
           return locale;
       }
   
       @Override
       public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {
   
       }
   }
   ```

3. 配置这个组件到Spring，让我们的区域化信息能够生效

   在我们自己的MvcConofig下添加bean；

   ```java
   @Configuration
   public class MyMvcConfig implements WebMvcConfigurer {
       @Override
       public void addViewControllers(ViewControllerRegistry registry) {
           registry.addViewController("/").setViewName("index");
           registry.addViewController("/index.html").setViewName("index");
       }
   
       //自定义的国际化组件生效 方法名不能乱写，否则装配不上
       @Bean
       public LocaleResolver localeResolver() {
           return new MyLocaleResolver();
       }
   }
   ```

4. 观察效果，点击按钮可以切换语言

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240517185616421-1597182346.png" alt="image-20240517185621526" width="300" />

### 总结

页面国际化: `Message Expression #{}`

1. 配置i18n文件
2. 如果需要在项目中进行按钮自动切换，需要自定义一个组件`LocaleResolver`区域信息解析器
3. 记得要把自定义的组件，配置到Spring容器中，通过`@Bean`

# 登录+拦截器

## 禁用模板缓存

说明：页面存在缓存，所以我们需要禁用模板引擎的缓存

```properties
spring.thymeleaf.cache=false
```

模板引擎修改后，想要实时生效！页面修改完毕后，IDEA小技巧 ： Ctrl + F9 重新编译！即可生效！

## 登录

我们这里就先不连接数据库了，输入任意用户名都可以登录成功！

1. 我们把登录页面的表单提交地址写一个controller！

   ```html
   <form class="form-signin" th:action="@{/user/login}">
   ```

2. 去编写对应的controller 

   测试登录成功！

   ```java
   @Controller
   public class LoginController {
       @RequestMapping("/user/login")
       public String login(@RequestParam("username") String username, @RequestParam("password") String password, Model model) {
           //具体的业务
           if (!StringUtils.isEmpty(username) && "123".equals(password)) {
               return "dashboard";
           } else {
               model.addAttribute("msg", "用户名或者密码错误!");
               return "index";
           }
       }
   }
   ```

3. 登录失败的话，我们需要将后台信息输出到前台，可以在首页标题下面加上判断！

   ```html
   <!--如果，msg的值不为空，则显示消息-->
   <p style="color: red" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}"></p>
   ```

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240518135206793-1145206999.png" alt="image-20240518135213000" style="zoom:33%;" />

4. 我们再添加一个视图控制映射，在我们的自己的MyMvcConfig中：

   ```java
   //访问路径为/main.html时，去到dashboard中
   registry.addViewController("/main.html").setViewName("dashboard");
   ```

5. 登录成功后，由于是转发，链接不变，我们可以重定向到主页！将 Controller 的代码改为重定向；

   ```java
   @Controller
   public class LoginController {
       @RequestMapping("/user/login")
       public String login(@RequestParam("username") String username, @RequestParam("password") String password, Model model) {
           //具体的业务
           if (!StringUtils.isEmpty(username) && "123".equals(password)) {
               return "redirect:/main.html";
           } else {
               model.addAttribute("msg", "用户名或者密码错误!");
               return "index";
           }
       }
   }
   ```

   重启测试，重定向成功！后台主页正常显示！

## 登录拦截器

但是又发现新的问题，我们可以直接登录到后台主页，不用登录也可以实现！怎么处理这个问题呢？我们可以使用拦截器机制，实现登录检查！

1. 用户登录成功之后，把用户信息放入Session中

   ```java
   @Controller
   public class LoginController {
       @RequestMapping("/user/login")
       public String login(@RequestParam("username") String username, @RequestParam("password") String password, Model model, HttpSession session) {
           //具体的业务
           if (!StringUtils.isEmpty(username) && "123".equals(password)) {
               //登录成功,把用户名放入Session
               session.setAttribute("loginUser", username);
   
               return "redirect:/main.html";
           } else {
               model.addAttribute("msg", "用户名或者密码错误!");
               return "index";
           }
       }
   }
   ```

2. 我们先自定义一个拦截器：

   ```java
   public class LoginHandlerInterceptor implements HandlerInterceptor {
       @Override
       public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
           //登录成功之后，应该有用户的Session信息
           Object loginUser = request.getSession().getAttribute("loginUser");
           
           if (loginUser == null) {//信息为空，表示没有登录成功
               request.setAttribute("msg","没有权限，请先登录！");
               request.getRequestDispatcher("/index.html").forward(request, response);
               return false;
           }else {
               return true;
           }
       }
   }
   ```

3. 然后将拦截器注册到我们的SpringMVC配置类当中！

   ```java
   //添加拦截器
   @Override
   public void addInterceptors(InterceptorRegistry registry) {
       //拦截所有的请求，除了index.html , / ,user/login
       //以及排除所有的静态资源
       registry.addInterceptor(new LoginHandlerInterceptor())
               .addPathPatterns("/**")
               .excludePathPatterns("/index.html", "/", "/user/login", "/css/*", "/js/**", "/img/**");
   }
   ```

   否则访问main.html，静态资源会被拦截

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240518135319393-1268287.png" alt="image-20240518135325604" style="zoom:33%;" />

4. 然后我们登录测试拦截！完美！

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240518135134881-1266094139.png" alt="image-20240518135141017" style="zoom:33%;" />

登录进入main.html后，修改左上的名字，使其显示为登录名

- 修改dashboard.html
- 使用th:text标签，或者[[${session.loginUser}]]

```html
<a class="navbar-brand col-sm-3 col-md-2 mr-0" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#"
   th:text="${session.loginUser}"></a>
```



# CRUD

## RestFul 风格

要求 ： 我们需要使用 Restful风格实现我们的crud操作！

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240513212047789-1989385483.png" alt="image-20240513212051901" style="zoom: 50%;" />

看看一些具体的要求，就是我们小实验的架构；

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240513212056865-545205815.png" alt="image-20240513212100746" style="zoom:50%;" />

我们根据这些要求，来完成第一个功能，就是我们的员工列表功能！

## 查询员工列表

### 员工列表页面跳转

我们在主页点击Customers，就显示列表页面；我们去修改下

1. 修改主页dashboard.html和list.html的侧边栏

   1. Customers改为员工管理
   2. 跳转地址改为/emps

   ```html
   <li class="nav-item">
       <a class="nav-link" th:href="@{/emps}">
           <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round" class="feather feather-users">
               <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
               <circle cx="9" cy="7" r="4"></circle>
               <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
               <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
           </svg>
           员工管理
       </a>
   </li>
   ```

2. 新建emp文件夹，将list放在emp文件夹下

3. 编写处理请求的controller

   ```java
   @Controller
   public class EmployeeController {
       @Autowired
       EmployeeDao employeeDao;
   
       @RequestMapping("/emps")
       public String list(Model model) {
           Collection<Employee> employees = employeeDao.getEmployees();
           model.addAttribute("employees", employees);
           return "emp/list";
       }
   }
   ```

我们启动项目，测试一下看是否能够跳转，测试OK！但是发现了两个问题：

- 侧边栏和顶部都相同，但是点击员工管理后信息发生了改变，我们是不是应该将它抽取出来呢？
- 我们还没有将数据渲染进去！

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240518142425563-1249579818.png" alt="image-20240518142431332" style="zoom: 33%;" />

### 公共页面元素抽取

#### 原理-片段表达式

- `~{…}` 是表示标记片段并将其在模板中移动的简便方法。
- 这使我们能够复制它们，并将它们作为参数传递给其他模板，依此类推。

最常见的用途是使用`th:insert`或`th:replace`进行片段插入(在后面的部分中有更多关于这些的信息)：

```html
<div th:insert="~{commons :: main}">...</div>

<!--但是它们可以在任何地方使用，就像其他任何变量一样：-->
<div th:with="frag=~{footer :: #main/text()}">
  <p th:insert="${frag}">
</div>
```

#### 实现步骤

1. 抽取公共片段 th:fragment 定义模板名

   在dashboard.html中抽取侧边栏片段，即头部nav标签

   ```html
   <!--侧边栏-->
   <nav class="col-md-2 d-none d-md-block bg-light sidebar" th:fragment="sidebar">
   ```

   抽取顶部导航栏片段

   ```html
   <!--顶部导航栏-->
   <nav class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0" th:fragment="topbar">
   ```

2. 引入公共片段 th:insert 插入模板名

   在list.html中删除原有侧边栏，引入头部nav标签

   ```html
   <!--插入dashboard.html中的片段sidebar-->
   <div th:insert="~{dashboard.html::sidebar}"></div>
   ```

   引入顶部导航栏片段

   ```html
   <div th:insert="~{dashboard::topbar}"></div>
   ```

说明：

- 除了使用`insert插入`，还可以使用`replace替换`，或者`include包含`，三种方式会有一些小区别，可以见名知义；
- 我们使用replace替换，可以解决div多余的问题

#### 优化

为了重用更清晰，我们建立一个commons文件夹，专门存放公共页面：

1. 在commons文件中新建commons.html，存放公共片段

   ```html
   <!--顶部导航栏-->
   <nav class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0" th:fragment="topbar">
   <!--侧边栏-->
   <nav class="col-md-2 d-none d-md-block bg-light sidebar" th:fragment="sidebar">
   ```

2. 使用时去页面中引入一下

   ```html
   <div th:replace="~{commons/commons::topbar}"></div>
   <div th:replace="~{commons/commons::sidebar}"></div>
   ```

侧边栏激活高亮问题：

观察代码发现高亮取决于a标签中class的active属性

```html
<a class="nav-link active" th:herf="@{/index.html}">
```

1. 修改请求链接，添加参数

   ```html
   <!--传递参数 dashboard.html中-->
   <div th:replace="~{commons/commons::sidebar(active='main.html')}"></div>
   <!--传递参数 list.html中-->
   <div th:replace="~{commons/commons::sidebar(active='list.html')}"></div>
   ```

2. 我们在commons.html的a标签中加一个判断，使用class改变标签的值；

   ```html
   <!--首页-->
   <a th:class="${active=='main.html'?'nav-link active':'nav-link'}" th:href="@{/main.html}">
   <!--用户管理-->
   <a th:class="${active=='list.html'?'nav-link active':'nav-link'}" th:href="@{/emps}">
   ```

3. 我们刷新页面，去测试一下，OK，动态激活搞定！

### 员工信息页面展示

现在我们来遍历我们的员工信息！顺便美化一些页面，增加添加，修改，删除的按钮！

```html
<!--list.html-->
<div class="table-responsive">
    <table class="table table-striped table-sm">
        <thead>
        <tr>
            <th>id</th>
            <th>lastName</th>
            <th>email</th>
            <th>gender</th>
            <th>department</th>
            <th>birth</th>
            <th>操作</th>
        </tr>
        </thead>
        <tbody>
        <tr th:each="emp:${employees}">
            <td th:text="${emp.getId()}"></td>
            <td>[[${emp.getLastName()}]]</td>
            <td th:text="${emp.getEmail()}"></td>
            <td th:text="${emp.getGender()}==0?'女':'男'"></td>
            <td th:text="${emp.getDepartment().getDepartmentName()}"></td>
            <!--使用工具类格式化日期-->
            <td th:text="${#dates.format(emp.getBirth(),'yyyy-MM-dd HH:mm:ss')}"></td>
            <!--增加修改，删除的按钮！-->
            <td>
                <button class="btn btn-sm btn-primary">编辑</button>
                <button class="btn btn-sm btn-danger">删除</button>
            </td>
        </tr>
        </tbody>
    </table>
</div>
```

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240518153233179-18303744.png" alt="image-20240518153238536" style="zoom: 33%;" />

OK，显示全部员工OK！

## 添加员工

### 表单信息操作

1. 修改list.html，将添加员工信息改为超链接

   ```html
   <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">
       <h2>用户列表</h2>
       <a class="btn btn-sm btn-success" th:href="@{/toAdd}">添加用户</a>
   ```

2. 去EmployeeController编写对应的controller

   - 此时是经过a标签跳转过来的，方式为get

   ```java
   @GetMapping("/toAdd")
   public String toAddpage(Model model) {
       //查出所有部门的信息
       Collection<Department> departments = departmentDao.getDepartments();
       model.addAttribute("departments", departments);
   
       return "emp/add";
   }
   ```

3. 添加前端页面add.html；复制list页面，修改main即可

   bootstrap官网文档 ： https://v4.bootcss.com/docs/4.0/components/forms/

   ```html
   <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">
       <form th:action="@{/toAdd}" method="post">
           <div class="form-group">
               <label>LastName</label>
               <input type="text" name="lastName" class="form-control" placeholder="sun">
           </div>
           <div class="form-group">
               <label>Email</label>
               <input name="email" type="email" class="form-control"
                      placeholder="123456789@qq.com">
           </div>
           <div class="form-group">
               <label>Gender</label><br/>
               <div class="form-check form-check-inline">
                   <input class="form-check-input" type="radio" name="gender"
                          value="1">
                   <label class="form-check-label">男</label>
               </div>
               <div class="form-check form-check-inline">
                   <input class="form-check-input" type="radio" name="gender"
                          value="1">
                   <label class="form-check-label">女</label>
               </div>
           </div>
           <div class="form-group">
               <label>department</label>
               <!--现在Controller接受的是一个Employee，所以我们需要提交的是其中的一个属性-->
               <select name="department.id" class="form-control">
                   <option th:each="dept:${departments}" th:text="${dept.getDepartmentName()}"
                           th:value="${dept.getId()}"></option>
               </select>
           </div>
           <div class="form-group">
               <label>Birth</label>
               <input name="birth" type="text" class="form-control" placeholder="2024/5/18">
           </div>
           <button type="submit" class="btn btn-primary">添加用户</button>
       </form>
   </main>
   ```

### 具体添加功能

1. 我们要接收前端传过来的属性，将它封装成为对象！首先需要将前端页面空间的name属性编写完毕！【操作】

2. 修改add页面form表单属性

   1. 修改跳转地址为/toAdd

   2. 修改提交方式为post


   ```html
   <form th:action="@{/toAdd}" method="post">
   ```

3. 编写controller；

   ```java
   @PostMapping("/toAdd")
   public String Addpage(Employee employee) {
       //添加的操作
       employeeDao.add(employee);
       //编写controller接收调试打印【操作】
       System.out.println("emplyee---" + employee);
   
       return "redirect:/emps";
   }
   ```

### 优化

那我们将时间换一个格式提交，提交发现页面出现了400错误！这里面存在一个日期格式化的问题；

-  我们第一次使用的 / 正常提交成功了，
- 后面使用 - 就错误了

SpringMVC会将页面提交的值转换为指定的类型，默认日期是按照 / 的方式提交并转换为一个date对象。我们去看webmvc的自动配置文件，找到一个format日期格式化的方法，我们可以看一下调用了 getDateFormat 方法；默认为`'dd/ MM/ yyyy'`

这个在配置类中，所以我们可以自定义的去修改这个时间格式化问题，我们在我们的配置文件中修改一下

```properties
spring.mvc.format.date=yyyy-MM-dd
```

这样的话，我们现在就支持 - 的格式了，但是又不支持 / 了 

## 修改员工信息

逻辑分析：我们要实现员工修改功能，需要实现两步；

1. 点击修改按钮，去到编辑页面，我们可以直接使用添加员工的页面实现
2. 显示原数据，修改完毕后跳回列表页面！

### 表单信息操作

1. 首先修改跳转链接的位置；

   ```html
   <a class="btn btn-sm btn-primary" th:href="@{/emp/}+${emp.id}">编辑</a>
   ```

2. 编写对应的controller

   ```java
   @GetMapping("/emp/{id}")
   public String toUpdate(@PathVariable("id") Integer id, Model model) {
       //查出原来的数据
       Employee employeeById = employeeDao.getEmployeeById(id);
       model.addAttribute("employee", employeeById);
       //查出所有部门的信息
       Collection<Department> departments = departmentDao.getDepartments();
       model.addAttribute("departments", departments);
   
       return "emp/update";
   }
   ```

3. 我们需要在这里将add页面复制一份，改为update页面；需要修改页面，将我们后台查询数据回显

   ```html
   <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">
       <form th:action="@{/emp}" method="post">
           <div class="form-group">
               <label>LastName</label>
               <input type="text" name="lastName" class="form-control" placeholder="sun"
                      th:value="${employee.getLastName()}">
           </div>
           <div class="form-group">
               <label>Email</label>
               <input name="email" type="email" class="form-control"
                      placeholder="123456789@qq.com" th:value="${employee.getEmail()}">
           </div>
           <div class="form-group">
               <label>Gender</label><br/>
               <div class="form-check form-check-inline">
                   <input th:checked="${employee.getGender()==1}" class="form-check-input" type="radio"
                          name="gender"
                          value="1">
                   <label class="form-check-label">男</label>
               </div>
               <div class="form-check form-check-inline">
                   <input th:checked="${employee.getGender()==0}" class="form-check-input" type="radio"
                          name="gender"
                          value="0">
                   <label class="form-check-label">女</label>
               </div>
           </div>
           <div class="form-group">
               <label>department</label>
               <select name="department.id" class="form-control">
                   <option th:selected="${dept.getId()==employee.getDepartment().getId()}"
                           th:each="dept:${departments}" th:text="${dept.getDepartmentName()}"
                           th:value="${dept.getId()}"></option>
               </select>
           </div>
           <div class="form-group">
               <label>Birth</label>
               <input th:value="${employee.getBirth()}" name="birth" type="text" class="form-control"
                      placeholder="2024/5/18">
           </div>
           <button type="submit" class="btn btn-primary">修改用户</button>
       </form>
   </main>
   ```

   测试OK！发现我们的日期显示不完美，可以使用日期工具，进行日期的格式化！

   ```html
   <input th:value="${#dates.format(employee.getBirth(),'yyyy-MM-dd HH:mm')}" name="birth" type="text" class="form-control"
          placeholder="2024/5/18">
   ```

   数据回显OK，我们继续完成数据修改问题！

### 具体修改功能

1. 修改表单提交的地址：

   ```html
   <form th:action="@{/emp/update}" method="post">
   ```

2. 编写对应的controller

   ```java
   @PostMapping("/emp/update")
   public String updatepage(Employee employee) {
       employeeDao.add(employee);
   
       return "redirect:/emps";
   }
   ```

### 问题

发现修改后会一直新增用户；我们在前端加一个隐藏域，提交id；

```html
<input type="hidden" name="id" th:value="${employee.getId()}">
```

重启，修改信息测试OK！

## 删除员工

1. list页面，编写提交地址

   ```html
   <a class="btn btn-sm btn-danger" th:href="@{/delemp/}+${emp.id}">删除</a>
   ```

2. 编写Controller

   ```java
   @GetMapping("/delemp/{id}")
   public String delEmp(@PathVariable("id") Integer id) {
       employeeDao.delete(id);
   
       return "redirect:/emps";
   }
   ```

测试OK！

# 404及注销

## 404

SpringBoot会帮我们自动使用了！

- 我们只需要在templates模板目录下添加一个error文件夹，
- 文件夹中存放我们相应的错误页面；比如404.html 或者 4xx.html 等等，

## 注销

1. 注销请求

   ```html
   <a class="nav-link" th:href="@{/user/logout}">注销</a>
   ```

2. 对应的controller

   ```java
   @GetMapping("/user/logout")
   public String logout(HttpSession session) {
       session.removeAttribute("loginUser");
       return "redirect:/index.html";
   }
   ```

## 定制错误数据

### SpringBoot 默认的错误处理机制

1. 浏览器访问的默认的错误处理效果：

   ![image-20240518184307060](https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240518184301065-77904632.png)

2. 如果是其他客户端，默认响应一个 json 数据；

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240518184314873-1134854164.png" alt="image-20240518184321044" style="zoom:33%;" />

### 错误处理原理分析

我们看到自动配置类：ErrorMvcAutoConfiguration 错误处理的自动配置类；这里面注入了几个很重要的 bean；

1. DefaultErrorAttributes
2. BasicErrorController
3. ErrorPageCustomizer
4. DefaultErrorViewResolver

错误处理步骤：

1. 进入ErrorMvcAutoConfiguration ，发现一旦系统出现了 4xx 或者 5xx 之类的错误，ErrorPageCustomizer 就会生效（定制错误的响应规则）

   ```java
   @Bean
   public ErrorPageCustomizer errorPageCustomizer(DispatcherServletPath dispatcherServletPath) {
       return new ErrorPageCustomizer(this.serverProperties, dispatcherServletPath);
   }
   ```

2. 进入ErrorPageCustomizer ，发现一个方法 registerErrorPages 注册错误页面

   ```java
   @Override
   public void registerErrorPages(ErrorPageRegistry errorPageRegistry) {
       ErrorPage errorPage = new ErrorPage(
             this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath()));
       errorPageRegistry.addErrorPages(errorPage);
   }
   
   //进入this.properties.getError().getPath()
   public String getPath() {
   	return this.path;
   } 
   // this.path;
   @Value("${error.path:/error}")
   private String path = "/error";
   ```

3. 系统一旦出现错误之后就会来到 /error 请求进行处理；这个请求会被 BasicErrorController 处理：

   ```java
   @Controller
   @RequestMapping("${server.error.path:${error.path:/error}}")
   public class BasicErrorController extends AbstractErrorController {
   ```

这个类有两个方法：

```java
// 产生html类型的数据，浏览器发送的请求会被这个方法处理
@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)
public ModelAndView errorHtml(HttpServletRequest request,HttpServletResponse response) {
    HttpStatus status = getStatus(request);
    Map<String, Object> model = Collections.unmodifiableMap(getErrorAttributes(request,isIncludeStackTrace(request, MediaType.TEXT_HTML)));
    response.setStatus(status.value());
    // 去哪个页面拿错误页面呢？resolveErrorView 方法
    ModelAndView modelAndView = resolveErrorView(request, response, status, model);
    return (modelAndView != null) ? modelAndView : new ModelAndView("error",model);
} 

// 返回 json 类型的数据，其他的客户端请求会被这个方法处理
@RequestMapping
public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {
    HttpStatus status = getStatus(request);
    if (status == HttpStatus.NO_CONTENT) {
        return new ResponseEntity<>(status);
    }
    Map<String, Object> body = getErrorAttributes(request,isIncludeStackTrace(request, MediaType.ALL));
    return new ResponseEntity<>(body, status);
}
```

我们来看看resolveErrorView 这个方法：

```java
protected ModelAndView resolveErrorView(HttpServletRequest request,HttpServletResponse response, HttpStatus status,Map<String, Object> model) {
    // 拿到所有的 errorViewResolvers 错误视图解析器
    for (ErrorViewResolver resolver : this.errorViewResolvers) {
        ModelAndView modelAndView = resolver.resolveErrorView(request,status, model);
        if (modelAndView != null) {
            return modelAndView;
        }
    }
    return null;
}
```

我们在之前看到有这样一个bean DefaultErrorViewResolver 默认的错误视图解析器 

```java
public class DefaultErrorViewResolver implements ErrorViewResolver, Ordered {
    private static final Map<Series, String> SERIES_VIEWS;

    static {
        Map<Series, String> views = new EnumMap<>(Series.class);
        views.put(Series.CLIENT_ERROR, "4xx"); // 客户端错误
        views.put(Series.SERVER_ERROR, "5xx"); // 服务端错误
        SERIES_VIEWS = Collections.unmodifiableMap(views);
    }
    // .....

    @Override // HttpStatus 状态码
    public ModelAndView resolveErrorView(HttpServletRequest request,HttpStatus status, Map<String, Object> model) {
        ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);
        if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) {
            // 通过状态码解析视图
            modelAndView = resolve(SERIES_VIEWS.get(status.series()),model);
        }
        return modelAndView;
    }

    // 去 error 路径下解析视图
    private ModelAndView resolve(String viewName, Map<String, Object> model) {
        // 比如 error/404 error/500
        String errorViewName = "error/" + viewName;
        TemplateAvailabilityProvider provider =this.templateAvailabilityProviders.getProvider(errorViewName,this.applicationContext);
        if (provider != null) {
            return new ModelAndView(errorViewName, model);
        }
        return resolveResource(errorViewName, model);
    }
}
```

所以说：定制错误页面，我们可以建立一个 error 目录，然后放入对应的错误码html文件！比如：404.html 500.html 4xx.html 5xx.html

这些页面的信息数据在哪里呢？我们找到 DefaultErrorAttributes 这个bean对象；里面有ErrorAttributeOptions对象，就是添加不同的信息；

```java
public static enum Include {
    EXCEPTION,
    STACK_TRACE,
    MESSAGE,
    BINDING_ERRORS;

    private Include() {
    }
}
```
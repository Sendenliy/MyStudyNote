# OOP 七大原则

面向对象设计五原则：单一职责原则、开放-封闭原则、Liskov替换原则、接口隔离原则、依赖倒置原则；

- **开闭原则**:对扩展开放，对修改关闭
- **里氏替换原则**:继承必须确保超类所拥有的性质在子类中仍然成立。子类应该能替换父类，出现在父类能出现的任何地方。
- **依赖倒置原则**:要面向接口编程，不要面向实现编程。是指应用系统中的高层模块不应依赖于底层模块，两者都应该依赖于抽象；抽象不应该依赖于细节实现，实现细节应该依赖于抽象。
- **单一职责原则**:控制类的粒度大小、将对象解耦、提高其内聚性。一个对象只负责一件事。
- **接口隔离原则**:要为各个类建立它们需要的专用接口

- **迪米特法则**: 只与你的直接朋友交谈,不跟"陌生人"说话
- **合成复用原则: **尽量先使用组合或者聚合等关联关系实现,其次才考虑使用继承关系来实现

## 单一职责原则

一个对象只负责一件事。

- 要求系统中的一个具体设计元素(类)只完成某一类功能(职责)
- 尽可能避免出现一个“复合”功能的类——在同一个类中完成多个不同的功能

[![image-20231231160603249](https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240313123153648-798138841.png)](https://img2023.cnblogs.com/blog/3406637/202403/3406637-20240313123153648-798138841.png)

开放-封闭原则OCP：类可以扩展，但不可以修改。

实现面向对象可复用设计的基础，其他的设计原则则是实现这一原则的手段和工具。

- 软件实体类(类、模块、函数等)应该是可以扩展、但是不可修改的。
- 基本思想：不用修改原有类就能扩展一个类的行为。

## **Liskov** 替换原则LSP

子类应该能替换父类，出现在父类能出现的任何地方。

- 若对每个类型S 的对象o1，都存在一个类型T 的对象o2，使得在所有针对T 编写的程序P 中，用o1 替换o2 后，程序P 的行为功能不变，则S 是T 的子类型。

- 核心思想：子类型必须能够替换它们的基类型，该原则能够知道设计人员正确地进行类的继承与派生

- 基本要求：派生类要与其子类自相容，也就是基本类中的抽象方法都要在子类中声明，并且一个具体的实现类应当只实现其接口和抽象类中声明的方法

- 如何遵守Liskov替换原则

  主要针对继承的设计原则；客户端只需要依赖于基类或其接口

- Liskov替换原则能够指导软件设计人员正确地进行继承关系的设计

  继承是面向对象编程技术中一个很重要的手段，也是类之间很常见的关系之一；如果类之间的继承关系满足Liskov替换原则，则能够实现运行期绑定（动态多态）-实现接口或者继承某个抽象类来实现

## 接口隔离原则ISP

其实就是接口的单一职责原则。

- 采用多个与特定客户类有关的接口比采用一个通用的涵盖多个业务方法的接口更好。

  主要思想：一个类对另外一个类的依赖关系应该是建立在最小接口上的；使用多个专用专门的接口比使用单一的复合总接口要优越

- 对接口的污染

  设计人员为了节省接口数目，而经常将一些功能相近或功能相关的接口合并成一个总的接口；臃肿的大接口

- 如何遵守接口隔离原则

  设计接口的基本思路（将完成一类相关功能的各个方法放在同一个接口中，形成高内聚的职责）

## 依赖倒置原则

- 面向过程——自顶向下，逐步求精

- 依赖倒置原则：是指应用系统中的高层模块不应依赖于底层模块，两者都应该依赖于抽象；抽象不应该依赖于细节实现，实现细节应该依赖于抽象。

- 消除两个模块之间的依赖——接口（上层调用接口中方法，下层实现接口）

- 如何满足依赖倒置原则--面向接口编程(结合使用接口和抽象类)

- 优点

  通过接口隔离了“服务的提供者”和“服务的请求者”；复用、灵活性、易维护

# 了解设计模式

## 什么是设计模式

- 设计模式 是前辈们对代码开发经验的总结, 是解决特定问题的一系列套路, 他不是语法规定, 而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案

- 1995年,GoF合作出版了《设计模式:可复用面向对象软件的基础》一书,共收录了23种设计模式,从此树立了软件设计模式领域的里程碑,人称GoF设计模式
- 广义上讲，设计模式是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述；狭义上讲，设计模式就是对特定问题的描述或解决方案，往往直接对应一段程序代码。

## 设计模式的意义

- 设计模式的本质：是面向对象设计原则的实际运用。是对类的封装性, 继承性和多态性以及类的关联关系和组合关系的充分理解
-  优化的设计经验，极高的复用性，丰富的表达能力，极低的耦合度

## 设计模式的优点

- 可以提高程序员的思维能力, 编程能力和设计能力
- 使程序设计更加标准化, 代码编制更加工程化, 使软件开发效率大大提高, 从而缩短软件的开发周期
- 使设计的代码可重用性高, 可读性强, 可靠性高, 灵活性好, 可维护性强

## 设计模式的基本要素

- 模式名称
- 问题
- 解决方案
- 效果

# GoF 23

Gof23：一种思维, 一种态度, 一种进步

`创建型模式`：描述怎么创建一个对象。创建和使用分离

1. 单例模式：一个类只有一个实例，全局唯一。构造器私有
2. 工厂模式：简单工厂模式(常用)和工厂方法模式。生产一个具体的产品
3. 抽象工厂模式：生成产品族
4. 建造者模式：创建和对象分离
5. 原型模式：new- - >用原型克隆。适合原型复杂的情况，new不方便

`结构型模式`：描述如何将类和对象按照某种类型，组成更大的结构。从程序的结构上实现松耦合，从而扩大整体的类结构，用来解决更大的问题。

1. 适配器模式
2. 桥接模式
3. 装饰模式
4. 组合模式
5. 外观模式
6. 享元模式
7. 代理模式

`行为型模式`：描述类和对象如何相互协作，完成单个类无法完成的任务

1. 模板方法模式
2. 命令模式
3. 迭代器模式
4. 观察者模式
5. 中介者模式
6. 备忘录模式
7. 解释器模式
8. 状态模式
9. 策略模式
10. 职责链模式
11. 访问者模式

# 单例模式

`构造器私有`

核心作用：`保证一个类只有一个实例，并且提供一个访问该实例的全局访问点`，不用new对象了

常见场景：

- windows的任务管理器
- windows的回收站
- 项目中，读取配置文件的类，一般只有一个对象
- 网站的计数器一般也会采用单例模式
- Servlet编程中，每个Servlet也是单例的
- 在Spring中，每个Bean默认就是单例的

## 饿汉式

```java
//饿汉式 类加载时，创建对象：
public class Hungry {
    //可能会浪费内存空间
    private byte[] data1 = new byte[1024];
    private byte[] data2 = new byte[1024];
    private byte[] data3 = new byte[1024];

    //构造器私有
    private Hungry() {

    }
	//即使静态变量，如果不加 final 修饰，在类加载第一步赋初始值的时候，也会给类型的默认值
    //如果加上了 final 修饰词，那么初始值就是设定的值
    private final static Hungry HUNGRY = new Hungry();
	//公有方法返回对象
    public static Hungry getInstance() {
        return HUNGRY;
    }
}
```

## 懒汉式

存在多线程并发模式，后面的DCL懒汉式解决并发问题

```java
//懒汉式  用的时候再加载对象
public class LazyMan {

    private LazyMan() {
        System.out.println(Thread.currentThread().getName() + " : OK");
        /*
        Thread-4 : OK
        Thread-5 : OK
        Thread-2 : OK
        Thread-3 : OK
        Thread-1 : OK
        Thread-0 : OK
         */
    }

    private  static LazyMan lazyMan;

    //单线程下单例OK  多线程不行
    public static LazyMan getInstance() {
         //判断对象是否为空，如果为空则创建对象然后返回
        if (lazyMan == null) {
            lazyMan = new LazyMan();      
        }
        return lazyMan; 
    }
}
```

## DCL懒汉式

注意：

- `synchronized` 解决并发问题
- 但是因为lazyMan = new LazyMan();不是原子性操作(可以分割，见代码注释)，可能发生指令重排序的问题，通过`volatile`来解决

```java
//懒汉式  用的时候再加载对象
public class LazyMan {

    private LazyMan() {
        System.out.println(Thread.currentThread().getName() + " : OK");
        //Thread-0 : OK
    }
	//关键字 volatile 避免指令重排
    private volatile static LazyMan lazyMan;

    //单线程下单例OK
    //多线程   双重检测锁模式的懒汉式单例 DCL懒汉式
    public static LazyMan getInstance() {
        if (lazyMan == null) {//第一重检测
            synchronized (LazyMan.class) {//锁住当前对象
                if (lazyMan == null) {//第二重检测
                    lazyMan = new LazyMan();    //不是原子性操作
                    /*
                    1.分配内存空间
                    2.执行构造方法 初始化对象
                    3.把这个对象指向这个空间

                    123 - -> 132 指令重排
                    
                    给lazyman加上volatile确保原子性
                     */
                }
            }
        }
        return lazyMan; //此时lazyman还没有完成构造
    }

    //多线程并发
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                LazyMan.getInstance();
            }).start();
        }
    }
}
```

Java 语言提供了 `volatile和 synchronized` 两个关键字来保证线程之间操作的有序性

- volatile 是因为其本身包含“禁止指令重排序”的语义
- synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。

原子性就是指该操作是不可再分的。

- 不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。
- 简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。比如 a = 1；

## 静态内部类

```java
//静态内部类实现
public class Holder {
    private Holder() {
    }
    //调用静态内部类
    public static Holder getInstance() {
        return InnerClass.HOLDER;
    }

    public static class InnerClass {
        //在内部类中创建对象
        private static final Holder HOLDER = new Holder();
    }
}
```

## 反射破坏单例

- 针对DCL懒汉式：一个实例用构造器获取，一个实例用反射获取。会报错，是有效的

```java
//DCL懒汉式
public class LazyMan {

    private LazyMan() {
        /*
        在构造器中加锁，确保同一时间构造器只能执行一次
        如果对象已经创建，则抛出异常
        */
        synchronized (LazyMan.class) {
            if (lazyMan != null) {
                throw new RuntimeException("不要试图使用反射破坏单例！");
            }
        }
    }

    private volatile static LazyMan lazyMan;

    public static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();
                }
            }
        }
        return lazyMan;
    }

    //反射
    public static void main(String[] args) throws Exception {
        //LazyMan instance = LazyMan.getInstance();

        //Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器
        Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);

        //不能直接操作私有属性 需要关闭程序的安全检测 设置setAccessible
        declaredConstructor.setAccessible(true);
        LazyMan instance2 = declaredConstructor.newInstance();
        LazyMan instance3 = declaredConstructor.newInstance();

        //System.out.println(instance == instance2);  //false
        System.out.println(instance2 == instance3);  //false
    }
}
```

- 两个实例都用反射获取。不报错，还是无效

```java
//DCL懒汉式
public class LazyMan {
    //红绿灯 解决通过反射创建对象（反编译可以破解该方法）
    private static boolean flag = false;

    private LazyMan() {
        if (flag == false) {
            flag = true;
        } else {
            throw new RuntimeException("不要试图使用反射破坏单例！");
        }
    }

    private volatile static LazyMan lazyMan;

    public static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();
                }
            }
        }
        return lazyMan;
    }

    //反射
    public static void main(String[] args) throws Exception {
        //LazyMan instance = LazyMan.getInstance();

        //通过反射找到这个红绿灯标志，依然可破坏 DCL
        Field flag = LazyMan.class.getDeclaredField("flag");
        flag.setAccessible(true);

        //Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器
        Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);

        //不能直接操作私有属性 需要关闭程序的安全检测 设置setAccessible
        declaredConstructor.setAccessible(true);
        LazyMan instance2 = declaredConstructor.newInstance();

        flag.set(instance2, false);

        LazyMan instance3 = declaredConstructor.newInstance();

        //System.out.println(instance == instance2);  //false
        System.out.println(instance2 == instance3);  //false
    }
}
```

## 枚举类型

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240510183455046-1352136815.png" alt="image-20240510183457796" style="zoom:67%;" />

### 反射破解枚举不成功

1. 普通的反编译会欺骗开发者，说enum枚举是无参构造

   ```java
   //IDEA的反编译结果
   public enum EnumSingle {
       INSTANCE;
   
       private EnumSingle() {
       }
   
       public EnumSingle getInstance() {
           return INSTANCE;
       }
   }
   ```

2. 实际enum为有参构造（见后面）；

3. 通过反射破解枚举会发现抛出异常

```java
//enum 本身也是一个Class类
public enum EnumSingle {
    INSTANCE;

    public EnumSingle getInstance() {
        return INSTANCE;
    }
}

class Test {
    public static void main(String[] args) throws Exception {
        EnumSingle e = EnumSingle.INSTANCE;
        EnumSingle e1 = EnumSingle.INSTANCE;

        Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(null);
        declaredConstructor.setAccessible(true);
        EnumSingle e2 = declaredConstructor.newInstance();

        System.out.println(e == e1);    //true
        System.out.println(e == e2);
        //NoSuchMethodException: com.sun.single.EnumSingle.<init>()该枚举类没有空参构造器
    }
}
```

### 寻找真正的反编译枚举

1. 通过idea和jdk自带的反编译枚举如下

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240510175914142-1252455874.png" alt="image-20240510175917185" style="zoom:50%;" />

2. 通过jad反编译枚举的代码：发现了有参构造

   - 反编译命令：jad -sjava EnumSingle.class

   ```java
   // Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
   // Jad home page: http://www.kpdus.com/jad.html
   // Decompiler options: packimports(3) 
   // Source File Name:   EnumSingle.java
   
   package com.sun.single;
   
   //继承枚举类
   public final class EnumSingle extends Enum
   {
   
       public static EnumSingle[] values()
       {
           return (EnumSingle[])$VALUES.clone();
       }
   
       public static EnumSingle valueOf(String name)
       {
           return (EnumSingle)Enum.valueOf(com/sun/single/EnumSingle, name);
       }
   	//私有的有参构造器
       private EnumSingle(String s, int i)
       {
           super(s, i);
       }
   
       public EnumSingle getInstance()
       {
           return INSTANCE;
       }
   
       public static final EnumSingle INSTANCE;
       private static final EnumSingle $VALUES[];
   
       static 
       {
           INSTANCE = new EnumSingle("INSTANCE", 0);
           $VALUES = (new EnumSingle[] {
               INSTANCE
           });
       }
   }
   ```

重新设计反射：修改构造器的参数，发现反射不能破坏枚举的单例

```java
//enum 本身也是一个Class类
public enum EnumSingle {
    INSTANCE;

    public EnumSingle getInstance() {
        return INSTANCE;
    }
}

class Test {
    public static void main(String[] args) throws Exception {
        EnumSingle e = EnumSingle.INSTANCE;
        EnumSingle e1 = EnumSingle.INSTANCE;

        //Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor();
        Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, int.class);
        //.IllegalArgumentException: Cannot reflectively create enum objects 反射不能破坏枚举的单例
        
        declaredConstructor.setAccessible(true);
        EnumSingle e2 = declaredConstructor.newInstance();

    }
}
```

# 工厂模式

|   作用   |          实现创建者与调用者的分离          |
| :------: | :----------------------------------------: |
| 详细分类 | 简单工厂模式 、工厂方法模式 、抽象工厂模式 |
| 涉及原则 |   开闭原则 、 依赖倒转原则 、迪米特法则    |

- 开闭原则: 一个软件的实体应当对扩展开放, 对修改关闭
- 依赖倒转原则: 要针对接口编程, 不要针对实现编程
- 迪米特法则: 只与你直接的朋友通信, 而避免和陌生人通信

1. 核心本质

   - 实例化对象不使用new，用工厂方法代替
   - 将选择实现类，创建对象统一管理和控制。从而`将调用者跟我们的实现类解耦`

2. 三种模式:

   1. 简单工厂模式 (静态工厂模式)

     - 用来生产`同一等级结构`中的任意产品(对于增加新的产品，需要覆盖已有代码)
     - 虽然某种程度上不符合设计原则，但实际使用最多
     - 根据实际业务：简单工厂模式（结构复杂度、代码复杂度、编程复杂度、管理复杂度都更高效）

   2. 工厂方法模式

     - 用来生产`同一等级结构`中的固定产品(支持增加任意产品)
     - 满足开闭原则，不修改已有类的前提下，通过增加新的工厂实现扩展
     - 根据设计原则：工厂方法模式

   3. 抽象工厂模式

     - 围绕一个超级工厂创建其他工厂, 该超级工厂又称为其他工厂的工厂
     - 不可以增加新产品，可以增加产品族

应用场景	

- JDK的Calendar中getInstance方法
- JDBC中Connection对象的获取
- Spring中IOC容器创建管理bean对象
- 反射中Class对象的newInstance方法

## 简单(静态)工厂模式

- 弊端：新增产品类时，需要修改代码；不满足开闭原则

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240510191120585-2087905914.png" alt="image-20240510191123188" style="zoom: 33%;" />

产品接口及实现类

```java
public interface Car {
    void name();
}

public class WuLing implements Car {
    @Override
    public void name() {
        System.out.println("我是五菱宏光");
    }
}

public class Tesla implements Car {
    @Override
    public void name() {
        System.out.println("我是Tesla");
    }
}
```

客户类自己创建

```java
public class Consumer {
    public static void main(String[] args) {
        //接口 所有的实现类
        Car car = new WuLing();
        Car car2 = new Tesla();

        car.name(); //我是五菱宏光
        car2.name(); //我是Tesla
    }
}
```

工厂类

```java
public class CarFactory {
    //新增产品类时，需要修改代码；不满足开闭原则
    //方法一：
    public static Car getCar(String car) {
        if (car.equals("五菱")) {
            return new WuLing();
        } else if (car.equals("特斯拉")) {
            return new Tesla();
        } else {
            return null;
        }
    }
    //方法二：
    public static Car getWuling() {
        return new WuLing();
    }
    public static Car getTesla() {
        return new Tesla();
    }
}
```

客户使用工厂创建

```java
public class Consumer {
    public static void main(String[] args) {
        //接口 所有的实现类
        //Car car = new WuLing();
        //Car car2 = new Tesla();

        Car car = CarFactory.getCar("五菱");
        Car car2 = CarFactory.getCar("特斯拉");

        car.name(); //我是五菱宏光
        car2.name(); //我是Tesla
    }
}
```

## 工厂方法模式

- 优点：新增产品类时，不需要修改代码；满足开闭原则
- 弊端：每次新增产品类时，都需要增加对应的工厂实现类

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240510193137959-1598130853.png" alt="image-20240510193140711" style="zoom: 33%;" />

产品接口及实现类

```java
public interface Car {
    void name();
}

public class WuLing implements Car {
    @Override
    public void name() {
        System.out.println("我是五菱宏光");
    }
}

public class Tesla implements Car {
    @Override
    public void name() {
        System.out.println("我是Tesla");
    }
}
```

工厂接口及工厂实现类

```java
//工厂方法模式
public interface CarFactory {
    Car getCar();
}
public class WuLingFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new WuLing();
    }
}
public class TeslaFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new Tesla();
    }
}
```

客户调用工厂实现类

```java
public class Consumer {
    public static void main(String[] args) {
        Car car = new WuLingFactory().getCar();
        Car car2 = new TeslaFactory().getCar();

        car.name();//我是五菱宏光
        car2.name();//我是Tesla
    }
}
```

# 抽象工厂模式

新增一个工厂实现类时需要修改幅度大

## 简介

1. 定义︰抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类
2. 适用场景:
   - 客户端（应用层)：`不依赖于产品类实例如何被创建、实现`等细节
   - 强调一系列相关的产品对象（属于`同一产品族`），一起使用创建对象需要大量的重复代码
   - 提供一个产品类的库，所有的产品以`同样的接`口出现，从而使得客户端不依赖于具体的实现
3. 优点:
   - 具体产品在应用层的代码隔离，无需关心创建的细节
   - 将一个系列的产品统一到一起创建
   - 适合比较稳定的工厂
4. 缺点:
       
   - 规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难;
   - 增加了系统的抽象性和理解难度

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240510194223514-882406531.png" alt="image-20240510194226110" style="zoom: 50%;" />

## 代码实现

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240510203508655-1384893289.png" alt="image-20240510203511064" style="zoom:50%;" />

不同产品等级接口

```java
//手机产品接口
public interface IphoneProduct {
    void start();

    void shutdown();

    void callup();

    void sendSMS();
}
//路由器产品接口
public interface IRouterProduct {
    void start();

    void shutdown();

    void openwifi();

    void setting();
}
```

同一产品等级接口的不同产品族实现类

```java
public class HuaweiPhone implements IphoneProduct {
    @Override
    public void start() {
        System.out.println("开启华为手机");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭华为手机");
    }

    @Override
    public void callup() {
        System.out.println("华为手机打电话");
    }

    @Override
    public void sendSMS() {
        System.out.println("华为手机发信息");
    }
}
public class XiaomiPhone implements IphoneProduct {
    @Override
    public void start() {
        System.out.println("开启小米手机");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭小米手机");
    }

    @Override
    public void callup() {
        System.out.println("小米手机打电话");
    }

    @Override
    public void sendSMS() {
        System.out.println("小米手机发信息");
    }
}
```

```java
public class HuaweiRouter implements IRouterProduct {
    @Override
    public void start() {
        System.out.println("启动华为路由器");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭华为路由器");
    }

    @Override
    public void openwifi() {
        System.out.println("华为路由器打开WiFi");
    }

    @Override
    public void setting() {
        System.out.println("设置华为路由器");
    }
}
public class XiaomiRouter implements IRouterProduct {
    @Override
    public void start() {
        System.out.println("启动小米路由器");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭小米路由器");
    }

    @Override
    public void openwifi() {
        System.out.println("小米路由器打开WiFi");
    }

    @Override
    public void setting() {
        System.out.println("设置小米路由器");
    }
}
```

超级工厂接口

```java
//抽象产品工厂
public interface IProductFactory {
    //生产手机
    IphoneProduct iphoneProduct();

    //生产路由器
    IRouterProduct irouterProduct();
}
```

具体工厂实现类

```java
public class HuaweiFactory implements IProductFactory {
    @Override
    public IphoneProduct iphoneProduct() {
        return new HuaweiPhone();
    }

    @Override
    public IRouterProduct irouterProduct() {
        return new HuaweiRouter();
    }
}
public class XiaomiFactory implements IProductFactory {
    @Override
    public IphoneProduct iphoneProduct() {
        return new XiaomiPhone();
    }

    @Override
    public IRouterProduct irouterProduct() {
        return new XiaomiRouter();
    }
}
```

客户

```java
public class Client {
    public static void main(String[] args) {
        System.out.println("=============XIAOMI=============");
        //小米工厂
        XiaomiFactory xiaomiFactory = new XiaomiFactory();

        IphoneProduct iphoneProduct = xiaomiFactory.iphoneProduct();
        iphoneProduct.callup();
        iphoneProduct.sendSMS();

        IRouterProduct iRouterProduct = xiaomiFactory.irouterProduct();
        iRouterProduct.openwifi();
        iRouterProduct.setting();

        System.out.println("=============XIAOMI=============");
        //华为工厂
        HuaweiFactory huaweiFactory = new HuaweiFactory();

        IphoneProduct iphoneProduct1 = huaweiFactory.iphoneProduct();
        iphoneProduct1.callup();
        iphoneProduct1.sendSMS();

        IRouterProduct iRouterProduct1 = huaweiFactory.irouterProduct();
        iRouterProduct1.openwifi();
        iRouterProduct1.setting();
    }
}
```

## 类关系图

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240510201600154-2005888842.png" alt="软件包" style="zoom: 33%;" />

# 建造者模式

## 简介

1. 建造者模式也属于创建型模式，它提供了一种创建对象的最佳方式。

2. 定义︰将一个`复杂对象的构建与它的表示分离`，使得同样的构建过程可以创建不同的表示

3. 主要作用:`在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象`。

4. 用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)

5. 建造者模式的意图和适用场景（拓展）

   - 模式意图

     将一个复杂的构件与其表示相分离,使得同样的构件过程可以创建不同的表示

   - 使用场景   
     - 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性;
     - 当一些基本部件不会变, 而其组合经常变化的时候
     - 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。
     - 适合于一个具有较多的零件（属性)的产品（对象)的创建过程。

6. 例子:

   - 工厂(建造者模式)︰负责制造汽车（组装过>程和细节在工厂内)
   - 汽车购买者（用户)∶你只需要说出你需要的>型号(对象的类型和内容)，然后直接购买就可以使用了(不需要知道汽车是怎么组装的（车轮、车门、>发动机、方向盘等等)

7. 角色分析

   - Director：指挥者，指挥建造的顺序
   - Builder：抽象，定义有哪些步骤
   - Worker：具体的Builder，定义每一步怎么实现。可以有多个

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240510204057925-997021745.png" alt="image-20240510204100780" style="zoom:33%;" />

既然是建造者模式，那么我们还是继续造房吧。

- 假设造房简化为如下步骤：地基、钢筋工程、铺电线、粉刷
- “如果”要盖一座房子
  - 首先要找一个建筑公司或工程承包商(指挥者)。
  - 承包商指挥工人(具体建造者）过来造房子(产品)，最后验收。

## 代码实现

![未命名文件(3)](https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240511100842011-649306157.png)

1. Builder

   抽象建造者,给出一个抽象接口, 以规范产品对象的各个组成成分的建造. 这个接口规定要实现复杂对象的哪些部分的创建,并不涉及具体的对象部件的创建

   ```java
   //抽象的建造者：不负责建造，只定义一些方法
   public abstract class Builder {
       abstract void buildA();
   
       abstract void buildB();
   
       abstract void buildC();
   
       abstract void buildD();
   
       //完工：得到产品
       abstract Product getProduct();
   }
   ```

2. ConcreteBuilder

   实现Builder接口, 针对不同的商业逻辑, 具体化复杂对象的各部分的创建, 即具体建造者

   ```java
   //具体的建造者：工人
   public class Worker extends Builder {
       private Product product;
   
       public Worker() {
           product = new Product();
       }
   
       @Override
       void buildA() {
           product.setBuildA("地基");
           System.out.println("地基");
       }
   
       @Override
       void buildB() {
           product.setBuildB("钢筋工程");
           System.out.println("钢筋工程");
       }
   
       @Override
       void buildC() {
           product.setBuildC("铺电线");
           System.out.println("铺电线");
       }
   
       @Override
       void buildD() {
           product.setBuildD("粉刷");
           System.out.println("粉刷");
       }
   
       @Override
       Product getProduct() {
           return product;
       }
   }
   ```

3. Director

   指挥者, 调用具体建造者来创建复杂对象的各个部分, 在指导者不涉及具体产品的信息, 只负责保证对象各部分完整创建或者按某种顺序创建

   ```java
   //指挥：核心 负责指挥构建一个工程，工程如何构建，由他决定
   public class Director {
       //指挥工人按顺序建房子
       public Product build(Builder builder) {
           builder.buildA();
           builder.buildB();
           builder.buildC();
           builder.buildD();
   
           return builder.getProduct();
       }
   }
   ```

4. Product

   要创建的复杂对象, 即产品角色
   
   ```java
   //产品：房子
   public class Product {
       private String buildA;
       private String buildB;
       private String buildC;
       private String buildD;
   
       @Override
       public String toString() {
           return "Product{" +
                   "buildA='" + buildA + '\'' +
                   ", buildB='" + buildB + '\'' +
                   ", buildC='" + buildC + '\'' +
                   ", buildD='" + buildD + '\'' +
                   '}';
       }
   
       public String getBuildA() {
           return buildA;
       }
   
       public void setBuildA(String buildA) {
           this.buildA = buildA;
       }
   
       public String getBuildB() {
           return buildB;
       }
   
       public void setBuildB(String buildB) {
           this.buildB = buildB;
       }
   
       public String getBuildC() {
           return buildC;
       }
   
       public void setBuildC(String buildC) {
           this.buildC = buildC;
       }
   
       public String getBuildD() {
           return buildD;
       }
   
       public void setBuildD(String buildD) {
           this.buildD = buildD;
       }
   }
   ```

测试：

```java
public class Test {
    public static void main(String[] args) {
        //指挥
        Director director = new Director();
        //指挥 具体的工人完成 产品
        Product build = director.build(new Worker());
        System.out.println(build.toString());
    }
}
```

## 总结 (拓展)

- 建造者模式的使用使得产品的内部表象可独立的变化. 使用建造者模式可以使客户端不必知道产品内部组成的细节
- 每一个Builder都相对独立, 而与其它的Builder无关
- 可使得对构造过程更加精细控制
- 将构建代码和表示代码分开
- 建造者模式的缺点在于难于应付"分步骤构建算法"的需求变动

建造者模式

- 上面示例是Builder模式的常规用法，导演类Director在 Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合。
- 通过静态内部类方式实现零件无序装配构造，这种方式使用更加灵活，更符合定义。内部有复杂对象的默认实现，使用时可以根据用户需求自由定义更改内容，并且无需改变具体的构造方式。就可以生产出不同复杂产品
- 比如:比如麦当劳的套餐，服务员（具体建造者）可以随意搭配任意几种产品（零件）组成一款套餐（产品)，然后出售给客户。比第一种方式少了指挥者，主要是因为第二种方式把指挥者交给用户来操作，使得产品的创建更加简单灵活。

## 静态内部类方式实现

零件无序装配构造

![未命名文件(5)](https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240511102353195-87651630.png)

```java
//建造者
public abstract class Builder {

    abstract Builder builderA(String msg);

    abstract Builder builderB(String msg);

    abstract Builder builderC(String msg);

    abstract Builder builderD(String msg);

    abstract Product getProduct();
}
```

```java
//产品：套餐
public class Product {
    private String BuildA = "汉堡";
    private String BuildB = "可乐";
    private String BuildC = "薯条";
    private String BuildD = "甜点";


    @Override
    public String toString() {
        return "Product{" +
                "BuildA='" + BuildA + '\'' +
                ", BuildB='" + BuildB + '\'' +
                ", BuildC='" + BuildC + '\'' +
                ", BuildD='" + BuildD + '\'' +
                '}';
    }

    public String getBuildA() {
        return BuildA;
    }

    public void setBuildA(String buildA) {
        BuildA = buildA;
    }


    public String getBuildB() {
        return BuildB;
    }

    public void setBuildB(String buildB) {
        BuildB = buildB;
    }

    public String getBuildC() {
        return BuildC;
    }

    public void setBuildC(String buildC) {
        BuildC = buildC;
    }

    public String getBuildD() {
        return BuildD;
    }

    public void setBuildD(String buildD) {
        BuildD = buildD;
    }
}
```

```java
//具体的建造者
public class Worker extends Builder {
    private Product product;

    public Worker() {
        product = new Product();
    }

    @Override
    Builder builderA(String msg) {
        product.setBuildA(msg);
        return this;
    }

    @Override
    Builder builderB(String msg) {
        product.setBuildB(msg);
        return this;
    }

    @Override
    Builder builderC(String msg) {
        product.setBuildC(msg);
        return this;
    }

    @Override
    Builder builderD(String msg) {
        product.setBuildD(msg);
        return this;
    }

    @Override
    Product getProduct() {
        return product;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        //服务员
        Worker worker = new Worker();
        Product product = worker.getProduct();

        System.out.println(product.toString());
        //Product{BuildA='汉堡', BuildB='可乐', BuildC='薯条', BuildD='甜点'}

        //链式编程
        Product product2 = worker.builderA("鸡腿").builderB("雪碧").getProduct();
        System.out.println(product2.toString());
        //Product{BuildA='鸡腿', BuildB='雪碧', BuildC='薯条', BuildD='甜点'}
    }
}
```

## 优缺点

优点:

- 产品的建造和表示分离, 实现了解耦, 使用建造者模式可以使客户端不必知道产品内部组成的细节.
- 将复杂产品的创建步骤分解在不同的方法中, 使得创建过程更加清晰
- 具体的建造者类之间是相互独立的, 这有利于系统的扩展. 增加新的具体建造者无需修改原有的类库的代码, 符合"开闭原则"

缺点:

- 建造者模式所创建的产品一般具有较多的共同点,其组成部分相似; 如果产品之间的差异性很大, 则不适合使用建造者模式, 因此其使用范围受到一定的限制
- 如果产品的内部变化复杂,可能会导致需要定义很多具体建造者类实现这种变化, 导致系统变得很庞大

## 建造者与抽象工厂模式的比较

与抽象工厂模式相比，建造者模式：

- 返回一个组装好的完整产品，
- 而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。

在抽象工厂模式中：

- 客户端实例化工厂类，然后调用工厂方法获取所需产品对象，
- 而在建造者模式中客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。

类比比较：

- 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品
- 那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车!

# 原型模式

## 简介

原型模式【Prototype】：是指将一个对象，完整的克隆出一份。

1. 实现一个Cloneable接口

2. 重写调用clone()方法  [Object类中的]

   ```java
   //super.clone()
   //native：本地C++方法
   protected native Object clone() throws CloneNotSupportedException;
   ```

 应用场景：

1. spring bean：单例模式、原型模式
2. 工厂模式： new 对象- - - 替换成 - - -原型模式

## 代码实现

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240511111325060-712732408.png" alt="image-20240511111328019" style="zoom:50%;" />

### 浅克隆

原型

- 实现一个接口 Cloneable
- 重写一个方法 clone()：直接返回父类的clone()，不做修改

```java
/*

 */
//Video : 原型
public class Video implements Cloneable {
    private String name;
    private Date createTime;
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
    
    //getter/setter/toString/无参构造/有参构造
}
```

副本

- new一个原型
- 副本=原型.clone()

```java
//副本
public class Video2 {
    public static void main(String[] args) throws CloneNotSupportedException {
        //1.原型对象
        Date date = new Date();
        Video v1 = new Video("我是原型", date);

        System.out.println("v1 => " + v1);
        //v1 => Video{name='我是原型', createTime=Sat May 11 10:45:27 CST 2024}
        System.out.println("v1 =>hash " + v1.hashCode());
        //v1 =>hash 21685669

        //2.克隆v1
        Video v2 = (Video) v1.clone();
        System.out.println("v2 => " + v2);
        //v2 => Video{name='我是原型', createTime=Sat May 11 10:45:27 CST 2024}
        System.out.println("v2 =>hash " + v2.hashCode());
        //v2 =>hash 2133927002
    }
}
```

结果：

- 原型和副本值相同
- 哈希值不同

修改Date对象后，观察原型和副本

- 浅克隆：原型和副本关联同一个对象。将对象的值完全拷贝一份，如果属性为引用类型变量，则拷贝属性指向的内存地址
- date修改后，原型和副本都改变了

```java
public static void main(String[] args) throws CloneNotSupportedException {
    Date date = new Date();
    Video v1 = new Video("我是原型", date);
    Video v2 = (Video) v1.clone();

    System.out.println("v1 => " + v1);
    System.out.println("v2 => " + v2);
    /*
    v1 => Video{name='我是原型', createTime=Sat May 11 10:55:02 CST 2024}
    v2 => Video{name='我是原型', createTime=Sat May 11 10:55:02 CST 2024}
     */
    System.out.println("================================");

    date.setTime(12345678);
    System.out.println("v1 => " + v1);
    System.out.println("v2 => " + v2);
    /*
    v1 => Video{name='我是原型', createTime=Thu Jan 01 11:25:45 CST 1970}
    v2 => Video{name='我是原型', createTime=Thu Jan 01 11:25:45 CST 1970}
     */
}
```

### 深克隆

修改原型重写的clone()方法

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    Object obj = super.clone();

    Video v = (Video) obj;
    //将对象的属性也进行克隆
    v.createTime = (Date) this.createTime.clone();

    return obj;
}
```

修改原型Date对象后，观察原型和副本

- 原型的createTime属性发生改变
- 副本不变

```java
v1 => Video{name='我是原型', createTime=Sat May 11 11:07:01 CST 2024}
v2 => Video{name='我是原型', createTime=Sat May 11 11:07:01 CST 2024}
================================
v1 => Video{name='我是原型', createTime=Thu Jan 01 11:25:45 CST 1970}
v2 => Video{name='我是原型', createTime=Sat May 11 11:07:01 CST 2024}
```

# 适配器模式

## 简介

1. 结构性模式作用：从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。
2. 适配器模式
   - 适配器模式就像，USB网线转换器
   - 将一个类的接口转换成客户希望的另外一个接口
   - Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作
3. 角色分析
   - 目标接口: 客户所期待的接口, 目标可以是具体的或抽象的类, 可以是接口
   - 需要适配的类: 需要适配的类或适配者类
   - 适配器: 通过包装一个需要适配的对象, 把原接口转换成目标对象
4. 对象适配器优点
   - 一个对象适配器可以把`多个不同的适配者`适配到同一个目标
   - 可以适配一个适配者的子类,由于适配器和适配者之间是关联关系,根据"里氏代换原则", 适配者的子类也可通过该适配器进行适配
5. 类适配器缺点
   - 对于Java, C#等不支持多重类继承的语言, `一次最多只能适配一个适配者类`,不能同时适配多个适配者,
   - 在Java, C#等语言中, 类适配器模式中的目标抽象类只能为接口, 不能为类, 其使用有一定的局限性
6. 适用场景
   - 系统需要使用一些现有的类，而这些类的接口(如方法名)不符合系统的需求，甚至没有这些类的源代码
   - 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作

## 代码实现

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240511134648361-1686053009.png" alt="image-20240511134651422" style="zoom:67%;" />

### 类适配器

`继承：单继承`

要被适配的类 ：网线

```java
//要被适配的类 ：网线
public class Adaptee {
    public void request() {
        System.out.println("我是网线，可以连我上网");
    }
}
```

客户端类 ： 想上网，插不上网线

```java
//客户端类 ： 想上网，插不上网线
public class Computer {
    //上网 需要连接上转接器
    public void net(NetToUsb adapter) {
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        //电脑、适配器、网线
        Computer computer = new Computer();
        Adapter adapter = new Adapter();
        Adaptee adaptee = new Adaptee();

        computer.net(adapter);
    }
}
```

适配器接口：抽象实现

```java
//接口转换器的抽象实现
public interface NetToUsb {

    //处理请求 网线=>USB
    public void handleRequest();
}
```

真正的适配器类：

- 继承了要被适配的类 ：网线
- 实现了适配器的接口

```java
//真正的适配器 需要连接USB，连接网线
public class Adapter extends Adaptee implements NetToUsb {
    @Override
    public void handleRequest() {
        super.request(); //可以上网了
    }
}
```

在客户端测试类适配器

```java
public class Computer {
    //上网 需要连接上转接器
    public void net(NetToUsb adapter) {
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        //电脑、适配器、网线
        Computer computer = new Computer();
        Adapter adapter = new Adapter();
        Adaptee adaptee = new Adaptee();

        computer.net(adapter);
    }
}
```

### 对象适配器[优先]

`组合：常用`  热拔插

真正的适配器实现类

```java
public class Adapter2 implements NetToUsb {
    private Adaptee adaptee;

    public Adapter2(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void handleRequest() {
        adaptee.request();
    }
}
```

客户端使用适配器

```java
public class Computer {
    //上网 需要连接上转接器
    public void net(NetToUsb adapter) {
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        //电脑、适配器、网线
        Computer computer = new Computer();//电脑
        Adaptee adaptee = new Adaptee();//网线
        Adapter2 adapter = new Adapter2(adaptee);//适配器

        computer.net(adapter);
    }
}
```

# 桥接模式

## 简介

桥接模式：将抽象部分与它的实现部分分离，使他们都可以独立地变化，它是一种对象结构型模式。又称为柄体(Handle and Body)模式或接口(Interface)模式

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240511134805617-971014806.png" alt="image-20240511134808884" style="zoom:50%;" />

上图结构分析 : 

- 多重继承模式，类的个数比较多，扩展比较麻烦；
- 这个场景中有两个变化的维度: 品牌，类型。
- 抽象出两个纬度，减少类的构建：

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240511135012046-886210866.png" alt="image-20240511135015406" style="zoom:50%;" />

桥接模式的优劣势

1. 好处分析:
   - 桥接模式偶尔类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，类的个数也非常多。桥接模式是比多继承方案更好的解决方法，极大的减少了子类的个数，从而降低管理和维护的成本
   - 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。符合开闭原则，就像一座桥，可以把两个变化的维度连接起来!
2. 劣势分析:
   - 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
   - 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性.

最佳实践:

1. 如果一个系统需要在构建的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。
2. 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
3. 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

场景:

1. Java语言通过Java虚拟机实现了平台的无关性。

   <img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240511142657930-1445365007.png" alt="image-20240511142701094" style="zoom:33%;" />

2. AWT中的Peer架构

3. JDBC驱动程序也是桥接模式的应用之一。

## 代码实现

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240511142123677-1261800209.png" alt="未命名文件(6)" style="zoom:50%;" />

品牌接口

```java
//品牌接口
public interface Brand {
    void info();
}
```

苹果品牌

```java
//苹果品牌
public class Apple implements Brand {
    @Override
    public void info() {
        System.out.print("苹果");
    }
}
```

联想品牌

```java
//联想品牌
public class Lenovo implements Brand {
    @Override
    public void info() {
        System.out.print("联想");
    }
}
```

电脑抽象类，及其子类

```java
//抽象的电脑类型
public abstract class Computer {
    //组合，品牌
    protected Brand brand;

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void info() {
        //自带品牌
        brand.info();
    }
}

class Desktop extends Computer {
    public Desktop(Brand brand) {
        super(brand);
    }

    @Override
    public void info() {
        super.info();
        System.out.println("台式-电脑");
    }
}

class Laptop extends Computer {
    public Laptop(Brand brand) {
        super(brand);
    }

    @Override
    public void info() {
        super.info();
        System.out.println("笔记本-电脑");
    }
}
```

测试

```java
public class Test {
    public static void main(String[] args) {
        //苹果-笔记本-电脑
        Computer laptop = new Laptop(new Apple());
        laptop.info();  //苹果笔记本-电脑

        //联想-台式-电脑
        Computer desktop = new Desktop(new Lenovo());
        desktop.info(); //联想台式-电脑
    }
}
```

# 代理模式

是SpringAOP的底层 [SpringAOP和SpringMVC]

代理模式的分类

- 静态代理
- 动态代理

## 静态代理

### 静态代理角色分析

1. 抽象角色 : 一般使用`接口或者抽象类`来实现
2. 真实角色 : 被代理的角色
3. 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作
4. 客户 : 使用代理角色来进行一些操作 .

### 代码实现

1. Rent . java 即抽象角色

   ```java
   //租房的接口
   public interface Rent {
       public void rent();
   }
   ```

2. Host . java 即真实角色

   ```java
   //房东
   public class Host implements Rent {
   
       @Override
       public void rent() {
           System.out.println("房东要出租房子");
       }
   }
   ```

3. Proxy . java 即代理角色

   ```java
   public class Proxy implements Rent {
       private Host host;
   
       public Proxy() {}
   
       public Proxy(Host host) {
           this.host = host;
       }
   
       @Override
       public void rent() {
           seeHouse();
           host.rent();
           hetong();
           fare();
       }
       public void seeHouse() {
           System.out.println("中介带你看房");
       }
       public void fare() {
           System.out.println("收中介费");
       }
       public void hetong() {
           System.out.println("签合同");
       }
   }
   ```

4. Client . java 即客户

   ```java
   //房客
   public class Client {
       public static void main(String[] args) {
           //房东租房子
           Host host = new Host();
           //代理 帮房东租房子，但是会有附属操作
           Proxy proxy = new Proxy(host);
           //不用面对房东 直接找中介
           proxy.rent();
       }
   }
   ```

分析： 在这个过程中，你直接接触的就是中介，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式

## 静态代理的好处

1. 可以使得我们的真实角色更加纯粹！不再去关注一些公共的事情
2. 公共的业务由代理来完成 ！实现了业务的分工 
3. 公共业务发生扩展时，变得更加集中和方便

缺点 :

- 一个真实角色就会产生一个代理角色。类多了 , 工作量变大了， 开发效率降低 .

我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !

## 静态代理理解

1. 创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！  

   ```java
   public interface UserService {
       public void add();
       public void delete();
       public void update();
       public void query();
   }
   ```

2. 我们需要一个真实对象来完成这些增删改查操作

   ```java
   public class UserServiceImpl implements UserService {
       @Override
       public void add() {
           System.out.println("增加了一个用户");
       }
   
       @Override
       public void delete() {
           System.out.println("删除了一个用户");
       }
   
       @Override
       public void update() {
           System.out.println("修改了一个用户");
       }
   
       @Override
       public void query() {
           System.out.println("查询了一个用户");
       }
   }
   ```

3. 需求来了，现在我们需要增加一个日志功能，怎么实现！

   思路1 ：在实现类上增加代码 【麻烦！】

   思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！

4. 设置一个代理类来处理日志！ 代理角色

   ```java
   public class UserServiceProxy implements UserService {
       private UserService userService;
   
       public void setUserService(UserService userService) {
           this.userService = userService;
       }
   
       @Override
       public void add() {
           log("add");
           userService.add();
       }
   
       @Override
       public void delete() {
           log("delete");
           userService.delete();
       }
   
       @Override
       public void update() {
           log("update");
           userService.update();
       }
   
       @Override
       public void query() {
           log("query");
           userService.query();
       }
   
       //日志方法
       public void log(String msg) {
           System.out.println("[Debug]使用了" + msg + "方法");
       }
   }
   ```

5. 测试访问类：

   ```java
   public class Client {
       public static void main(String[] args) {
           UserServiceImpl userService = new UserServiceImpl();
   
           UserServiceProxy proxy = new UserServiceProxy();
           proxy.setUserService(userService);
           proxy.add();
       }
   }
   ```

重点大家需要理解其中的思想：`我们在不改变原来的代码的情况下，实现了对原有功能的增强`，这是AOP中最核心的思想

【聊聊AOP：纵向开发，横向开发】

<img src="https://img2023.cnblogs.com/blog/3406637/202404/3406637-20240429142756203-101162789.png" alt="image-20240429142805253" width="400" />

## 动态代理

### 简介

1. 动态代理的角色和静态代理的一样
2. 动态代理的`代理类是动态生成`的 . 静态代理的代理类是我们提前写好的
3. 动态代理分为两类 : 一类是`基于接口`动态代理 , 一类是`基于类`的动态代理
   - 基于接口的动态代理----JDK动态代理【我们使用】
   - 基于类的动态代理--cglib
   - 现在用的比较多的是 javasist -Java字节码来生成动态代理
   - 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！

JDK的动态代理需要了解两个类核心 : InvocationHandler 和 Proxy

### InvocationHandler调用处理程序

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240503134603959-1478274911.png" alt="image-20240503134604790" width="600" />

invoke方法

```java
//处理代理实例上的方法调用并返回结果
Object invoke(Object proxy,方法 method,Object[] args)

/*：参数
proxy - 调用该方法的代理实例
method -所述方法对应于调用代理实例上的接口方法的实例。 
		方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。
args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。 
*/
```

### Proxy代理

<img src="https://img2023.cnblogs.com/blog/3406637/202405/3406637-20240503135339054-284127216.png" alt="image-20240503135339838" width="500" />

newProxyInstance方法

```java
//返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序
public static Object newProxyInstance(ClassLoader loader,
                                      类<?>[] interfaces,
                                      InvocationHandler h)
/*参数 
loader - 类加载器来定义代理类 
interfaces - 代理类实现的接口列表 
h - 调度方法调用的调用处理函数 
*/
```

### 代码实现

抽象角色和真实角色和之前的一样！

1. Rent . java 即抽象角色

   ```java
   //租房的接口
   public interface Rent {
       public void rent();
   }
   ```

2. Host . java 即真实角色

   ```java
   //房东
   public class Host implements Rent {
   
       @Override
       public void rent() {
           System.out.println("房东要出租房子");
       }
   }
   ```

3. ProxyInvocationHandler. java 即代理角色

   ```java
   //动态生成代理类
   public class ProxyInvocationHandler implements InvocationHandler {
       //被代理的接口
       private Rent rent;
   
       public void setRent(Rent rent) {
           this.rent = rent;
       }
   
       //1.生成得到 代理类
       public Object getProxy() {
           return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(), this);
       }
   
       //2.处理代理实例上的方法调用，并返回结果。
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           //动态代理的本质，就是使用反射机制实现
           seeHouse();
           Object result = method.invoke(rent, args);
           fare();
   
           return result;
       }
   
       //中介带你看房子
       public void seeHouse() {
           System.out.println("中介带你看房子！");
       }
   
       //收中介费
       public void fare() {
           System.out.println("收中介费！");
       }
   }
   ```

4. Client . java

   ```java
   public class Client {
       public static void main(String[] args) {
           //真实角色
           Host host = new Host();
   
           //代理角色：现在没有，只有调用处理程序
           //1.获得调用处理程序
           ProxyInvocationHandler pih = new ProxyInvocationHandler();
           //2.通过调用处理程序 来 处理我们要调用的接口对象
           pih.setRent(host);  //相当于Rent rent=new Host()
           //3.获得动态生成的代理类    我们没有写
           Rent proxy = (Rent) pih.getProxy();
           //4.通过代理类调用接口
           proxy.rent();
       }
   }
   ```

核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！

## 动态代理理解

我们来使用动态代理实现代理我们后面写的UserService！

我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！

```java
//动态生成代理类
public class ProxyInvocationHandler implements InvocationHandler {
    //1.被代理的接口
    private Object target;

    //代理谁
    public void setTarget(Object target) {
        this.target = target;
    }

    //2.生成 代理类
    public Object getProxy() {
        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }

    //3.调用代理类要执行的方法
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //动态代理的本质，就是使用反射机制实现
        log(method.getName());  //通过反射获得方法的名字
        Object result = method.invoke(target, args);

        return result;
    }

    //增加方法
    public void log(String msg) {
        System.out.println("执行了" + msg + "方法");
    }
}
```

测试！  

```java
public class Client {
    public static void main(String[] args) {
        //真实角色
        UserServiceImpl userService = new UserServiceImpl();

        //代理角色
        //1.获取调用处理程序
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        //2.设置要代理的接口-抽象角色  真实对象UserServiceImpl实现了接口
        pih.setTarget(userService);
        //3.动态生成代理类  默认生成Object类型，强转为UserService
        UserService proxy = (UserService) pih.getProxy();

        //通过代理类使用真实对象的方法
        proxy.delete();
    }
}
```

## 动态代理的好处

静态代理有的它都有

- 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .
- 公共的业务由代理来完成 . 实现了业务的分工
- 公共业务发生扩展时，变得更加集中和方便 

静态代理没有的，它也有！

当有多个类实现的是同一个接口的情况下，访问的客户只需要修改真实角色和代理的对象，而在获得代理对象的时候不用改，因为代理角色是动态生成的。

```java
public class Client {
    public static void main(String[] args) {
        //真实角色
        //UserServiceImpl userService = new UserServiceImpl();
        //修改一：
        UserServiceImpl2 userServiceImpl2 = new UserServiceImpl2();

        //代理角色
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
		//修改二：
        pih.setTarget(userServiceImpl2);//设置要代理的接口-抽象角色
        UserService proxy = (UserService) pih.getProxy();

        proxy.delete();
    }
}
```

- 一个动态代理 , 代理的是接口！一般代理某一类业务
- 一个动态代理可以代理多个类，只要是实现了同一个接口

